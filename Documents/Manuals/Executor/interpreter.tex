
This section describes the process for the interpreter. The interpreter reads the plan file and generates the canonical robot commands. The description of this process and subprocesses are mainly described via flowcharts. Samples of \verb!C++! code are used to capture the attention of the reader on important notes.

The main process for the interpreter is depicted in Figure \ref{fig:interpreter} and described in the following subsections.


\begin{figure}[h!]
\centering
\scalebox{.7}{
\begin{tikzpicture}[node distance=1.5cm, every edge/.style={link}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %---------- Main
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \node[cloud] (start) {\textbf{Start}};
  \node[MainAttribute] (parseplan) [rectangle split, rectangle split parts=2, below=1cm of start]
  {
        Parse plan
        \nodepart{second} \textbf{\small{KittingPlan::parsePlanInstance}}
  };
  \draw[myarrow] (start.south) -- (parseplan.north);

   \node[MainAttribute] (parsepddl) [rectangle split, rectangle split parts=2, below=1cm of parseplan]
  {
        Parse PDDL Problem File
        \nodepart{second} \textbf{\small{KittingPDDLProblem::parsePDDLProblem}}
  };
  
  
  \node[MainAttribute] (canonical) [rectangle split, rectangle split parts=2, below=1cm of parsepddl]
  {
        Generate canonical robot commands
        \nodepart{second} \textbf{\small{CanonicalRobotCommand::interpretPlan}}
  };
  
  \draw[myarrow] (parseplan.south) -- (parsepddl.north);
  \draw[myarrow] (parsepddl.south) -- (canonical.north);
  \node[cloud] (end) [below=1cm of canonical] {\textbf{End}};
  \draw[myarrow] (canonical.south) -- (end.north);

\end{tikzpicture}
}
\caption{Main Process for the Interpreter.}
\label{fig:interpreter}
\end{figure}
\newpage


\subsection{Parse Plan}
In this process, the plan file is parsed and each line is read and stored in different lists. The process for parsing the plan file is performed by \textbf{\small{KittingPlan::parsePlanInstance}} and is depicted in Figure~\ref{fig:parseplan}. This figure and the following ones in this document display some functions in rectangle which are split in half. The upper part of these rectangles describes the action performed by the functions and the lower part displays the name of the functions in the \verb!C++! code source.


\begin{figure}[h!t!]
\centering
\scalebox{.75}{
\begin{tikzpicture}[node distance=1.5cm, every edge/.style={link}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %---------- Parse plan
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \node[cloud] (start) {\textbf{Start}};
  
  
  \node[MainAttribute] (parseplan)[rectangle split, rectangle split parts=2, below=1cm of start]
  {
        Parse plan
        \nodepart{second} \textbf{\small{KittingPlan::parsePlanInstance}}
  };
\draw[myarrow] (start.south) -- (parseplan.north);
 %%-- Open Plan file
  \node[entity] (openplan) [below=1cm of parseplan] {Open plan file};
  \draw[myarrow] (parseplan.south) -- (openplan.north);

  %%-- While Loop
  \node[relationship] (whileloop1) [below=1cm of openplan] {Next line available?};
  \draw[myarrow] (openplan.south) -- (whileloop1.north);

  %%-- Remove parentheses
  \node[entity] (removeparentheses) [rectangle split, rectangle split parts=2, below=1cm of whileloop1]
  {
        Remove parentheses
        \nodepart{second} \textbf{\small{FileOperator::removeParentheses}}
  };

  \draw[myarrow] (whileloop1.south) -- node [auto] {yes} (removeparentheses.north);

  %%-- Split strings
  \node[entity] (splitstring) [rectangle split, rectangle split parts=2, below=1cm of removeparentheses]
  {
    Split line into strings
    \nodepart{second} \textbf{\small{FileOperator::splitString}}
  };

  \draw[myarrow] (removeparentheses.south) -- (splitstring.north);



  %%-- Store action and parameters
  \node[entity] (storestring) [below=1cm of splitstring] {Store action and parameters in list \textbf{A}};
  \draw[myarrow] (splitstring.south) -- (storestring.north);

  %%-- Arrow from storestring to the beginning of the loop
  \draw[myarrow] (storestring.west) -- ++ (-1,0) -- ++ (0,4)  |-  ($(openplan.south)!.5!(whileloop1.north)$);

  %%-- Close plan file
  \node[entity] (closefile) [right=5cm of whileloop1] {Close plan file};
  \draw[myarrow] (whileloop1.east) -- node [auto] {no} (closefile.west);

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %---------- Store Parameters
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%-- Read list A
  \node[entity] (readlistA) [below=1cm of closefile] {Read list \textbf{A}};
  \draw[myarrow] (closefile.south) -- (readlistA.north);

  %%-- Store only parameters in list B
  \node[entity] (storeparamlistB) [rectangle split, rectangle split parts=2, below=1cm of readlistA]
    {
    Store parameters in list \textbf{B}
    \nodepart{second} \textbf{\small{KittingPlan::storeParam}}
  };
  \draw[myarrow] (readlistA.south) -- (storeparamlistB.north);

  %%-- Remove duplicates in list B
  \node[entity] (removeduplicates) [rectangle split, rectangle split parts=2, below=1cm of storeparamlistB]
  {
    Remove duplicates in list \textbf{B}
    \nodepart{second} \textbf{\small{FileOperator::removeDuplicates}}
  };
  \draw[myarrow] (storeparamlistB.south) -- (removeduplicates.north);




  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %--------------- Parse PDDL Problem File
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \node[MainAttribute] (parsepddl) [rectangle split, rectangle split parts=2, below=1cm of removeduplicates]
  {
        Parse PDDL Problem File
        \nodepart{second} \textbf{\small{KittingPDDLProblem::parsePDDLProblem}}
  };
  \draw[myarrow] (removeduplicates.south) -- (parsepddl.north);
%
%
%  % Start of loop For
%  % \node[ForLoop] (startloop) [rectangle split, rectangle split parts=2, below=1cm of readplan]
%  %  {
%  %        \textbf{For each line in the plan file}
%  %        \nodepart{second}test
%  %  };
%
%

\end{tikzpicture}
}
\caption{Process for parsing the plan file.}
\label{fig:parseplan}
\end{figure}

The different steps illustrated in Figure~\ref{fig:parseplan} are described below. This process for parsing the plan file is performed by \textbf{\small{KittingPlan::parsePlanInstance}} and is depicted in Figure~\ref{fig:parseplan}.

\begin{itemize}
\item Open plan file: The location and the name of the plan file can be found in the \textit{Config.h} file. The location of the plan file is given by \texttt{\#define PLAN\_FOLDER} and the name of the plan file is given by \texttt{\#define PLAN\_FILE}.
\item Next line available?: This while loop reads each line of the plan file and does the following commands:
\begin{itemize}
\item If there is a next line in the plan file
\begin{itemize}
\item Remove parentheses: To describe this function and the following ones, we will use the following examples which describe two lines of the plan file:\\
    \small{(\planobj{action_A} \planobj{param_{P_1}} \planobj{param_{P_2}})} \\
    \small{(\planobj{action_B} \planobj{param_{P_3}} \planobj{param_{P_2}} \planobj{param_{P_4}})}\\
    The result of this function for each line is:\\
    \small{\planobj{action_A} \planobj{param_{P_1}} \planobj{param_{P_2}}} \\
    \small{\planobj{action_B} \planobj{param_{P_3}} \planobj{param_{P_2}} \planobj{param_{P_4}}}
\item Split line into strings: Each line of the plan file is then split into separate strings.

\item Store action and parameters in list \textbf{A}: Each line is stored in list \textbf{A} defind by \textbf{\small{KittingPlan::m\_actionParamList}}. Using our example the result of this function is:\\
    list \textbf{A}: \small{\planobj{<<action_A,param_{P_1},param_{P_2}><action_B,param_{P_3},param_{P_2},param_{P_4}>>}}
\end{itemize}
\item If there is a next line in the plan file
\begin{itemize}
\item Close plan file
\end{itemize}
\end{itemize}
\item Read list \textbf{A}
\item Store parameters in list \textbf{B}: All parameters present in list \textbf{A} are stored in list \textbf{B}. List \textbf{B} is defined by (\textbf{\small{KittingPlan::m\_paramList}}). The result of this function generates:\\ \small{\planobj{<param_{P_1},param_{P_2},param_{P_3},param_{P_2},param_{P_4}>}}
\item Remove duplicates in list \textbf{B}: Duplicates are removed from list \textbf{B}. In the example, \planobj{param_{P_2}} appears twice. The result returns the following list:\\
    list \textbf{B}: \small{\planobj{<param_{P_1},param_{P_3},param_{P_2},param_{P_4}>}}
\item Parse PDDL Problem File: This process is used to parse the PDDL problem file in order to retrieve the type of each parameter in list \textbf{B}. Section~\ref{parseproblem} gives a deeper description of this process.
\end{itemize}

\newpage
\subsection{Parse the PDDL Problem File}\label{parseproblem}
This process parses the PDDL problem file and retrieves the type for each parameter stored in list \textbf{B}. This process is performed by \textbf{\small{KittingPDDLProblem::parsePDDLProblem}} and is depicted in Figure~\ref{fig:parsepddl}.
\begin{figure}[h!t!]
\centering
\scalebox{.75}{
\begin{tikzpicture}[node distance=1.5cm, every edge/.style={link}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %--------------- Parse PDDL Problem File
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%-- Process for parsing the PDDL problem file
  \node[MainAttribute] (parsepddl) [rectangle split, rectangle split parts=2, below=1cm of parseplan]
  {
        Parse PDDL Problem File
        \nodepart{second} \textbf{\small{KittingPDDLProblem::parsePDDLProblem}}
  };

 %% Open the PDDL problem file
 \node[entity] (openpddlfile) [below=1cm of parsepddl] {Open PDDL problem file};
 \draw[myarrow] (parsepddl.south) -- (openpddlfile.north);
 
 %% Read PDDL problem file into memory
 \node[entity] (memory) [below=1cm of openpddlfile] {Store PDDL problem file into string};
 \draw[myarrow] (openpddlfile.south) -- (memory.north);
  
 \node[entity] (readlistB) [below=1cm of memory] {Read list \textbf{B}};
  \draw[myarrow] (memory.south) -- (readlistB.north);

 % Read first parameter
  \node[ForLoop] (firstparam) [below=1cm of readlistB] {Get first parameter};
  \draw[myarrow] (readlistB.south) -- (firstparam.north);

%%-- insidefor
  \node[relationship] (forloop) [below=1cm of firstparam] {Parameter exists?};
  \draw[myarrow] (firstparam.south) -- (forloop.north);
  

  \node[entity] (findparamPDDL) [rectangle split, rectangle split parts=2, below=1cm of forloop]
  {
        Find parameter in PDDL file
        \nodepart{second} \textbf{\small{KittingPDDLProblem::findParam}}
  };
  \draw[myarrow] (forloop.south) -- node [auto] {yes} (findparamPDDL.north);

   \node[entity] (findline) [rectangle split, rectangle split parts=2, below=1cm of findparamPDDL]
   {
     Find type of parameter in PDDL file
     \nodepart{second} \textbf{\small{KittingPDDLProblem::findParamType}}
   };
  \draw[myarrow] (findparamPDDL.south) -- (findline.north);

  \node[entity] (storeparamtype) [below=1cm of findline] {Store parameter and type in list \textbf{C}};
  \draw[myarrow] (findline.south) -- (storeparamtype.north);

  %%-- Next parameter
  \node[ForLoop] (nextparam) [below=1cm of storeparamtype] {Next parameter};
  \draw[myarrow] (storeparamtype.south) -- (nextparam.north);
  \draw[myarrow] (nextparam.west) -- ++ (-3,0) -- ++ (0,4)  |-  ($(firstparam.south)!.5!(forloop.north)$);

  \node[entity] (closefile) [right=5cm of forloop] {Close PDDL problem file};
  \draw[myarrow] (forloop.east) -- node [auto] {no} (closefile.west);

  \node[MainAttribute] (canonicalr) [rectangle split, rectangle split parts=2, below=1cm of closefile]
  {
        Generate canonical robot commands
        \nodepart{second} \textbf{\small{CanonicalRobotCommand::interpretPlan}}
  };

  \draw[myarrow] (closefile.south) -- (canonicalr.north);

\end{tikzpicture}
}
\caption{Process for parsing the PDDL problem file.}
\label{fig:parsepddl}
\end{figure}

The different steps illustrated in Figure~\ref{fig:parsepddl} are described below.
\begin{itemize}
\item Open PDDL Problem file: The location and the name of the PDDL problem file can be found in the \textit{Config.h} file. The location of the PDDL problem file is given by \texttt{\#define PDDL\_FOLDER} and the name of the problem file is given by \texttt{\#define PDDL\_PROBLEM}.
\item Store PDDL problem file into string: The entire PDDL problem file is read and stored in memory (string).
\item Read list \textbf{B}
\item For each element in \textbf{B}:
\begin{itemize}
\item Find parameter in PDDL problem file: This function retrieves the first occurrence of the parameter in the PDDL problem file. The first occurrence of the parameter appears in the \planobj{:objects} section of the problem file. An excerpt the \planobj{:objects} section for our example is given below:\\
{\scriptsize{1.}}\planobj{(:objects}\\
{\scriptsize{2.}}\hspace*{5mm}\planobj{param_{P_1} - type_A}\\
{\scriptsize{3.}}\hspace*{5mm}\planobj{param_{P_2} - type_B}\\
{\scriptsize{4.}}\hspace*{5mm}\planobj{param_{P_3} - type_C}\\
{\scriptsize{5.}}\hspace*{5mm}\planobj{param_{P_4} - type_D}\\
{\scriptsize{6.}}\planobj{)}

%\begin{minipage}{.5\paperwidth}
%\begin{mylisting}
%\begin{Verbatim}[commandchars=\\\{\},commandchars=+\[\],fontsize=\small,numbersep=3pt]
%(define (problem kitting-problem)
%  (:domain kitting-domain)
%  (:objects
%     Object_1 - Type_A
%	 Object_2 - Type_B
%	 Object_3 - Type_C
%	 Object_4 - Type_D
%     ...
%  )
%\end{Verbatim}
%\end{mylisting}
%\end{minipage}

This function returns a \verb!C++! \texttt{map<string,int>}, where the first element is the parameter and the second element is the line where the parameter was found in the problem file. According to our example, this function returns the following map:\\
\small{\planobj{<<param_{P_1},2><param_{P_3},4><param_{P_2},3><param_{P_4},5>>}}
\item Find type of parameter in PDDL problem file: This function takes as input the \texttt{map} generated in the previous step and the PDDL problem file. For each line number in \texttt{map<string,int>}, the PDDL problem file is read again until the line number is reached. The last element of the line (type of the parameter) in the PDDL file is retrieved.
\item Store parameter in list \textbf{C}: The parameter and its type are stored in list \textbf{C} which is a \verb!C++! \texttt{map<string,string>}. The first element of \texttt{map<string,string>} is the parameter and the second element is its type. list \textbf{C} is defined with \textbf{\small{KittingPDDLProblem::m\_ParamType}}. In our example, the result of this function will be:\\
    \small{\planobj{<<param_{P_1},type_A><param_{P_3},type_C><param_{P_2},type_B><param_{P_4},type_D>>}}
\end{itemize}
\item Close PDDL problem file.
\item Generate canonical robot commands: This process generates the canonical robot commands for each action found in the plan file. More information on this process can be found in section~\ref{robotcommands}.

\end{itemize}



\newpage
\subsection{Generate Canonical Robot Commands}\label{robotcommands}

\begin{figure}[h!t!]
\centering
\scalebox{.7}{
\begin{tikzpicture}[node distance=1.5cm, every edge/.style={link}]

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %--------------- Parse PDDL Problem File
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \node[MainAttribute] (canonical) [rectangle split, rectangle split parts=2]
  {
        Generate canonical robot commands
        \nodepart{second} \textbf{\small{CanonicalRobotCommand::interpretPlan}}
  };
  
  \node[entity] (outputfile) [below=1cm of canonical] {Create output file};
  \draw[myarrow] (canonical.south) -- (outputfile.north);
  
  \node[entity] (initend) [below=1cm of outputfile] {Write \texttt{InitCanon} and \texttt{EndCanon}};
  \draw[myarrow] (outputfile.south) -- (initend.north);
  
  \node[entity] (readlistA) [below=1cm of initend] {Read list \textbf{A}};
  \draw[myarrow] (initend.south) -- (readlistA.north);

  % For
  \node[ForLoop] (firstelement) [below=1cm of readlistA] {Get first element};
  \draw[myarrow] (readlistA.south) -- (firstelement.north);
  
  %%-- insidefor
  \node[relationship] (forloop) [below=1cm of firstelement] {Element exists?};
  \draw[myarrow] (firstelement.south) -- (forloop.north);
  

  \node[entity] (actionparam) [below=1cm of forloop] {Get action name and parameters};
  \draw[myarrow] (forloop.south) -- node [auto] {yes} (actionparam.north);

\node[entity] (interpret) [rectangle split, rectangle split parts=2,below=1cm of actionparam] 
  {
        Interpret action
        \nodepart{second} \textbf{\small{CanonicalRobotCommand::actionInterpreter}}
  };
  \draw[myarrow] (actionparam.south) -- (interpret.north);
  
   \node[entity] (database) [below=1cm of interpret] {Get parameter information from database};
  \draw[myarrow] (interpret.south) -- (database.north);

  \node[entity] (canonical) [below=1cm of database] {Generate canonical commands};
  \draw[myarrow] (database.south) -- (canonical.north);

  \node[entity] (writefile) [below=1cm of canonical] {Write canonical commands in file};
  \draw[myarrow] (canonical.south) -- (writefile.north);

  \node[ForLoop] (nextelement) [below=1cm of writefile] {Next element};
  \draw[myarrow] (writefile.south) -- (nextelement.north);
  \draw[myarrow] (nextelement.west) -- ++ (-3,0) -- ++ (0,4)  |-  ($(firstelement.south)!.5!(forloop.north)$);
  
  \node[cloud] (end) [right=3cm of forloop] {\textbf{End}};
  \draw[myarrow] (forloop.east) -- node [auto] {no} (end.west);
  
\end{tikzpicture}
}
\caption{Process for generating canonical robot commands.}
\label{fig:canonical}
\end{figure}


%\subsection{Main Process}
%% Define block styles
%\tikzstyle{decision} = [diamond, draw, fill=blue!20,
%    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, fill=blockcolor,
%    text width=5em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, -latex']
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
%    minimum height=2em]
%
%\begin{center}
%\begin{tikzpicture}[node distance = 2cm, auto]
%    % Place nodes
%    \node [block] (init) {Read Plan};
%    \node [block, right of=init, node distance=3cm] (problem) {Read PDDL Problem File};
%    \node [block, right of=problem, node distance=3cm] (canonical) {Generate Canonical Robot Commands};
%    \path [line] (init) -- (problem);
%    \path [line] (problem) -- (canonical);
%\end{tikzpicture}
%\end{center}

%\subsubsection{Read Plan}
%\texttt{KittingPlan::parsePlanInstance()}:
%\textit{input}: file name of the plan.
%\begin{itemize}
% \item \texttt{KittingPlan::parseLinePlanInstance()}: Parse each line of the plan file.
% \item \textit{input}: action and parameters.
% \item \textit{example}: (attach-eff robot\_1 tray\_gripper tray\_gripper\_holder)
%\begin{itemize}
%\item \texttt{FileOperator::removeParentheses}: Return each line without the parentheses.
%\item \textit{input}: action and parameters with parentheses: (attach-eff robot\_1 tray\_gripper tray\_gripper\_holder)
%\item \textit{output}: action and parameters without parentheses: attach-eff robot\_1 tray\_gripper tray\_gripper\_holder
%\item \texttt{FileOperator::splitString}: Split each line and store it in a vector.
%\item \textit{input}: action and parameters without parentheses: attach-eff robot\_1 tray\_gripper tray\_gripper\_holder
%\item \textit{output}: vector of actions and parameters: <attach-eff, <robot\_1,tray\_gripper,tray\_gripper\_holder>>
%\end{itemize}
%\end{itemize}

%\subsubsection{Read PDDL Problem File}
%
%\subsubsection{Generate Canonical Robot Commands} 