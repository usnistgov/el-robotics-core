The controller is designed to provide a queue for storing commands during the execution procedure. It provides classes for each of the canonical robot commands, a queuing and dequeuing mechanism, and virtual functions for processing each command. A sample controller is also provided. The files in the distribution are located in the controller directory and consist of:

\begin{itemize}
 \item \texttt{canonicalMsg.hh} - The header file that provides classes for all of the canonical robot commands.
 \item \texttt{controller.cpp} - The base class that should be extended to create the controller.
 \item \texttt{controller.hh} - Include file for the base class.
 \item \texttt{Makefile} - The makefile
 \item \texttt{myController.cpp} - Sample controller that extends the controller class and creates routines to process all of the canonical robot commands.
 \item \texttt{myController.hh} - Include file for above.
 \item \texttt{test.cpp} -  Sample threaded controller. The application uses the ulapi routines to create two threads. Thread 1 stuffs commands into the queue. Thread 2 reads them out and processes them.
 \item \texttt{ulapi.cpp} - Machine independent routines for items such as thread control and time.
 \item \texttt{ulapi.hh} -  Include file for above.
\end{itemize}

To run the sample code, compile the application and library (type make), and then issue the command \textbf{./test}. You should see print outs that show commands being queued and executed.