\section{State-Variable Representation}
In a SVR, each state is represented by a tuple of values of $n$ state variables $\lbrace x_1,\dots,x_n\rbrace$, and each action is represented by a partial function that maps this tuple into some other tuple of values of the $n$ state variables.\\ \\
To build the SVR, the group has taken a very systematic approach of identifying and modeling the concepts. Because the industrial robot field is so broad, the group decided to limit its efforts to a single type of operation, namely kitting. A scenario was developed that described, in detail, the types of operations that would be performed in kitting, the sequencing of steps, the parts and machines that were needed, constraints on the process such as pre- and post-conditions, etc. For this scenario, a set of concepts were extracted and defined. These concepts served as the initial requirements for the kitting SVR. The concepts were then modeling in our SVR, building off of the definitions and relationships that were identified in the scenario. A SVR relies on the elements of constant variable symbols, object variable symbols, state variable symbols, rigid relations, and planning operators. These are defined for the kitting domain in the rest of this section.


\subsection{Constant Variable Symbols}
For the kitting domain, there is a finite set of constant variable symbols that must be represented. In the SVR, constant variable symbols are partitioned into disjoint classes corresponding to the objects of the domain. The finite set of all constant variable symbols in the kitting domain is partitioned into the following sets:
%\begin{small}
\begin{itemize}
\item A set of \class{Part} \{\const{part\_a\_1},\const{part\_a\_2},\ldots\}: A \class{Part} is the basic item that will be used to fill a kit.

\item A set of \class{PartsTray} \{\const{part\_a\_tray},\const{part\_b\_tray},\ldots\}: \class{Parts} arrive at the workstation in \class{PartsTrays}. Each \class{Part} is at a known position in the \class{PartsTray}. Each \class{PartsTray} contains one type of \class{Part}.

\item A set of \class{KitTray} \{\const{kit\_tray\_1},\const{kit\_tray\_2},\ldots\}:  A \class{KitTray} can hold \class{Parts} in known positions.

\item A set of \class{Kit} \{\const{kit\_1},\const{kit\_2},\ldots\}: A \class{Kit} consists of a \class{KitTray} and, possibly, some \class{Parts}. A \class{Kit} is empty when it does not contain any \class{Part} and finished when it contains all the \class{Parts} that constitute a kit.

\item A symbol \class{WorkTable} \const{work\_table\_1}: A \class{WorkTable} is an area in the kitting workstation where \class{KitTrays} are placed to build \class{Kits}.

\item A set of \class{LargeBoxWithKits} \{\const{finished\_kit\_receiver\_1},\const{finished\_kit\_receiver\_2},\ldots\}: A \class{LargeBoxWithKits} contains only finished \class{Kits}.

\item A set of \class{LargeBoxWithEmptyKitTrays} \{\const{empty\_kit\_tray\_supply\_1}, \const{empty\_kit\_tray\_supply\_2},\ldots\}: A \class{LargeBoxWithEmptyKitTrays} is a box that contains only empty \class{KitTrays}.

\item A set of \class{Robot} \{\const{robot\_1},\const{robot\_2},\ldots\}: A \class{Robot} in the kitting workstation is a robotic arm that can move objects in order to build \class{Kits}.

\item A set of \class{EndEffector} \{\const{part\_gripper},\const{tray\_gripper},\ldots\}: \class{EndEffectors} are used in a kitting workstation to manipulate \class{Parts}, \class{PartsTrays}, \class{KitTrays}, and \class{Kits}. A \class{EndEffector} is attached to a \class{Robot}.

\item A set of \class{EndEffectorHolder}  \{\const{part\_gripper\_holder},\const{tray\_gripper\_holder}, \ldots\}: An \class{EndEffectorHolder} is a storage unit that holds one type of \class{EndEffector}.

\item A symbol \class{EndEffectorChangingStation} \const{changing\_station\_1}: An \class{EndEffectorChangingStation} is made up of \class{EndEffectorHolders}.
\end{itemize}
%\end {small}

\subsection{Object Variable Symbols}
Object variable symbols are typed variables which range over a class or the union of classes of constant variable symbols. Examples of object variable symbols are \const{r} $\in$ \class{Robots}, \const{kt} $\in$ \class{KitTrays}, etc.

\subsection{State Variable Symbols}
\label{subsubsect:State_Variable_Symbols}
A state variable symbol is defined as follows:
$\mathrm{x: A_1\times \dots\times A_i\times S\rightarrow B_1\cup\dots\cup B_j}$ ($i, j\geq 1$) is a function from the set of states ($\mathrm{S}$) and at least one set of constant variable symbols $\mathrm{A_1\times \dots\times A_i}$ into a set of constant variable symbols $\mathrm{B_1\cup\dots\cup B_j}$.\\

\noindent
The use of state variable symbols reduces the possibility of inconsistent states and generates a smaller state space. The following state variable symbols are used in the kitting domain:

\begin{itemize}
\item \stvar{efflocation}: \class{EndEffector}$\mathrm{\times S\rightarrow}$\class{Robot} $\cup$ \class{EndEffectorHolder}: designates the location of a \class{EndEffector} in the workstation. A \class{EndEffector} is either attached to a \class{Robot} or placed in an \class{EndEffectorHolder}.

\item \stvar{r-eff}: \class{Robots}$\mathrm{\times S\rightarrow}$\class{EndEffector} $\cup$ \{\textit{nil}\}: designates the \class{EndEffector} attached to a \class{Robot} if there is one attached, otherwise \textit{nil}.

\item \stvar{on-worktable}: \class{WorkTable}$\mathrm{\times S\rightarrow}$\class{Kit} $\cup$ \class{KitTray} $\cup$ \{\textit{nil}\}: designates the object placed on the \class{WorkTable}, i.e., a \class{Kit}, a \class{KitTray}, or nothing (\textit{nil}).

\item \stvar{kitlocation}: \class{Kit}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithKits} $\cup$ \class{WorkTable} $\cup$ \class{Robots}: designates the different possible locations of a \class{Kit} in the workstation, i.e., in a \class{LargeBoxWithKits}, on the \class{WorkTable}, or being held by a \class{Robot}.

\item \stvar{kittraylocation}: \class{KitTray}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithEmptyKitTrays} $\cup$ \class{Robots} $\cup$ \class{WorkTable}: designates the different possible locations of a \class{KitTray} in the workstation, i.e., in a \class{LargeBoxWithEmptyKitTrays}, on a \class{WorkTable} or being held by a \class{Robot}.

\item \stvar{partlocation}: \class{Part}$\mathrm{\times S\rightarrow}$\class{PartsTray} $\cup$ \class{Kit} $\cup$ \class{Robots}: designates the different possible locations of a \class{Part} in the workstation, i.e., in a \class{PartTray}, in a \class{Kit}, or being held by a \class{Robot}.

\item \stvar{rhold}: \class{Robot}$\mathrm{\times S\rightarrow}$\class{KitTray} $\cup$ \class{Kit} $\cup$ \class{Part} $\cup$ \{\textit{nil}\}: designates the object being held by a \class{Robot}, i.e., a \class{KitTray}, a \class{Kit}, a \class{Part}, or nothing (\textit{nil}). It is assumed that the \class{Robot} is already equipped with the appropriate \class{EndEffector}.

\item \stvar{islbwkfull}: \class{LargeBoxWithKits}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{LargeBoxWithKits} is full (1) or not (0).

\item \stvar{islbwektempty}: \class{LargeBoxWithEmptyKitTrays}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{LargeBoxWithEmptyKitTrays} is empty (1) or not (0).

\item \stvar{isptempty}: \class{PartsTray}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{PartsTray} is empty (1) or not (0).

\item \stvar{efftype}: \class{EndEffector}$\mathrm{\times S \rightarrow}$\class{KitTray} $\cup$ \class{Kit} $\cup$ \class{Part}: designates the type of object an \class{EndEffector} can hold, i.e., a \class{KitTray}, a \class{Kit}, or a \class{Part}.

\item \stvar{effhold-eff}: \class{EndEffectorHolder}$\mathrm{\times S \rightarrow}$\class{EndEffector} $\cup$ \{\textit{nil}\}: designates the object an \class{EndEffectorHolder} is holding, i.e., a \class{EndEffector} or nothing.
\end{itemize}


\subsection{Rigid Relations}
\label{subsubsect:Rigid_Relation}
\stvar{efftype} and \stvar{effhold-eff} are rigid relations since their values do not vary from one state to another. In each state, a given \class{EndEffector} will always hold the same type of object and a given \class{EndEffectorHolder} will always hold the same \class{EndEffectors}.

\subsection{Planning Operators and Actions}
\label{subsect:Planning_Operators}
The planning operators presented in this section will be expressed in classical representation instead of state variable representation. In classical representation, states are represented as sets of logical atoms that are true or false within some interpretation. Actions are represented by planning operators that change the truth values of these atoms. Predicates and actions in the domain and problem PDDL files (see Section~\ref{S:PDDL}) need to be expressed with logical atoms, hence the use of classical representation.

\subsubsection{Convert State Variable Symbols to Atoms}
In order to use sets of logical atoms, the state variable symbols (SVSs) presented in Section~\ref{subsubsect:State_Variable_Symbols} are converted into predicates (PRED). A state variable symbol can be split into multiple predicates as follows:
\begin{itemize}
 \item \stvar{SVS}
  \begin{itemize}
  \item \stvar{PRED1} (\class{param1},\class{param2}, \ldots)
  \item \stvar{PRED2} (\class{param1},\class{param2}, \ldots)
  \item \ldots
  \end{itemize}
\end{itemize}


The state variable symbols and their corresponding predicates for kitting are presented below:
\begin{itemize}
 \item \stvar{efflocation}
  \begin{itemize}
  \item \stvar{eff-location}(\class{EndEffector},\class{Robot}) ;TRUE iff \class{EndEffector} is attached to \class{Robot}
  \item \stvar{eff-location}(\class{EndEffector},\class{EndEffectorHolder}) ;TRUE iff \class{EndEffector} is in \class{EndEffectorHolder}
  \end{itemize}

 \item \stvar{r-eff}
  \begin{itemize}
  \item \stvar{r-with-eff}(\class{Robot},\class{EndEffector}) ;TRUE iff \class{Robot} is equipped with \class{EndEffector}
  \item \stvar{r-no-eff}(\class{Robot}) ;TRUE iff \class{Robot} is not equipped with any \class{EndEffector}	
  \end{itemize}

 \item \stvar{on-worktable}
  \begin{itemize}
  \item \stvar{onworktable}(\class{WorkTable},\class{Kit}) ;TRUE iff \class{Kit} is on the \class{WorkTable}
  \item \stvar{onworktable}(\class{WorkTable},\class{KitTray}) ;TRUE iff \class{KitTray} is on the \class{WorkTable}
  \item \stvar{worktable-empty}(\class{WorkTable}) ;TRUE iff there is nothing on the \class{WorkTable}
  \end{itemize}

 \item \stvar{kitlocation}
  \begin{itemize}
  \item \stvar{kit-location}(\class{Kit},\class{LargeBoxWithKits}) ;TRUE iff \class{Kit} is in the \class{LargeBoxWithKits}
  \item \stvar{kit-location}(\class{Kit},\class{WorkTable}) ;TRUE iff \class{Kit} is on the \class{WorkTable}
  \item \stvar{kit-location}(\class{Kit},\class{Robot}) ;TRUE iff \class{Kit} is being held by the \class{Robot}	
  \end{itemize}

 \item \stvar{ktlocation}
  \begin{itemize}
  \item \stvar{kit-tray-location}(\class{KitTray},\class{LargeBoxWithEmptyKitTrays}) ;TRUE iff \class{KitTray} is in the \class{LargeBoxWithEmptyKitTrays}	
  \item \stvar{kit-tray-location}(\class{KitTray},\class{Robot}) ;TRUE iff \class{KitTray} is being held by the \class{Robot}
  \item \stvar{kit-tray-location}(\class{KitTray},\class{WorkTable}) ;TRUE iff \class{KitTray} is on the \class{WorkTable}
  \end{itemize}

 \item \stvar{partlocation}
  \begin{itemize}
    \item \stvar{part-location}(\class{Part},\class{PartsTray}) ;TRUE iff \class{Part} is in the \class{PartsTray}	
    \item \stvar{part-location}(\class{Part},\class{Kit}) ;TRUE iff \class{Part} is in the \class{Kit}
    \item \stvar{part-location}(\class{Part},\class{Robot}) ;TRUE iff \class{Part} is being held by the \class{Robot}
  \end{itemize}

 \item \stvar{rhold}
  \begin{itemize}
    \item \stvar{rhold}(\class{Robot},\class{KitTray}) ;TRUE iff \class{Robot} is holding a \class{KitTray}	
    \item \stvar{rhold}(\class{Robot},\class{Kit}) ;TRUE iff \class{Robot} is holding a \class{Kit}
    \item \stvar{rhold}(\class{Robot},\class{Part}) ;TRUE iff \class{Robot} is holding a \class{Part}
    \item \stvar{rhold-empty}(\class{Robot}) ;TRUE iff \class{Robot} is not holding anything
  \end{itemize}

 \item \stvar{islbwkfull}
  \begin{itemize}
    \item \stvar{lbwk-not-full}(\class{LargeBoxWithKits}) ;TRUE iff \class{LargeBoxWithKits} is not full	
  \end{itemize}

 \item \stvar{islbwektempty}
  \begin{itemize}
    \item \stvar{lbwekt-not-empty}(\class{LargeBoxWithEmptyKitTrays}) ;TRUE iff \class{LargeBoxWithEmptyKitTrays} is not empty
  \end{itemize}

 \item \stvar{isptempty}
  \begin{itemize}
    \item \stvar{part-tray-not-empty}(\class{PartsTray}) ;TRUE iff \class{PartsTray} is not empty
  \end{itemize}

 \item \stvar{efftype}
  \begin{itemize}
    \item \stvar{efftype}(\class{EndEffector},\class{KitTray}) ;TRUE iff \class{EndEffector} is capable of holding a \class{KitTray}	 
    \item \stvar{efftype}(\class{EndEffector},\class{Kit}) ;TRUE iff \class{EndEffector} is capable of holding a \class{Kit}
    \item \stvar{efftype}(\class{EndEffector},\class{Part}) ;TRUE iff \class{EndEffector} is capable of holding a \class{Part}
  \end{itemize}

 \item \stvar{effhold-eff}
  \begin{itemize}
    \item \stvar{effhold-eff}(\class{EndEffectorHolder},\class{EndEffector}) ;TRUE iff \class{EndEffectorHolder} is holding \class{EndEffector}
    \item \stvar{effh-empty}(\class{EndEffectorHolder}) ;TRUE iff \class{EndEffectorHolder} is empty ( not holding a \class{EndEffector})
  \end{itemize}
\end{itemize}


\subsubsection{Planning Operators}
 In classical planning, a planning operator~\cite{NAU.2004} is a triple \textit{o=(name(o), precond(o), effects(o))} whose elements are as follows:
\begin{itemize}
\item name(o) is a syntactic expression of the form $n(x_1,\dots,x_k)$, where $n$ is a symbol
called an operator symbol, $x_1,\dots,x_k$ are all of the object variable symbols that
appear anywhere in \textit{o}, and $n$ is unique (i.e., no two operators can have the
same operator symbol).
\item precond(o) and effects(o) are sets of literals (i.e., atoms and negations of atoms). Literals that are true in precond(o) but false in effects(o) are removed by using negations of the appropriate atoms.
\end{itemize}

Our kitting domain is composed of nine operators which are defined below.


\begin{enumerate}
\item \op{take-kit-tray}(\const{r},\const{kt},\const{lbwekt},\const{eff},\const{wtable}): The \class{Robot} \const{r} equipped with the \class{EndEffector} \const{eff} picks up the \class{KitTray} \const{kt} from the \class{LargeBoxWithEmptyKitTrays} \const{lbwekt}.

\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{rhold-empty}(\const{r}),&$\neg$\stvar{rhold-empty}(\const{r}),\\
  \stvar{lbwekt-not-empty}(\const{lbwekt}),&\stvar{kit-tray-location}(\const{kt},\const{r}),\\
  \stvar{r-with-eff}(\const{r},\const{eff}),&\stvar{rhold}(\const{r},\const{kt}), \\
  \stvar{kit-tray-location}(\const{kt},\const{lbwekt}),&$\neg$\stvar{kit-tray-location}(\const{kt},\const{lbwekt}) \\
  \stvar{eff-location}(\const{eff},\const{r}),&\\
  \stvar{worktable-empty}(\const{wtable}),& \\
  \stvar{efftype}(\const{eff},\const{kt})&
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-kit-tray}(\const{r},\const{kt},\const{wtable}): The \class{Robot} \const{r} puts down the \class{KitTray} \const{kt} on the \class{WorkTable} \const{wtable}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{kit-tray-location}(\const{kt},\const{r}),&$\neg$\stvar{kit-tray-location}(\const{kt},\const{r}),\\
  \stvar{rhold}(\const{r},\const{kt}),&$\neg$\stvar{rhold}(\const{r},\const{kt}),\\
  \stvar{worktable-empty}(\const{wtable})&$\neg$\stvar{worktable-empty}(\const{wtable}),\\
  &\stvar{kit-tray-location}(\const{kt},\const{wtable}),\\
  &\stvar{rhold-empty}(\const{r}),\\
  &\stvar{onworktable}(\const{wtable},\const{kt})\\
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{take-kit}(\const{r},\const{kit},\const{wtable},\const{eff}): The \class{Robot} \const{r} equipped with the \class{EndEffector} \const{eff} picks up the \class{Kit} \const{kit} from the \class{WorkTable} \const{wtable}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{kit-location}(\const{kit},\const{wtable}),&$\neg$\stvar{kit-location}(\const{kit},\const{wtable}),\\
  \stvar{rhold-empty}(\const{r}),&$\neg$\stvar{rhold-empty}(\const{r}),\\
  \stvar{onworktable}(\const{wtable},\const{kit}),&$\neg$\stvar{onworktable}(\const{wtable},\const{kit}),\\
  \stvar{r-with-eff}(\const{r},\const{eff}),&\stvar{kit-location}(\const{kit},\const{r}),\\
  \stvar{efftype}(\const{eff},\const{kit})&\stvar{rhold}(\const{r},\const{kit}),\\
  &\stvar{worktable-empty}(\const{wtable})
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-kit}(\const{r},\const{kit},\const{lbwk}): The \class{Robot} \const{r} puts down the \class{Kit} \const{kit} in the \class{LargeBoxWithKits} \const{lbwk}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{kit-location}(\const{kit},\const{r}),&$\neg$\stvar{kit-location}(\const{kit},\const{r}),\\
  \stvar{rhold}(\const{r},\const{kit}),&$\neg$\stvar{rhold}(\const{r},\const{kit}),\\
  \stvar{lbwk-not-full}(\const{lbwk})&\stvar{kit-location}(\const{kit},\const{lbwk}),\\
  &\stvar{rhold-empty}(\const{r})
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{take-part}(\const{r},\const{part},\const{pt},\const{eff},\const{wtable},\const{kit}): The \class{Robot} \const{r} uses the \class{EndEffector} \const{eff} to pick up the \class{Part} \const{part} from the \class{PartTray} \const{pt}. The \class{Kit} \const{kit} must \textit{a priori} be on the \const{wtable}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{part-location}(\const{part},\const{pt}),&$\neg$\stvar{part-location}(\const{part},\const{pt}),\\
  \stvar{eff-location}(\const{eff},\const{r}),&\stvar{rhold}(\const{r},\const{part}),\\
  \stvar{rhold-empty}(\const{r}),&$\neg$\stvar{rhold-empty}(\const{r}),\\
  \stvar{r-with-eff}(\const{r},\const{eff}),&\stvar{part-location}(\const{part},\const{r})\\
  \stvar{onworktable}(\const{wtable},\const{kins}),&\\
  \stvar{kit-location}(\const{kit},\const{wtable}),&\\
  \stvar{efftype}(\const{eff},\const{part}),&\\
  \stvar{part-tray-not-empty}(\const{pt})&
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-part}(\const{r},\const{part},\const{kit},\const{wtable}): The \class{Robot} \const{r} puts down the \class{Part} \const{part} in the \class{Kit} \const{kit}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{part-location}(\const{part},\const{r}),&$\neg$\stvar{part-location}(\const{part},\const{r}),\\
  \stvar{rhold}(\const{r},\const{part}),&$\neg$\stvar{rhold}(\const{r},\const{part}),\\
  \stvar{onworktable}(\const{wtable},\const{kins}),&\stvar{part-location}(\const{part},\const{kit}),\\
  \stvar{kit-location}(\const{kit},\const{wtable})&\stvar{rhold-empty}(\const{r})
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{attach-eff}(\const{r},\const{eff},\const{effh}): The \class{Robot} \const{r} attaches the \class{EndEffector} \const{eff} which is situated in the \class{EndEffectorHolder} \const{effh}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{eff-location}(\const{eff},\const{effh}),&$\neg$\stvar{eff-location}(\const{eff},\const{effh}),\\
  \stvar{r-no-eff}(\const{r}),&$\neg$\stvar{r-no-eff}(\const{r}),\\
  \stvar{effhold-eff}(\const{effh},\const{eff})&$\neg$\stvar{effhold-eff}(\const{effh},\const{eff}),\\
  $\neg$\stvar{effh-empty}(\const{effh}) &\stvar{rhold-empty}(\const{r}),\\
  &\stvar{eff-location}(\const{eff},\const{r}),\\
  &\stvar{r-with-eff}(\const{r},\const{eff}),\\
  &\stvar{effh-empty}(\const{effh})
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{remove-eff}(\const{r},\const{eff},\const{effh}): The \class{Robot} \const{r} removes the \class{EndEffector} \const{eff} and puts it in the \class{EndEffectorHolder} \const{effh}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{eff-location}(\const{eff},\const{r}),&$\neg$\stvar{eff-location}(\const{eff},\const{r}),\\
  \stvar{r-with-eff}(\const{r},\const{eff}),&$\neg$\stvar{r-with-eff}(\const{r},\const{eff}),\\
  \stvar{rhold-empty}(\const{r})&\stvar{eff-location}(\const{eff},\const{effh}),\\
  &\stvar{effhold-eff}(\const{effh},\const{eff}),\\
  &\stvar{r-no-eff}(\const{r})
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{create-kit}(\const{kit},\const{kt},\const{wtable}): The \class{KitTray} \const{kt} is converted to the \class{Kit} \const{kit} once the \class{KitTray} \const{kt} is on the \class{WorkTable} \const{wtable}.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{onworktable}(\const{wtable}\const{kt})&$\neg$\stvar{onworktable}(\const{wtable},\const{kt}),\\
&\stvar{kit-location}(\const{kit},\const{wtable}),\\
&\stvar{onworktable}(\const{wtable},\const{kit})\\
\end{tabular}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{enumerate}

\subsubsection{Actions}
An action \textit{a} can be obtained by substituting the object variable symbols that
appear anywhere in the operator with constant variable symbols. For instance, the operator \op{take-p}(\const{r},\const{part},\const{pt},\const{eff}) in the kitting domain can be translated into the action \op{take-p}(\const{r_1},\const{part_1},\const{pt_1},\const{eff_2}) where \const{r_1}, \const{part_1}, \const{pt_1}, and \const{eff_2} are constant variable symbols in the classes \class{Robots}, \class{Parts}, \class{PartsTrays}, and \class{EndEffectors}, respectively.





