\section{System Overview}
\label{sect:overview}
The kitting system that has been implemented as part of this work is a deliberative intelligent system based on the 4D/RCS 
reference model architecture\cite{Albus2000}. This architecture is a hierarchical architecture in which each echelon or level
follows a sense-model-act paradigm. The basic structure of the system may be seen in Figure \ref{fig:SenseModelAct}.
%
\subsection{Sense}
\label{subsection:Sense}
In order to sense action failures associated with kit building, it is necessary to be able to detect the six-degree of freedom pose of relevant objects in the
world. One issue with pose detection is the large number of potential target objects and object classes in the world. 
Both the number of objects and potential classes can be reduced by intelligently
selecting critical objects of interest that are tagged with predicted locations and object class for the sensor system to track. This object selection, 
also known as focus of attention, is guided by
the executor process with knowledge obtained from preconditions and effects of planned actions.
Actual algorithm development for pose and object detection is an active research area, and is beyond the scope of this article. 

For our purposes, 
we have assumed the use of a high-quality
system that is capable of recognizing a limited variety of items in a controlled environment and then determining the item's pose. This is accomplished through
simulation by using the Unified System for Automation and Robot Simulation (USARSim) \cite{Balakirsky2007}. As described in Section \ref{sect:future}, 
we intend to relax this assumption in the near future.
%
\begin{figure}[htb!]
\begin{center}
\includegraphics[width=8.5cm]{images/RITAWorldModel.pdf}
\caption{System World Model - The world model contains an ontology shown in green,
a Planning Domain Definition Language (PDDL) specification shown in blue, and a dynamic database shown in orange.}
\label{fig:WorldModel}
\end{center}
\end{figure}
%
\subsection{Model}
\label{subsection:Model}
The world model that is being utilized is shown in Figure \ref{fig:WorldModel}. The model contains knowledge that is structured specifically for
reasoning, planning, and execution. All of the concepts necessary for the manufacturing domain under test are
encoded in the ontology that resides in the reasoning section of the model. The planning and execution sections of the model are automatically generated from
this section.
%
\subsubsection{Ontology --}
\label{sect:Ontology}
The reasoning portion of the world model is designed to contain all of the information needed to reason over and solve complex manufacturing
problems. The knowledge is represented in an ontology that is structured in three levels. The first part of the ontology is an upper ontology
that contains generic information and classes that are needed for the domain of kit building. 

This area of the ontology contains information on basic elements such as a ``point" which is defined as a class that contains a name 
and a three-dimensional quantity, as well as complex types such as a ``part'', which is
shown in Figure \ref{fig:part}, and
contains elements such as a the part's shape, stock keeping unit (SKU) number, and location. This information is utilized to create parameters for the Planning World
Model and the skeleton tables for the mySQL database of the Execution World Model.
%
\begin{figure}[htb!]
\begin{center}
\includegraphics[width=8.5cm]{images/Part.jpg}
\caption{Description of the PartType class that is designed to contain both static and dynamic information about particular parts.}
\label{fig:part}
\end{center}
\end{figure}
%
Both static and dynamic information is represented in this
ontology and is automatically transitioned into the Planning and Execution areas of the world model. During system
operation,  dynamic information is updated in the Execution World Model.
More information on this portion of the ontology may be found in \cite{Balakirsky2012-1}.


The second level of the ontology (known as States, Ordering constraints, Actions, and Predicates or SOAP) contains the high-level concept of an action and all of the concepts 
that are required to support an action. In this case, a Planning Domain Definition Language (PDDL) \cite{PDDL} action is being represented, and this action is defined
 as an operator that causes one or more properties of an 
instance to change. Before this action may be
performed, certain preconditions must be satisfied, and after the action is performed, certain effects will take place. The action accepts parameters that specify the particular
instances that will be affected, where an instance refers to a physical object in the world. The classes used to represent the actions in the ontology are provided in the
enumerated list shown below. The naming convention utilized follows the OWL \cite{OWLoverview} implementation of the ontology.

ZEID, FIX HERE!

\begin{enumerate}
\item \class{Action} -- An \class{Action} has a \class{Precondition} and an \class{Effect}. An \class{Action} has a \class{ParameterList} that contains all the parameters for an action. An action has a unique name.
\item \class{ParameterList} -- Actions may have multiple parameters of different types. Each one of these types is represented by a class in the upper ontology. The \class{ParameterList} has \class{Parameter}s that are instances from the upper ontology. The order of the parameters in an  action also needs to be represented in the ontology. OWL has no built-in structure to represent an ordered list, instead, the \class{Parameter}, uses \emph{hasParameter\_Next} to point to the next parameter in \class{ParameterList}.
\item \class{Precondition} -- A \class{Precondition} can consist of a \class{Predicate}, a \class{Function}, a \class{FunctionBool}, or a combination of these three classes. A \class{Precondition} belongs to one \class{Action}.
\item \class{Effect} -- An \class{Effect} can consist of a \class{Predicate}, a \class{Function}, \class{FunctionBool}, or a combination of these three classes. An \class{Effect} belongs to one \class{Action}. A negative \class{Predicate} is represented with the declaration of \emph{hasEffect\_Predicate} within the OWL built-in property assertion \texttt{owl:NegativePropertyAssertion}.
\item \class{Predicate} -- A \class{Predicate} has a unique name  of type \texttt{string}. A \class{Predicate} has a reference parameter and a target parameter. A reference parameter is the first parameter in the \class{Predicate}'s list and the target parameter is the second parameter in the parameter's list. A \class{Predicate} cannot have more than two parameters due to the inherent definition of \class{Predicates}. In the case where a \class{Predicate} has only one parameter, it is assigned to the reference parameter. Reference and target parameters are one of the parameters defined for the \class{Action} to which the \class{Predicate} belongs.
    
    The meaning of reference and target parameters lies in the definition of a state variable. We recall the following definition of a state variable $\mathrm{x: A_1\times \dots\times A_i\times S\rightarrow B_1\cup\dots\cup B_j}$ ($i, j\geq 1$) that is used to convert state variables into predicates as follows:

\begin{itemize}
 \item $\mathrm{A_1\times \dots\times A_i\times S\rightarrow B_1\cup\dots\cup B_j}$ ($i, j\geq 1$)
  \begin{itemize}
  \item \stvar{predicate\_1}($\mathcal{A,B}$)
  \item \ldots
  \item \stvar{predicate\_n}($\mathcal{A,B}$)
  \end{itemize}
\end{itemize}

Where $\mathcal{A} \in \mathrm{\{A_1,\ldots,A_i\}}$ and $\mathcal{B} \in \mathrm{\{B_1,\ldots,B_i\}}$ ($i, j\geq 1$)

From this methodology, we have defined a predicate's parameter as a reference parameter if the parameter belongs to the set $\mathcal{A}$. Similarly, we have defined a predicate's parameter as a target parameter if the parameter belongs to the set $\mathcal{B}$. For instance, the predicate \texttt{(part-location-robot ?part ?robot)} has \texttt{?part} as the reference parameter and \texttt{?robot} as the target parameter. This convention has been used in our ontology to define these two distinct types of parameters.

\item \class{Function} -- A \class{Function} has a unique name  of type \texttt{string}. A \class{Function} has a reference parameter and a target parameter. The same rules apply to the definition and use of these two types of parameters as the ones defined for \class{Predicate}.
\item \class{FunctionBool} -- \class{FunctionBool} has one or more subclasses that represent the type of relation between two \class{Functions}. For example, the relation depicted at line 13--14 in is represented in the subclass \class{IntLesserThanInt}. Subclasses of \class{FunctionBool} have a first \class{Function} that represents the \class{Function} on the left side of the operator. Subclasses of \class{FunctionBool} have a second \class{Function} that represents the \class{Function} on the right side of the operator.
\end{enumerate}

The third level of the ontology contains specific instances needed for a particular kitting domain. For example, it will contain the definition of the finished kits that may be
constructed and specific information on the individual parts. One of the goals of this framework is to introduce additional agility into the kit building process. Therefore,
partial information is accepted and even encouraged for this area of the ontology. For the example of a part shown in Figure \ref{fig:part}, information on the SKU, grasp points 
(part of the ExternalShape or InternalShape), and name would be expected to be available at runtime. Information on the location of the part (PrimaryLocation) may not
become valid until after a sensor processing system has identified and located the particular part.
%
\subsubsection{Planning --}
The Planning Domain Definition Language (PDDL)  is an attempt by the domain independent planning community to formulate a standard language for planning. A community of planning researchers has been producing planning systems that comply with this formalism since the first International Planning Competition held in 1998. This competition series
continues today, with the seventh competition being held in 2011. PDDL is constantly adding extensions to the base language in order to represent more expressive problem domains. The representation in the world model is based on PDDL Version 3.

By placing the knowledge in a PDDL representation, the use of an entire family of open source planning systems such as the forward-chaining partial-order planning system from Coles et al. \cite{Coles.ICAPS.2010}
is enabled. In order to operate, the PDDL planners require a PDDL file-set that consists of two files that specify the domain and the problem.
From these files, the planning system creates an additional static plan file.

This plan file contains a sequence of actions that will transition the system from the initial state to the goal state. In order to maintain flexibility, it is desired that detailed information that is subject to change should be ``late-bound'' to the plan. In other words, specific information is acquired directly before that information needs to be used by the system. This allows for last minute changes in this information. For example, the location of a kit tray on a work table may be different from run to run. However, one would like to be able to use the same planning sequence for constructing the kit independent of the tray's exact position.
To compensate for this lack of exact knowledge, the plans that are generated by the PDDL planning system contain only high-level actions.

As seen in Figure \ref{fig:WorldModel}, the planning world model framework contains generators that read the ontology and create
a standard PDDL domain and PDDL problem file. Any of the family of PDDL Version 3 compatible planning systems is then able to be
run on these files to create the static plan instance file. A representation of this plan may be stored in the ontology for future use.
%
\subsubsection{Execution --}
The execution world model is also built automatically from the ontology. This world model consists of a mySQL database and C++ and Java
interfaces that provide for easy access to the data. The table skeletons are generated from the kitting ontology, and the tables are initially populated
with information from the initial and goal condition files. During plan execution, the executor guides the sensor processing system
in updating the information in 
this section of the world model. All of the data structures encoded in the ontology are included in this representation. 
%An example 
%of the data tables that are created may be seen in Figure ?? for the Part class that is shown in Figure \ref{fig:part}. 
%
\subsection{Act}
\label{subsection:Act}
The actions that take place in the kitting work cell are coordinated by the Executor as illustrated in Figure \ref{fig:SenseModelAct}.  The Executor
reads PDDL actions as input and outputs a standardized set of low-level robot commands developed at the National Institute of Standards
and Technology (NIST) known as the  Canonical Robotic Control Language \cite{Balakirsky2012-1}. 

Before and after each high-level command
is executed, the Executor sends focus of attention information into the sensor processing system. This allows the sensor processing system to compute
the appropriate predicate relations that are required to verify the conditions necessary to carry out an action and that an action's execution has
been successful. Information on predicates is written to the world model by the sensing system and read from the world model by the executor.
%
\\
\begin{algorithm}[h!]

 \KwData{ $kitToBuild$ }
 \KwResult{reports success or failure}
 	retrieve instance $PDDLInstance$ to construct kit $kitToBuild$\;
 	\For{each action $\textbf{A}$ in $PDDLInstance$}{
 		\For{each precondition $\textbf{P}$ of action $\textbf{A}$} {
			\If{$PredicateEvaluation(P)=false$}{
				report failure\;
			}
 		}
 		create set $S$ of Canonical Robot Control Language Commands\;
 		send set $S$ to Robot Controller for execution\;
 		\For{each effect $\textbf{E}$ of action $\textbf{A}$} {
			\If{$PredicateEvaluation(E)==false$}{
				report failure\;
			}
 		}
 		report action success\;
 	}
 	report plan success\;
\caption{{\sc BuildKit} -- Sequences the actions necessary to build a kit.}
\label{fig:buildkit}
\end{algorithm}
%