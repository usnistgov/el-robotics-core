\section{6DOF Pose Estimation within the Knowledge Driven Methodology}
\label{sect:architecture}
\begin{figure}[!t!h!b!]
\centering
\includegraphics[width=10cm]{images/KnowledgeDrivenRobotics.pdf}
\caption{Knowledge Driven Design extensions -- In this figure, green shaded
  boxes with curved bottoms represent hand generated files while light blue
  shaded boxes with curved bottoms represent automatically created boxes.
  Rectangular boxes represent processes and libraries. }
\label{fig:methodology}
\end{figure}

The knowledge driven methodology presented in this section is not purposed
to act as a stand-alone system architecture. Rather it is intended to be an
extension to well developed hierarchical, deliberative architectures such
as 4D/RCS~\cite{Albus2000}. The overall knowledge driven methodology of the
system is depicted in Figure~\ref{fig:methodology}. The figure is organized
vertically by the representation that is used for the knowledge and
horizontally by the classical sense-model-act paradigm of intelligent
systems. The remainder of this section gives a brief description of each
level of the hierarchy to help the reader understand the basic concepts
implemented within the system architecture in order to captivate the main effort described in this paper. The reader may find a more
detailed description of each component and each level of the architecture
in other documented
publications~\cite{BALAKIRSKY.IROS.2012}.

\subsection{Domain Specific Information}
Knowledge begins with Domain Specific Information
(DSI) that captures operational knowledge that is necessary to be
successful in the particular domain in which the system is designed to
operate. This includes information on items ranging from what actions and
attributes are relevant, to what the necessary conditions are for an action
to occur and what the likely results of the action are. The authors have
chosen to encode this basic information in a formalism known as a state
variable representation~\cite{NAU.2004}.

\subsection{Ontology}
\label{sub:ontology}
The information encoded in the DSI is then organized into a domain
independent representation. A base ontology (\textsf{OWL/XML Kitting})
contains all of the basic information that was determined to be needed
during the evaluation of the use cases and scenarios. The knowledge is
represented in as compact a form as possible with knowledge classes
inheriting common attributes from parent classes. The \textsf{OWL/XML SOAP}
ontology describes not only aspects of actions and predicates but also the
individual actions and predicates that are necessary for the domain under
study. The instance files describe the initial and goal states for the
system through the \textsf{Kitting Init Conditions File} and the
\textsf{Kitting Goal Conditions File}, respectively. The initial state file
must contain a description of the environment that is complete enough for a
planning system to be able to create a valid sequence of actions that will
achieve the given goal state. The goal state file only needs to contain
information that is relevant to the end goal of the system. For the case of building a kit, this may simply be that a complete kit is located in a bin designed to hold completed kits.

Since both the OWL and XML implementations of the knowledge representation are file based, real time information proved to be problematic. In order to solve this problem, an automatically generated MySQL database has been introduced as part of the knowledge representation. More information on the generated MySQL database is given in the description of the Planning Language level.


\subsection{Planning Language}
Aspects of the knowledge previously described are automatically extracted and encoded in a form
that is optimized for a planning system to utilize (the Planning Language).
The planning language used in the knowledge driven system is expressed with
the Planning Domain Definition Language (PDDL)~\cite{PDDL} (version 3.0).
The PDDL input format consists of two files that specify the domain and the
problem. As shown in Figure~\ref{fig:methodology}, these files are
automatically generated from the ontology. From
these two files, a domain independent planning
system~\cite{Coles.ICAPS.2010} was used to produce a static \textsf{Plan Instance File}.

%As mentioned in Section~\ref{sub:ontology}, a MySQL is automatically generated and the tables of the database are filled based on real data from the OWL/XML Kitting Init Condition File (created at the Ontology level). 
While the knowledge representation presented in this paper provides the \lq\lq{}slots\rq\rq{} necessary for representing dynamic information, the
static file structure makes the utilization of these slots awkward. It is desirable to be able to represent the dynamic information in a dynamic database. For this reason, the authors have developed a technique for automatically generating tables for storing,  and access functions for obtaining, the data from the ontology in a MySQL database.

Reading data from and to the MySQL database instead of the ontology file offers the community easy access to a live data structure. Furthermore, it is more practical to modify the information stored in a database than if it was stored in an ontology, which in some cases, requires the deletion and re-creation of the whole file. A literature review reveals many efforts and methodologies that have been designed to produce SQL databases from ontologies. Our effort builds upon the work of Astrova et al.\cite{Astrova2007}. 

In addition to generating and filling the database tables, the authors have created tools that automatically generate a set of C{}\texttt{++} classes for reading and writing
information to the kitting MySQL database. The choice of C{}\texttt{++} was a team preference and we believe that other object-oriented languages could have been used in this project.

The interaction of the MySQL database with the Connectors to Predicate Evaluation (in the Act level) is detailed in Section \ref{sec:sensor}.

\subsection{Robot Language}
Once a plan has been formulated, the knowledge is transformed into a
representation that is optimized for use by a robotic system (the Robot
Language). The interpreter combines knowledge from the plan with knowledge
from the MySQL database to form a sequence of sequential actions that the
robot controller is able to execute. The authors devised a canonical robot
command language (CRCL) in which such lists can be written. The purpose of
the CRCL is to provide generic commands that implement the functionality of
typical industrial robots without being specific either to the language of
the planning system that makes a plan or to the language used by a robot
controller that executes a plan.