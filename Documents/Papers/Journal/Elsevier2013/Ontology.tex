We believe that building models of the world knowledge is a necessary step towards operating an automated kitting workstation. The proposed models include representations for non-executable information about the kitting workstation such as information about parts, kits, and trays. The description of these models includes for instance the location, orientation, and relation between components. These models are discussed in Section~\ref{owlkitting}.

Models of executable information are also produced from the system information described in the SVR. These models include actions, actions' precondition, actions' effect, and actions' failures that consist of different spatial relations. A description of these models is given in Section~\ref{owlsoap}.

Models for executable and non-executable information can be combined to generate the OWL/XML kitting init and goal conditions files, as described in Section~\ref{owlinitgoal}.



%The rest of this section describes the two proposed different models along with their representation in the ontologies presented in Figure~\ref{fig:DesignArchitecture}. %The models were defined in OWL's functional-style syntax~\cite{OWLspec}.

\subsection{The OWL/XML Kitting Ontology}\label{owlkitting}
In order to maintain compatibility with the IEEE working group, the \texttt{Kitting} ontology has been fully defined in the Web Ontology Language (OWL)~\cite{OWLoverview}. In addition, the ontology was also fully defined in the XML schema language~\cite{Walmsley.2002}. Although the two models are conceptually identical, there are some systematic differences between the models (in addition to differences inherent in using two different languages).


\begin{itemize}
  \item The \textsf{complexType} names (i.e. class names) in XML schema have the suffix ``Type" added which is not used in OWL. This is so that the same names without the suffix can be used in XML schema language as element names without confusion.
  \item All of the XML schema \textsf{complexTypes} have a ``Name" element that is not present in OWL. It is not needed in OWL because names are assigned as a matter of course when instances of classes are created.
  \item The XML schema model has a list of ``Object" elements. This collects all of the movable objects. The OWL model does not have a corresponding list. In an OWL data file, the movable objects may appear anywhere.
  \item OWL has classes but does not have attributes; it has \textsf{ObjectProperties} and \textsf{DataProperties} instead. They may be used to model attributes. OWL Properties are global, not local to a class, so localizing each attribute to a class is done by a naming convention that includes using prefixes as described below. The prefixes are not used in XML schema.
  \item OWL supports multiple inheritances, but that has not been used in the \texttt{Kitting} ontology. Except by subclass relationship, no object is in more than one class.
\end{itemize}
\begin{table}[h!t!b!]
\caption{Excerpt of the \texttt{Kitting} ontology.}
\label{tab:kittingonto}
\centering
\begin{tabular}{l}
\hline
\textsf{SolidObject} \textit{PrimaryLocation} \textit{SecondaryLocation}
\\\hline
\hspace{5 mm}\textsf{Kit} \textit{Tray} \textit{DesignRef} \textit{Parts} \textit{Finished?}
\\\hline
\hspace{5 mm}\textsf{LargeBoxWithEmptyKitTrays} \textit{LargeContainer} \textit{Trays}
\\\hline
\hspace{5 mm}\textsf{LargeBoxWithKits} \textit{LargeContainer} \textit{Kits} \textit{KitDesignRef} \textit{Capacity}
\\\hline
\hspace{5 mm}\textsf{PartsTrayWithParts} \textit{PartTray}
\\\hline
\hspace{5 mm}\ldots
\\\hline
\textsf{DataThing}
\\\hline
\hspace{5 mm}\textsf{PhysicalLocation} \textit{RefObject}
\\\hline
\hspace{10 mm}\textsf{PoseLocation} \textit{Point} \textit{XAxis} \textit{ZAxis}
\\\hline
\hspace{15 mm}\textsf{PoseLocationIn}
\\\hline
\hspace{15 mm}\textsf{PoseLocationOn}
\\\hline
\hspace{10 mm}\textsf{RelativeLocation} \textit{Description}
\\\hline
\hspace{15 mm}\textsf{RelativeLocationIn}
\\\hline
\hspace{15 mm}\textsf{RelativeLocationOn}
\\\hline
\hspace{5 mm}\ldots
\\\hline
\end{tabular}
\end{table}
\textsf{SolidObject} and \textsf{DataThing} constitute the two top-level classes of the \texttt{Kitting} ontology model, from which all other classes are derived.


\textsf{SolidObject} models solid objects, things made of matter. The \texttt{Kitting} ontology includes several subclasses of \textsf{SolidObject} that are formed from
components that are \textsf{SolidObject}. The \textsf{DataThing} class models data for \textsf{SolidObject}. Examples of subclasses for \textsf{SolidObject} and \textsf{DataThing} are represented in Table~\ref{tab:kittingonto}. Items in italics following classes are names of class attributes. Derived types inherit the attributes of the parent. Each attribute has a specific type not shown in the listing below. If an attribute type has derived types, any of the derived types may be used.

Using Table~\ref{tab:kittingonto}, an example of interaction between classes \textsf{SolidObject} and \textsf{DataThing} can be expressed as follows: Each \textsf{SolidObject} \textsf{A} has at least one \textsf{PhysicalLocation} (the \textit{PrimaryLocation}). A \textsf{PhysicalLocation} is defined by giving a reference \textsf{SolidObject} \textsf{B} (\textit{RefObject}) and information saying how the position of \textsf{A} is related to \textsf{B}. \textsf{PhysicalLocation} consists of two types of location which are required for the operation of the kitting workstation:
\begin{itemize}
 \item Mathematically precise locations are needed to support robot motion. The mathematical location, \textsf{PoseLocation}, gives the pose of the coordinate system of \textsf{A} in the coordinate system of \textsf{B}. The mathematical information consists of the location of the origin of \textsf{A}'s coordinate system (\textit{Point}) and the directions of its Z (\textit{ZAxis}) and X (\textit{XAxis}) axes. The mathematical location variety has subclasses representing that, in addition, \textsf{A} is in \textsf{B} (\textsf{PoseLocationIn}) or on \textsf{B} (\textsf{PoseLocationOn}).
\item Relative locations (class \textsf{RelativeLocation}), specifically the knowledge that one \textsf{SolidObject} is in (\textsf{RelativeLocationIn}) or on (\textsf{RelativeLocationOn}) another, are needed to support making logical plans for building kits. The subclasses of \textsf{RelativeLocation} are needed not only for
logical planning, but also for cases when the relative location is known, but the
mathematical information is not available.
\end{itemize}



\subsection{The OWL Predicate Ontology}\label{owlsoap}

As depicted in Figure~\ref{fig:DesignArchitecture}, the \texttt{Predicate} ontology imports the \texttt{Kitting} ontology and is involved in the process that generates the planning domain definition language (PDDL)~\cite{GHALLAB.PDDL.1998} domain file and in the predicate evaluation process. While some concepts in the \texttt{Predicate} ontology are used by both processes, other concepts are exclusive to the predicate evaluation process. We approach the description of the \texttt{Predicate} ontology with a discussion on each process and the concepts used by these processes.

\subsubsection{Concepts for PDDL Domain File Generation Process}\label{sss:domainfile}
A PDDL domain file consists of definitions of actions, predicates, and functions. Actions are ways of changing the state of the world and consist of a precondition and an effect sections. Predicates and functions constitute preconditions and effects. Predicates are used to encode Boolean state variables, while functions are used to model updates of numerical values. Introducing functions into planning makes it possible to model actions in a more compact and sometimes more natural way~\cite{FOX.JAIR.2003}. Figure~\ref{fig:put-part} shows the action \texttt{put-part} as defined in the kitting domain file.

\begin{figure}[t!h!]
    \begin{minipage}{.9\paperwidth}
    \begin{mylisting}
    \begin{Verbatim}[commandchars=\\\{\},fontsize=\small, numbers=left, numbersep=0pt]
(:action put-part
   :parameters(
      ?robot - Robot
      ?part - Part
      ?kit - Kit
      ?worktable - WorkTable
      ?partstray - PartsTray)
   :precondition (and
      (part-location-robot ?part ?robot)
      (robot-holds-part ?robot ?part)
      (on-worktable-kit ?worktable ?kit)
      (origin-part ?part ?partstray)
      (< (quantity-kit ?kit ?partstray)
      (capacity-kit ?kit ?partstray))
      (kit-location-worktable ?kit ?worktable))
   :effect (and
      (not (part-location-robot ?part ?robot))
      (not (robot-holds-part ?robot ?part))
      (part-not-searched)
      (not (found-part ?part ?partstray))
      (part-location-kit ?part ?kit)
      (increase (quantity-kit ?kit ?partstray) 1)
      (robot-empty ?robot))
)
\end{Verbatim}
\end{mylisting}
\end{minipage}
\caption{PDDL action put-part.}
\label{fig:put-part}
\end{figure}

A PDDL action consists of the following sections:
\begin{enumerate}
  \item \texttt{action} (line 1): The unique name of the action comes directly after the keyword \texttt{:action}. In this example, the name of the action is \texttt{put-part}.
  \item \texttt{parameters} (lines 2--7): The parameters (start with a ? mark) that participate in this action are listed along their types. For example, line 3 can be read as ``\texttt{robot} is a parameter and is of type \texttt{Robot}''.
  \item \texttt{precondition} (lines 8--15): This section lists all the predicates (functions) that need to be true (satisfied) for the action to be carried out.
  \item \texttt{effect} (lines 16--23): This section lists all the predicates (functions) that are true (satisfied) when the action is performed.
   \item \texttt{predicate} and \texttt{function}: In Figure~\ref{fig:put-part}, the \texttt{precondition} section includes an operation between functions (lines 13--14) and the \texttt{effect} section includes one function at line 22. The other components of the precondition and the effect sections are predicates and negation of predicates (identified by the keyword \texttt{not}).
\end{enumerate}

In the \texttt{Predicate} ontology, the concepts of ``Action", ``Precondition", ``Effect", ``Predicate", ``Function", and ``Parameter" are represented by the classes \textsf{Action}, \textsf{Precondition}, \textsf{Effect}, \textsf{Predicate}, \textsf{Function}, and \textsf{ParameterList}, respectively. These classes are subclasses of the \textsf{DataThing} class discussed in Section~\ref{owlkitting}. An operation between two functions (lines 13--14) compares to integers and return a Boolean value. This is expressed in the class \textsf{FunctionBool}. 

In order to represent the structure of a PDDL action in the ontology, we have expressed the relations between classes as follows:
\begin{enumerate}
  \item Each instance of the class \textsf{Action} points (1 occurrence) to an instance of the class \textsf{ParameterList}.
  \begin{enumerate}
  \item Each instance of the class \textsf{ParameterList} points ($1\ldots\infty$ occurrences) to an instance of a class in the \texttt{Kitting} ontology. In Figure~\ref{fig:put-part}, the parameter \texttt{robot} is an instance of the class \textsf{Robot} which is a subclass of \textsf{SolidObject} in the \texttt{Kitting} ontology.
\end{enumerate}
  \item Each instance of the class \textsf{Action} points (1 occurrence) to an instance of the class \textsf{Precondition}.
  \begin{enumerate}
  \item Each instance of the class \textsf{Precondition} points ($0\ldots\infty$ occurrences) to an instance of the class \textsf{Predicate}. A precondition can consist only of functions and has no predicates.
  \begin{enumerate}
  \item Each instance of the class \textsf{Predicate} points ($0\ldots2$ occurrences) to an instance of  a class in the \texttt{Kitting} ontology. In most domains, including our kitting domain, predicates have a maximum of two parameters. This is the result of the definition of state variables in the SVR~\cite{BALAKIRSKY.IROS.2012}. Note that the instance of the class in the \texttt{Kitting} ontology is the same one defined in 1(a). This way assures that the predicate's parameters refer to the same parameters defined for the action.
  \end{enumerate}
    \item Each instance of the class \textsf{Precondition} points ($0\ldots\infty$ occurrences) to an instance of the class \textsf{Function}. A precondition can consist only of predicates and has no functions.
    \begin{enumerate}
    \item Each instance of the class \textsf{Function} points ($1\ldots\infty$ occurrences) to an instance of a class in the \texttt{Kitting} ontology. This instance of the class in the \texttt{Kitting} ontology is the same one defined in 1(a) for the same reason described in 2(a)i.
  \end{enumerate}
    \item Each instance of the class \textsf{Precondition} points ($0\ldots\infty$ occurrences) to an instance of the class \textsf{FunctionBool}.
        \begin{enumerate}
    \item Each instance of the class \textsf{FunctionBool} points (2 occurrences) to the class \textsf{Function} to formulate the kind of operation depicted at lines 13--14 in Figure~\ref{fig:put-part}.
  \end{enumerate}
\end{enumerate}
  \item Each instance of the class \textsf{Action} points (1 occurrence) to an instance of the class \textsf{Effect}. The class \textsf{Effect} has the same relations as the ones described for the class \textsf{Predicate} (2(a), 2(b), and 2(c)). Note that the effect section can contain $1\ldots\infty$ occurrences of negative predicates. Negative predicates are expressed in OWL with the property assertion\\\texttt{owl:NegativePropertyAssertion}.
\end{enumerate}

%
%\begin{enumerate}
%\item For each instance of the class \textsf{Action}:
%\begin{enumerate}
%  \item There is an object property \texttt{hasActionParameterList} that points to an instance of the class \textsf{ParameterList}.
%  \item There is an object property \texttt{hasActionPrecondition} that points to an instance of the class \textsf{Precondition}.
%  \item There is an object property \texttt{hasActionEffect} that points to an instance of the class \textsf{Effect}.
%\end{enumerate}
%\item For each instance of the class \textsf{ParameterList}:
%\begin{enumerate}
%  \item There exists $1\ldots\infty$ object property \texttt{hasActionParameter} that points to an instance of a class in the \texttt{Kitting} ontology. For instance, referring to Figure~\ref{fig:put-part}, if \texttt{putpart-paramlist} is an instance of the class \textsf{ParameterList} and \texttt{putpart-robot} is an instance of the class \textsf{Robot}, we will have the relation ``\texttt{putpart-paramlist} \texttt{hasActionParameter} \texttt{putpart-robot}".
%\end{enumerate}
%\item For each instance of the class \textsf{Precondition}:
%\begin{enumerate}
%  \item There exists an object property \texttt{hasPreconditionPredicate} that can occur more than once ($0\ldots\infty$) that points to an instance of the class \textsf{Predicate}.
%    \item There exists an object property \texttt{hasPreconditionFunction} that can occur more than once ($0\ldots\infty$) that points to an instance of the class \textsf{Function}.
%    \item There exists an object property \texttt{hasBoolOperator} that can occur more than once ($0\ldots\infty$) that points to an instance of the class \textsf{FunctionBool}.
%\end{enumerate}
%\item For each instance of the class \textsf{Predicate}:
%\begin{enumerate}
%  \item There exists 1 occurrence of the object property \\\texttt{hasPredicateReferenceParameter} that points to an instance of a class in the \texttt{Kitting} ontology. This instance of the class in the \texttt{Kitting} ontology is the same one defined by the object property \texttt{hasActionParameter} for the class \textsf{ParameterList}. For instance, if \texttt{putpart-robot} has been defined as a parameter for \texttt{putpart-paramlist}, the predicate \texttt{robot-holds-part} (from the class \textsf{Predicate}) points to \texttt{putpart-robot}.
%    \item There exists 0 or 1 occurrence of the object property \\\texttt{hasPredicateTargetParameter} that points to an instance of a class in the \texttt{Kitting} ontology (same rule as described in 4(a)). Note that the difference between \texttt{hasPredicateReferenceParameter} and \texttt{hasPredicateTargetParameter} lies in the number of parameters for the predicate. If the predicate consists of only one parameter, this parameter is identified by \texttt{hasPredicateReferenceParameter}. If the predicate consists of two parameters, the first parameter is identified by \texttt{hasPredicateReferenceParameter} and the second parameter is identified by \texttt{hasPredicateTargetParameter}.
%\end{enumerate}
%\end{enumerate}


\subsubsection{Concepts for the Predicate Evaluation Process}
The predicate evaluation process is called during the execution of robot commands (defined in the Robot Language) by the robot. In our system, one PDDL action generates multiple of these commands. Before the robot executes these commands, the predicates that constitute the precondition section for the original PDDL action are evaluated. In the same way, once the set of robot commands has been carried out by the robot, the predicates part of the effect section for the original PDDL action are evaluated. In our system, we use the concept of \texttt{Spatial Relations} to evaluate these predicates.

\texttt{Spatial Relations} are represented as subclasses of the \textsf{RelativeLocation} class which is a subtype of the \textsf{PhysicalLocation} (see Table~\ref{tab:kittingonto}). There are three types of spatial relations, each represented in a separate class as described below:
\begin{itemize}
 \item \textsf{RCC8\_Relation}: RCC8~\cite{Wolter.KR.2000} is a well-known and cited approach for representing the relationship between two regions in Euclidean space or in a topological space. Based on the definition of RCC8, the class \textsf{RCC8\_Relation} consists of eight possible relations, including Tangential Proper Part (TPP), Non-Tangential Proper Part(NTPP), Disconnected (DC), Tangential Proper Part Inverse (TPPi), Non-Tangential Proper Part Inverse (NTPPi), Externally Connected (EC), Equal (EQ), and Partially Overlapping (PO). In order to represent these relations in all three dimensions for the kitting domain, we have extended RCC8 to a three-dimensions space by applying it along all three planes (x-y, x-z, y-z) and by including cardinal direction relations ``+'' and ``-''~\cite{SCHLENOFF.ECDRM.2012}. In the ontology, RCC8 relations and cardinal direction relations are represented as subclasses of the class \textsf{RCC8\_Relation}. Examples of such classes are \textsf{X-DC}, \textsf{X-EC}, \textsf{X-Minus}, and \textsf{X-Plus}.

 \item \textsf{Intermediate\_State\_Relation}: These are intermediate level state relations that can be inferred from the combination of RCC8 and cardinal direction relations. For  instance, the intermediate state relation \textbf{Contained-In} is used to describe object \textit{obj1} completely inside object \textit{obj2} and is represented with the following combination of RCC8 relations:

\begin{gather}
\textbf{Contained-In}(\textit{obj1}, \textit{obj2}) \rightarrow   \notag\\
(\texttt{x-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{x-NTPP}(\textit{obj1}, \textit{obj2})) \wedge \notag\\
(\texttt{y-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{y-NTPP}(\textit{obj1}, \textit{obj2})) \wedge \notag\\
(\texttt{z-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{z-NTPP}(\textit{obj1}, \textit{obj2}))\notag
\end{gather}
In the ontology, intermediate state relations are represented with the OWL built-in property \texttt{owl:equivalentClass} that links the description of the class \textsf{Intermediate\_State\_Relation} to a logical expression based on RCC8 relations from the class \textsf{RCC8\_Relation}.
 \item \textsf{Predicate}: The representation of predicates has been illustrated in Section~\ref{sss:domainfile}. In this section we discuss how the class \textsf{Predicate} has been extended to include the concept of \texttt{Spatial Relation}. The truth-value of predicates can be determined through the logical combination of intermediate state relations. The predicate \textsf{kit-location-lbwk}(\textit{kit}, \textit{lbwk}) is true if and only if the location of the kit \textit{kit} is in the large box with kits \textit{lbwk}. This predicate can be described using the following combination of intermediate state relations:

\begin{gather}
\textsf{kit-location-lbwk}(\textit{kit}, \textit{lbwk}) \rightarrow   \notag\\
\textbf{In-Contact-With}(\textit{kit}, \textit{lbwk}) \wedge \notag\\
\textbf{Contained-In}(\textit{kit}, \textit{lbwk}) \notag
\end{gather}

As with state relations, the truth-value of predicates is captured in the ontology using the \texttt{owl:equivalentClass} property that links the description of the class \textsf{Predicate} to the logical combination of intermediate state relations from the class \textsf{Intermediate\_State\_Relation}. 

As seen in Section~\ref{sss:domainfile}, a predicate can have a maximum of two parameters. In the case where a predicate has two parameters, the parameters are passed to intermediate state relations defined for the predicate, and are in turn passed to the RCC8 relations were the truth-value of these relations are computed. In the case the predicate has only one parameter, the truth-value of intermediate state relations, and by inference, the truth-value of RCC8 relations will be tested with this parameter and with every object in the environment in lieu of the second parameter.
\end{itemize}


\subsubsection{Concept of Failure Mode}\label{sss:failure}

%The authors refer to Figure~\ref{} to describe the different concepts
%As depicted in Figure~\ref{fig:DesignArchitecture}, this ontology is applied to the generation of the domain file generation and to the evaluation of predicates.

\subsection{The OWL Kitting Init and Goal Conditions File} \label{owlinitgoal}
