We believe that building models of the world knowledge is a necessary step towards operating an automated kitting workstation. The proposed models include representations for non-executable information about the kitting workstation such as information about parts, kits, and trays. The description of these models includes for instance the location, orientation, and relation between components. These models are discussed in Section~\ref{owlkitting}. Models of executable information are also produced from the system information described in the SVR. These models include actions along with their precondition and effect, and failures. Section~\ref{owlsoap} discusses models of executable information.

Models for non-executable and executable information can be combined to generate the OWL/XML kitting \onto{init} and \onto{goal} conditions files, as described in Section~\ref{owlinitgoal}.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
\subsection{The OWL/XML Kitting Ontology}\label{owlkitting}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
In order to maintain compatibility with the IEEE Robotics and Automation Society's Ontologies for
Robotics and Automation Working Group, the \onto{Kitting} ontology has been fully defined in the Web Ontology Language (OWL)~\cite{OWLoverview}. In addition, the ontology was also fully defined in the XML schema language~\cite{Walmsley.2002}. Although the two models are conceptually identical, there are some systematic differences between the models (in addition to differences inherent in using two different languages) that are discussed in Balakirsky~\textit{et al.}~\cite{Balakirsky.whitepaper.2012}.
%
%\begin{itemize}
%  \item The \textsf{complexType} names (i.e. class names) in XML schema have the suffix ``Type" added which is not used in OWL. This is so that the same names without the suffix can be used in XML schema language as element names without confusion.
%  \item All of the XML schema \textsf{complexTypes} have a ``Name" element that is not present in OWL. It is not needed in OWL because names are assigned as a matter of course when instances of classes are created.
%  \item The XML schema model has a list of ``Object" elements. This collects all of the movable objects. The OWL model does not have a corresponding list. In an OWL data file, the movable objects may appear anywhere.
%  \item OWL has classes but does not have attributes; it has \textsf{ObjectProperties} and \textsf{DataProperties} instead. They may be used to model attributes. OWL Properties are global, not local to a class, so localizing each attribute to a class is done by a naming convention that includes using prefixes as described below. The prefixes are not used in XML schema.
%  \item OWL supports multiple inheritances, but that has not been used in the \onto{Kitting} ontology. Except by subclass relationship, no object is in more than one class.
%\end{itemize}

\begin{table}[h!t!b!]
  \caption{Excerpt of the \onto{Kitting} ontology.}
  \label{tab:kittingonto}
  \centering
  \begin{tabular}{l}
    \hline
    \class{SolidObject} \textit{PrimaryLocation} \textit{SecondaryLocation}
    \\\hline
    \hspace{5 mm}\class{Kit} \textit{Tray} \textit{DesignRef} \textit{Parts} \textit{Finished?}
    \\\hline
    \hspace{5 mm}\class{LargeBoxWithEmptyKitTrays} \textit{LargeContainer} \textit{Trays}
    \\\hline
    \hspace{5 mm}\class{LargeBoxWithKits} \textit{LargeContainer} \textit{Kits} \textit{KitDesignRef} \textit{Capacity}
    \\\hline
    \hspace{5 mm}\class{PartsTrayWithParts} \textit{PartTray}
    \\\hline
    \hspace{5 mm}\ldots
    \\\hline
    \class{DataThing}
    \\\hline
    \hspace{5 mm}\class{PhysicalLocation} \textit{RefObject}
    \\\hline
    \hspace{10 mm}\class{PoseLocation} \textit{Point} \textit{XAxis} \textit{ZAxis}
    \\\hline
    \hspace{15 mm}\class{PoseLocationIn}
    \\\hline
    \hspace{15 mm}\class{PoseLocationOn}
    \\\hline
    \hspace{10 mm}\class{RelativeLocation} \textit{Description}
    \\\hline
    \hspace{15 mm}\class{RelativeLocationIn}
    \\\hline
    \hspace{15 mm}\class{RelativeLocationOn}
    \\\hline
    \hspace{5 mm}\ldots
    \\\hline
  \end{tabular}
\end{table}

\class{SolidObject} and \class{DataThing} constitute the two top-level classes of the \onto{Kitting} ontology model, from which all other classes are derived. \class{SolidObject} models solid objects, things made of matter. The \onto{Kitting} ontology includes several subclasses of \class{SolidObject} that are formed from
components that are \class{SolidObject}. The \class{DataThing} class models data for \class{SolidObject}. Examples of subclasses for \class{SolidObject} and \class{DataThing} are represented in Table~\ref{tab:kittingonto}. Items in italics following classes are names of class attributes. Derived types inherit the attributes of the parent. Each attribute has a specific type not shown in Table~\ref{tab:kittingonto}. If an attribute type has derived types, any of the derived types may be used.

Using Table~\ref{tab:kittingonto}, an example of interaction between classes \class{SolidObject} and \class{DataThing} can be expressed as follows: Each \class{SolidObject} \class{A} has at least one \class{PhysicalLocation} (the \textit{PrimaryLocation}). A \class{PhysicalLocation} is defined by giving a reference \class{SolidObject} \class{B} (\textit{RefObject}) and information saying how the position of \class{A} is related to \class{B}. \class{PhysicalLocation} consists of two types of location which are required for the operation of the kitting workstation:
\begin{itemize}
 \item Mathematically precise locations are needed to support robot motion. The mathematical location, \class{PoseLocation}, gives the pose of the coordinate system of \class{A} in the coordinate system of \class{B}. The mathematical information consists of the location of the origin of \class{A}'s coordinate system (\textit{Point}) and the directions of its Z (\textit{ZAxis}) and X (\textit{XAxis}) axes. The mathematical location variety has subclasses representing that, in addition, \class{A} is in \class{B} (\class{PoseLocationIn}) or on \class{B} (\class{PoseLocationOn}).
\item Relative locations (class \class{RelativeLocation}), specifically the knowledge that one \class{SolidObject} is in (\class{RelativeLocationIn}) or on (\class{RelativeLocationOn}) another, are needed to support making logical plans for building kits. The subclasses of \class{RelativeLocation} are needed not only for
logical planning, but also for cases when the relative location is known, but the
mathematical information is not available.
\end{itemize}


%++++++++++++++++++++++++++++++++++++++++++++++++++++++%
\subsection{The OWL/XML SOAP Ontology}\label{owlsoap}
%++++++++++++++++++++++++++++++++++++++++++++++++++++++%
As depicted in Figure~\ref{fig:DesignArchitecture}, the \onto{SOAP} ontology imports the \onto{Kitting} ontology. The \onto{Kitting} ontology is involved in the process that generates the PDDL domain file and in the process that evaluates the truth-value of predicates. While some concepts in the \onto{SOAP} ontology are used by both processes, other concepts are exclusive to one of these two processes. We approach the description of the \onto{SOAP} ontology with a discussion on each process.

%------------------------------------------------------------------------------------------------------------------------------%
\subsubsection{PDDL Domain File Generator Process}\label{sss:domainfile}
%------------------------------------------------------------------------------------------------------------------------------%
A PDDL domain file consists of definitions of actions, predicates, and functions. Actions are ways of changing the state of the world and consist of a precondition and an effect sections. Predicates and functions constitute preconditions and effects. Predicates are used to encode Boolean state variables while functions are used to model updates of numerical values. Introducing functions into planning makes it possible to model actions in a more compact and sometimes more natural way~\cite{FOX.JAIR.2003}. Both predicates and functions are well documented in the SVR. Figure~\ref{fig:put-part} shows the action \textsl{put-part} that will be used as the model to discuss the components of a PDDL action.

\begin{figure}[t!h!]
\begin{minipage}{.5\paperwidth}
\begin{list}{}{\setlength{\leftmargin}{1em}}\item\small
\begin{Verbatim}[commandchars=\\\{\},fontsize=\scriptsize, numbers=left, numbersep=2pt]
(:action put-part
   :parameters(
      ?robot - Robot
      ?part - Part
      ?kit - Kit
      ?worktable - WorkTable
      ?partstray - PartsTray)
   :precondition (and
      (part-location-robot ?part ?robot)
      (robot-holds-part ?robot ?part)
      (on-worktable-kit ?worktable ?kit)
      (origin-part ?part ?partstray)
      (< (quantity-kit ?kit ?partstray)
      (capacity-kit ?kit ?partstray))
      (kit-location-worktable ?kit ?worktable))
   :effect (and
      (not (part-location-robot ?part ?robot))
      (not (robot-holds-part ?robot ?part))
      (part-not-searched)
      (not (found-part ?part ?partstray))
      (part-location-kit ?part ?kit)
      (increase (quantity-kit ?kit ?partstray) 1)
      (robot-empty ?robot))
)
\end{Verbatim}
\end{list}
\end{minipage}
\caption{PDDL action put-part.}
\label{fig:put-part}
\end{figure}

\begin{enumerate}
  \item \texttt{action} (line 1): The unique name of the action comes directly after the keyword \texttt{:action}. In this example, the name of the action is \texttt{put-part}.
  \item \texttt{parameters} (lines 2--7): The parameters (preceded by a ? mark) that participate in this action are listed along their types. For example, line 3 can be read as ``\texttt{robot} is a parameter and is of type \texttt{Robot}''.
  \item \texttt{precondition} (lines 8--15): List of all the predicates and functions needed in the precondition section.
  \item \texttt{effect} (lines 16--23): List of all the predicates and functions needed in the effect section.
\end{enumerate}

The representation of PDDL action in the ontology is made up of the classes \class{Action}, \class{Precondition}, \class{Effect}, \class{Predicate}, \class{Function}, \class{ParameterList}.  Operations between functions such as the one shown at lines 13--14 in Figure~\ref{fig:put-part}, are expressed with the class \class{FunctionBool}. All these classes are subclasses of \class{DataThing}.

In the remainder of this section, we provide paragraph descriptions of each of the classes used to represent PDDL actions in the \onto{SOAP} ontology. The naming convention utilized below follows the OWL implementation of the ontology.

\begin{enumerate}
\item \class{Action} -- An \class{Action} has a \class{Precondition} (\emph{hasAction\_Precondition}) and an \class{Effect} (\emph{hasAction\_Effect}). An \class{Action} has a \class{ParameterList} (\emph{hasAction\_ParameterList}) that contains all the parameters for a PDDL action. As seen in Figure~\ref{fig:put-part}, an action has unique name (\emph{hasAction\_Name}) of type \texttt{string}.
\item \class{ParameterList} -- The \textsl{put-part} action illustrated in Figure~\ref{fig:put-part} has five parameters of different types. Each one of these types is represented by a class in the \onto{Kitting} ontology. To represent all PDDL actions in the \onto{SOAP} ontology, we considered all the different types of parameters that are used in all our ten PDDL actions. To date, we are using eleven different types of parameter, represented by the eleven following classes: \class{Robot}, \class{EndEffectorChangingStation}, \class{KitTray}, \class{Kit}, \class{LargeBoxWithEmptyKitTrays}, \class{LargeBoxWithKits}, \class{WorkTable}, \class{PartsTray}, \class{Part}, \class{EndEffector}, and \class{EndEffectorHolder}. Therefore, \class{ParameterList} has at least a parameter (\emph{hasAction\_Parameter}) that is from one of these eleven classes.
    
    The order of the parameters in a PDDL action also needs to be represented in the ontology. In Figure~\ref{fig:put-part}, the parameter \texttt{robot} comes before the parameter \texttt{part}, the parameter \texttt{part} comes before the parameter \texttt{kit}, and so on. OWL has no built-in structure to represent an ordered list, instead, all the eleven classes mentioned earlier, use \emph{hasParameter\_Next} to point to the next parameter in \class{ParameterList}.
\item \class{Precondition} -- A \class{Precondition} can consist of only one \class{Predicate} (\emph{hasPrecondition\_Predicate}), only one \class{Function} (\emph{hasPrecondition\_Function}), \class{FunctionBool} (\emph{hasPrecondition\_FunctionBool}), or a combination of these three classes. A \class{Precondition} belongs to one \class{Action} (\emph{hadByPrecondition\_Action}).
\item \class{Effect} -- An \class{Effect} can consist of only one \class{Predicate} (\emph{hasEffect\_Predicate}), only one \class{Function} (\emph{hasEffect\_Function}), \class{FunctionBool} (\emph{hasEffect\_FunctionBool}), or a combination of these three classes. An \class{Effect} belongs to one \class{Action} (\emph{hadByEffect\_Action}). A negative \class{Predicate} is represented with the declaration of \emph{hasEffect\_Predicate} within the OWL built-in property assertion \texttt{owl:NegativePropertyAssertion}.
\item \class{Predicate} -- A \class{Predicate} has a unique name (\emph{hasPredicate\_Name}) of type \texttt{string}. A \class{Predicate} has a reference parameter (\emph{hasPredicate\_RefParam}) and a target parameter (\emph{hasPredicate\_TargetParam}). A reference parameter is the first parameter in the \class{Predicate}'s list and the target parameter is the second parameter in the parameter's list. A \class{Predicate} cannot have more than two parameters due to the definition of \class{Predicates} in the SVR. In the case a \class{Predicate} has only one parameter, it is assign to the reference parameter. Reference and target parameters are one of the parameters defined for the \class{Action} to which the \class{Predicate} belongs.
\item \class{Function} -- A \class{Function} has a unique name (\emph{hasFunction\_Name}) of type \texttt{string}. A \class{Function} has a reference parameter (\emph{hasFunction\_RefParam}) and a target parameter (\emph{hasFunction\_TargetParam}). The same rules apply to the definition and use of these two types of parameters as the ones defined for \class{Predicate}.
\item \class{FunctionBool} -- \class{FunctionBool} has one or more subclasses that represent the type of relation between two \class{Functions}. For example, the relation depicted at line 13--14 in Figure~\ref{fig:put-part} is represented in the subclass \class{IntLesserThanInt}. Subclasses of \class{FunctionBool} have a first \class{Function} (\emph{hasFunctionBool\_FirstFunction}) that represents the \class{Function} on the left side of the operator. Subclasses of \class{FunctionBool} have a second \class{Function} (\emph{hasFunctionBool\_SecondFunction}) that represents the \class{Function} on the right side of the operator.
\end{enumerate}

%-------------------------------------------------------------%
\subsubsection{Concepts for Action Failure}\label{sss:failure}
%-------------------------------------------------------------%
 A failure is any change or any design or manufacturing error that renders a component, assembly, or system incapable of performing its intended function. In kitting, failures can occur for multiple reasons: equipment not set up properly, tools and/or fixtures not properly prepared, lack of safety, and improper equipment maintenance. Part/component availability failures can be triggered by inaccurate information on the location of the part, part damage, wrong type of part, or part shortage due to delays in internal logistics. In order to prevent or minimize failures, a disciplined approach needs to be implemented to identify the different ways a process design can fail before impacting the productivity. 
 
 Failures detected in the workstation can result in the current plan to become obsolete. When a failure is detected in the execution process and the failure mode identified, the value of the severity for the failure mode will be retrieved from the ontology and the appropriate contingency plan will be activated. In some cases, the current state of the environment is brought back to the state prior to the failure and the robot starts from a ``stable" state. To select the right contingency plan, i.e., the less time consuming or safer, the system will need to rely on the information from the knowledge representation.
 
 In the knowledge driven diagram (Figure~\ref{fig:DesignArchitecture}), the \process{Predicate Evaluation} process is responsible for failure detection. An action failure consists of failure modes that can occur during the execution of a PDDL action. The steps to identify action failures in the kitting system are described in Figure~\ref{fig:algo}.

\begin{figure}[h!t!]
  \centering
  \includegraphics[width=10cm]{images/algorithm.pdf}
  \caption{Failure identification.}
  \label{fig:algo}
\end{figure}

As seen in Figure~\ref{fig:algo}, failures are identified during the execution of canonical robot commands (line 6), generated from PDDL actions (line 3) by the \process{Interpreter}. The \process{Predicate Evaluation} process outputs a Boolean value that results in a failure detection if this value is false (lines 18 and 20). Therefore, to represent failures in the \onto{SOAP} ontology, the following concepts are introduced:
\begin{itemize}
 \item ``Action'' the PDDL action for which a failure can occur.
 \item ``Failure Modes'': List of failure modes that can occur during the execution of a specific action.
 \item ``Causes'' of failure: Causes can be of different types, such as  components, usage conditions, human interaction, internal factors, external factors, etc.
 \item ``Predicates'' that can be responsible for the occurrence of the ``Failure Mode''.
 \item ``Effects'' of the failure: Consequences associated to the failure mode.
 \item ``Severity'' of the ``Effect(s)'': Assessment of how serious the effects would be should the failure occur. Each effect is given a rank of severity ranging from 1 (minor) to 10 (very high). The severity rank is used to trigger the appropriate contingency plan.
 \item ``Probability of Occurrence'': an estimate number of frequencies (based on experience) that a failure will occur for a specific action.
\end{itemize}

Table~\ref{tab:putpartfailure} shows an example of failure modes associated to the PDDL action \textsl{put-part}($\mathit{robot}$,$\mathit{part}$,$\mathit{kit}$,$\mathit{worktable}$,$\mathit{partstray}$) which is defined as ``The \textit{Robot} $\mathit{robot}$ puts the \textit{Part} $\mathit{part}$ in the \textit{Kit} $\mathit{kit}$''.
%previously presented in Figure~\ref{fig:put-part}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% put-part %%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[h!t!]
  %\centering
  \caption{Failure modes for the PDDL action \textit{put-part}.}
  \label{tab:putpartfailure}
  \scalebox{0.6}{
  \begin{tabular}{|l|l|l|l|c|c|c|}
    \hline
    \multicolumn{1}{|c|}{\begin{sideways}Action\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Failure Mode(s) \,\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Cause(s) \,\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Effect(s) \,\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Severity \,\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Occurrence (\%) \,\end{sideways}} &
    \multicolumn{1}{c|}{\begin{sideways}Predicate(s) \,\end{sideways}} \\
    \hline

    \multirow{5}{*}{\textit{\small{put-part}}} &
    \multirow{2}{*}{\stvar{part} falls off of the end effector} &
    \multirow{2}{*}{end effector hardware issues} &
    downtime & %\stvar{endeffector} replacement &
    9 &
    \multirow{2}{*}{60} &
    \small {\textsf{part-location-robot}}\\\cline{4-5}

     &
     &
     &
    \stvar{part} damage & %\stvar{endeffector} replacement &
    5 &
     &
    \small {\textsf{robot-holds-part}}\\\cline{2-7}

     &
     \multirow{3}{*}{\stvar{part} not released at all}&
     end effector hardware issues &
     downtime &
     9 &
     \multirow{3}{*}{8} &
     $\neg$(\small{\textsf{part-location-robot}})\\\cline{3-5}

     &
     &
     \multirow{2}{*}{wrong/inexistant canonical command} &
     \multirow{2}{*}{downtime} &
     \multirow{2}{*}{7} &
      &
     $\neg$(\small{\textsf{robot-holds-part}})\\
%
     &
     &
     &
     &
     &
     &
     \small {\textsf{robot-empty}}\\\hline

\end{tabular}
}
\end{table}
The column \textit{Predicate(s)} shows the predicates from the action \textit{put-part} that can activate the corresponding failure mode (column \textit{Failure Mode(s)}) if their truth-value is evaluated to false.

The classes discussed below are used to represent action failures in the \onto{SOAP} ontology. All these classes are subclasses of \class{DataThing}.
\begin{enumerate}
\item \class{Action} -- An \class{Action} has at least one \class{FailureMode} (\emph{hasAction\_FailureMode}).
\item \class{FailureMode} -- A \class{FailureMode} has at least one \class{FailureEffect} (\emph{hasFailureMode\_FailureEffect}). A \class{FailureMode} has a description (\emph{hasFailureMode\_Description}) of type \texttt{Literal} which represents the nature of the failure mode. The cause of the failure mode is expressed with \emph{hasFailureMode\_Cause} and is of type \texttt{Literal}. The occurrence of the failure mode is expressed with \emph{hasFailureMode\_Occurrence} and is of type \texttt{Integer}. A \class{FailureMode} has at least one \class{Predicate} (\emph{hasFailureMode\_Predicate}) that can be responsible for the occurrence of the failure mode. The \class{Predicate} should be already defined \textit{prior} to its association with the class \class{FailureMode}.
\item \class{FailureEffect} -- A \class{FailureEffect} has one failure severity (\emph{hasFailureEffect\_FailureSeverity}) of type \texttt{integer} and a description (\emph{hasFailureEffect\_Description}) of type \texttt{Literal}.
\end{enumerate}

%-------------------------------------------------------------%
\subsubsection{Concepts for the Predicate Evaluation Process}
%-------------------------------------------------------------%
As seen in Section~\ref{sss:failure}, the \process{Predicate Evaluation} process is called by the \process{System Monitor} process to check the truth-value of a predicate. The output of this process is a Boolean that is redirected back to the \process{System Monitor}. We have implemented the concept of ``Spatial Relations'' in the \onto{SOAP} ontology to be able to compute the truth-value of a predicate.

``Spatial Relations'' are represented as subclasses of the \class{RelativeLocation} class which is a subtype of the \class{PhysicalLocation} (see Table~\ref{tab:kittingonto}). There are three types of spatial relations, each represented in a separate class as described below:
\begin{itemize}
 \item \class{RCC8\_Relation}: RCC8~\cite{Wolter.KR.2000} is a well-known and cited approach for representing the relationship between two regions in Euclidean space or in a topological space. Based on the definition of RCC8, the class \class{RCC8\_Relation} consists of eight possible relations, including Tangential Proper Part (TPP), Non-Tangential Proper Part(NTPP), Disconnected (DC), Tangential Proper Part Inverse (TPPi), Non-Tangential Proper Part Inverse (NTPPi), Externally Connected (EC), Equal (EQ), and Partially Overlapping (PO). In order to represent these relations in all three dimensions for the kitting domain, we have extended RCC8 to a three-dimensions space by applying it along all three planes (x-y, x-z, y-z) and by including cardinal direction relations ``+'' and ``-''~\cite{SCHLENOFF.ECDRM.2012}. In the ontology, RCC8 relations and cardinal direction relations are represented as subclasses of the class \class{RCC8\_Relation}. Examples of such classes are \class{X-DC}, \class{X-EC}, \class{X-Minus}, and \class{X-Plus}.

 \item \class{Intermediate\_State\_Relation}: These are intermediate level state relations that can be inferred from the combination of RCC8 and cardinal direction relations. For  instance, the intermediate state relation \textbf{Contained-In} is used to describe object \textit{obj1} completely inside object \textit{obj2} and is represented with the following combination of RCC8 relations:
\begin{gather}
\textbf{Contained-In}(\textit{obj1}, \textit{obj2}) \rightarrow   \notag\\
(\texttt{x-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{x-NTPP}(\textit{obj1}, \textit{obj2})) \wedge \notag\\
(\texttt{y-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{y-NTPP}(\textit{obj1}, \textit{obj2})) \wedge \notag\\
(\texttt{z-TPP}(\textit{obj1}, \textit{obj2}) \vee \texttt{z-NTPP}(\textit{obj1}, \textit{obj2}))\notag
\end{gather}
In the ontology, intermediate state relations are represented with the OWL built-in property \texttt{owl:equivalentClass} that links the description of the class \class{Intermediate\_State\_Relation} to a logical expression based on RCC8 relations from the class \class{RCC8\_Relation}.
 \item \class{Predicate}: The representation of predicates has been illustrated in Section~\ref{sss:domainfile}. In this section we discuss how the class \class{Predicate} has been extended to include the concept of ``Spatial Relation''. The truth-value of predicates can be determined through the logical combination of intermediate state relations. The predicate \class{kit-location-lbwk}(\textit{kit}, \textit{lbwk}) is true if and only if the location of the kit \textit{kit} is in the large box with kits \textit{lbwk}. This predicate can be described using the following combination of intermediate state relations:
\begin{gather}
\textsf{kit-location-lbwk}(\textit{kit}, \textit{lbwk}) \rightarrow   \notag\\
\textbf{In-Contact-With}(\textit{kit}, \textit{lbwk}) \wedge \notag\\
\textbf{Contained-In}(\textit{kit}, \textit{lbwk}) \notag
\end{gather}
As with state relations, the truth-value of predicates is captured in the ontology using the \texttt{owl:equivalentClass} property that links the description of the class \class{Predicate} to the logical combination of intermediate state relations from the class \class{Intermediate\_State\_Relation}.

As seen in Section~\ref{sss:domainfile}, a predicate can have a maximum of two parameters. In the case where a predicate has two parameters, the parameters are passed to the intermediate state relations defined for the predicate, and are in turn passed to the RCC8 relations were the truth-value of these relations are computed. In the case the predicate has only one parameter, the truth-value of intermediate state relations, and by inference, the truth-value of RCC8 relations will be tested with this parameter and with every object in the environment in lieu of the second parameter. Our kitting domain consists of only one predicate that has no parameters. This predicate is used as a flag in order to force some actions to come before others during the formulation of the plan. Predicates of this nature are not treated in the concept of ``Spatial Relation''.
\end{itemize}



%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
\subsection{The OWL/XML Kitting Init and Goal Conditions File} \label{owlinitgoal}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++%
The OWL/XML kitting \onto{init} and \onto{goal} conditions files are used to build the PDDL problem file. This section first describes how a PDDL problem file is structured and then reviews the classes used in the different ontologies to build the PDDL problem file.

%-------------------------------------------------%
\subsubsection{Structure of a PDDL Problem File}
%-------------------------------------------------%
Figure~\ref{fig:problem} is a fragment of the problem file generated for our kitting system but it displays all the necessary components that constitute a PDDL problem file.

\begin{figure}[t!h!]
\begin{minipage}{.7\paperwidth}
\begin{list}{}{\setlength{\leftmargin}{1em}}\item\small
\begin{Verbatim}[commandchars=\\\{\},fontsize=\scriptsize, numbers=left, numbersep=2pt]
(define (problem kitting-problem)
   (:domain kitting-domain)
   (:objects
      robot_1 - Robot
      changing_station_1 - EndEffectorChangingStation
      kit_tray_1 - KitTray
      kit_a2b2c1 - Kit
      part_a_tray part_b_tray part_c_tray - PartsTray
      part_a_1 part_a_2 part_a_3 part_a_4 - Part
      kit_a2b2c1 - Kit
      ...)
    (:init
      (robot-with-no-endeffector robot_1)
      (partstray-not-empty part_a_tray)
      (partstray-not-empty part_b_tray)
      (partstray-not-empty part_c_tray)
      (part-location-partstray part_a_1 part_a_tray)
      (part-location-partstray part_b_1 part_b_tray)
      (part-location-partstray part_c_1 part_c_tray)
      ...
      (= (capacity-kit kit_a2b2c1 part_a_tray) 2)
      (= (capacity-kit kit_a2b2c1 part_b_tray) 2)
      (= (capacity-kit kit_a2b2c1 part_c_tray) 1)
      (= (quantity-kit kit_a2b2c1 part_a_tray) 0)
      (= (quantity-kit kit_a2b2c1 part_b_tray) 0)
      (= (quantity-kit kit_a2b2c1 part_c_tray) 0)
      (= (quantity-partstray part_a_tray) 4)
      (= (quantity-partstray part_b_tray) 4)
      (= (quantity-partstray part_c_tray) 4)
      ...)
    (:goal (and
      (= (quantity-kit kit_a2b2c1 part_a_tray) (capacity-kit kit_a2b2c1 part_a_tray))
      (= (quantity-kit kit_a2b2c1 part_b_tray) (capacity-kit kit_a2b2c1 part_b_tray))
      (= (quantity-kit kit_a2b2c1 part_c_tray) (capacity-kit kit_a2b2c1 part_c_tray))
      (kit-location-lbwk kit_a2b2c1 finished_kit_receiver))
)
\end{Verbatim}
\end{list}
\end{minipage}
\caption{Excerpt of a PDDL problem file for kitting.}
\label{fig:problem}
\end{figure}

The different sections that form the problem file are described below.
\begin{itemize}
\item line 1: Signal a planner that the current file contains all the elements required to constitute a PDDL problem file. \texttt{kitting-problem} is the name given to this problem.
\item line 2: \texttt{:domain} refers to the domain file that the current problem file depends on. In this case, the problem \texttt{kitting-problem} refers to the domain \texttt{kitting-domain}.
\item lines 4--11: \texttt{:objects} declare all the objects present in the world. Some of these objects are required in both the initial state and the goal state.
\item line 12: \texttt{:init} signals a planner that the predicates and functions in this section are true in the initial state.
\item lines 13--19: Predicates that true in the initial state of the world. Since PDDL uses a close world assumption, predicates that are not present in the initial state are automatically set to false. This section also set the initial values for functions. Some relevant sections are presented:
\item lines 21--29: Numerical values assigned to functions.
\item line 31: \texttt{:goal} is a keyword used to signal a planner that all predicates and functions within the goal section have to be true in order to reach the final state.
\end{itemize}

%------------------------------------------------------------------%
\subsubsection{Expression of a PDDL Problem file using Ontologies}
%------------------------------------------------------------------%
In our kitting system, the \texttt{init} and \texttt{goal} sections always consist of predicates and functions. The following steps describe how we build the OWL/XML kitting \onto{init} and \onto{goal} conditions files.
\begin{enumerate}
 \item In the \onto{SOAP} ontology, instances of the objects that will appear in the \texttt{:objects} section of the problem file are created. Since these objects are used in both the \texttt{init} and \texttt{goal} sections in the generated PDDL problem file, it is important to make these objects available to the OWL/XML kitting \onto{init} and \onto{goal} conditions files. For instance, the object \texttt{robot\_1} of type \texttt{Robot} (line 4 in Figure~\ref{fig:problem}) will be generated from the instance \texttt{robot\_1} in the class \class{Robot}, created in the \onto{SOAP} ontology.
 \item Predicates and functions that will appear in the \texttt{init} section for the generated PDDL problem file are created in the OWL/XML kitting \onto{init} file as instances of the class \class{Predicate} and \class{Function}, respectively.
 \item Predicates and functions that will appear in the \texttt{goal} section in the generated PDDL problem file are created in the OWL/XML kitting \onto{goal} file as instances of the class \class{Predicate} and \class{Function}, respectively.
 \item Instances of the class \class{Predicate} and of the class \class{Function} created in the OWL/XML kitting \onto{init} and \onto{goal} conditions files point to parameters (instances of classes) that have been created in the \onto{SOAP} ontology (step 1).
\end{enumerate}


