
The NIST's Knowledge Driven Planning and Modeling team has developed a methodology to generate a MySQL database from the kitting ontology. Reading data from and to the MySQL database instead of the ontology file offers the community an easy access to a live data structure. Furthermore, it is more practical to modify the information stored in a database than if it was stored in an ontology, which, in some cases, requires the deletion and re-creation of the whole files. Finally, a literature review reveals many efforts and methodologies to produce SQL databases from ontologies. Once the MySQL database in place and the tables filled with information from the ontology, the NIST's team developed tools to automatically generate a set of C++ classes in order to read the kitting MySQL database. Please note that choice of C++ was a team preference and we believe that other object-oriented languages could have been used in this project. The rest of this section describes the methodology and tools mentioned above. Excerpts of C++ classes are used to demonstrate the results.
\subsection{From the Ontolongy to the MySQL Database}\label{ss:ontology2db}

\subsection{From the MySQL Database to C++ Classes}
This section first discusses the tools developed to generate a set of C++ classes that is capable of accessing information in the MySQL database. An example is presented on how to use the generated classes to retrieve data from the MySQL database.

The idea is to propose an object-relational mapping tool within the executor module. The C++ classes regarding this object-relational mapping are all generated, and so are the Data Access Objects (DAO) to interact with the MySQL database. To map the MySQL database and indirectly the ontology to C++ classes, we had to perform the two following steps:
\begin{itemize}
\item Generate the C++ classes from the ontology itself.
\item Build the DAO with the help of the mapping of the ontology into the database (described in section~\ref{ss:ontology2db})
\end{itemize}


The generated C++ classes as well as MySQL tables are based upon the ontolongy's entities. To quote the OWL 2 Web Ontolongy website~\cite{OWLspec}, ``Entities are the fundamental building blocks of OWL 2 ontologies, and they define the vocabulary — the named terms — of an ontology. In logic, the set of entities is usually said to constitute the signature of an ontology''. Therefore, the notions of single-valued and multi-valued properties as well as the inheritance are kept from the ontolongy to the C++ classes.


Data property: The single-valued data properties are mapped into an attribute of the object with a corresponding type, and multi-valued data properties are mapped to a \texttt{std:vector}. For example, in the ontonlogy, a robot has a single-valued data property \texttt{hasRobot\_Description}, represented in the database as a \texttt{varchar} and in the corresponding C++ class as \texttt{std:string hasRobot\_Description}. In the ontonlogy, a stock keeping unit has a multi-valued
data property \texttt{hasSku\_EndEffectorRefs} mapped to a \texttt{std::vector\textless std::string\textgreater} in the corresponding C++ class.

Object property: The single-valued object properties are mapped to an attribute of the object, but their type is a pointer to the range of the object properties. The multi-valued object properties one are mapped to a \texttt{std:vector} of pointer referencing objects of the range of the property. To illustrate, a solid object has the object property \texttt{hasRobot\_Description} linking it to a physical location represented by a reference to a physical location: \texttt{PhysicalLocation* hasSolidObject\_PrimaryLocation}. A solid object also has a list of secondary location corresponding to a multi-valued object property in the ontology: {\scriptsize\texttt{std::vector\\ \textless PhysicalLocation*\textgreater hasSolidObject\_SecondaryLocation}}.


\subsubsection{Classes}

The C++ classes are generated according to the two following steps :
\begin{itemize}
\item The first step generates the header (.h) (see Figure~\ref{fig:headerclass}) and class file (.cpp) used for the connection with the database. It doesn't depend on
the content of the ontology, it only initializes the specific objects related to the MySQL connector driver.

\item The second step generates all the C++ headers and class files relative to our ontology. All the classes in the ontology are C++ classes, and all the data properties in the ontology are attributes of the C++ classes. The link
between the ontology entities made with the help of the object properties results in the C++ classes in pointers to an object
having the same type as the range of the object property. The notion of multiple values are solved with the use of \texttt{std::vector}.
\end{itemize}

The different includes are made in the C++ class files and only forward declarations are done in the different headers. 
Doing so resolves the different problems associated to circular includes or multiple ones. In addition to the different getter 
and setter, the classes have and \textit{explode} method that splits a string into a vector around matches of a given regular expression, 
and a \textit{copy} method that takes a C++ map as input and copy the values from the map into the instance. The classes also consist of \textit{get} and \textit{set} methods that initialize and use the DAO to read and write data from and to the MySQL database.

\begin{figure}[t!h!]
\begin{minipage}{.5\paperwidth}
\begin{mylisting}
\begin{Verbatim}[commandchars=\\\{\},fontsize=\scriptsize, numbersep=2pt]
\textbf{#ifndef} PARTSBIN_H_
\textbf{#define} PARTSBIN_H_
\textbf{#include} <cstdlib>
\textbf{#include} <iostream>
\textbf{#include} <map>
\textbf{#include} <string>
\textbf{#include} <vector>
\textbf{#include} <sstream>

\textbf{#include} "BoxyObject.h"
\textbf{class} DAO;
\textbf{class} PartsBin: \textbf{public} BoxyObject \{
    \textbf{private}:
        std::string hasBin_PartQuantity;
        std::string hasBin_PartSkuRef;
        \textbf{int} PartsBinID;
        DAO* dao;
    \textbf{public}:
        PartsBin(std::string name);
        ~PartsBin();
        \textbf{void} get(\textbf{int} id);
        \textbf{void} get(std::string name);
        \textbf{void} set(\textbf{int} id, PartsBin* obj);
        \textbf{void} set(std::string name);
        std::string gethasBin_PartQuantity();
        \textbf{void} sethasBin_PartQuantity(
            std::string _hasBin_PartQuantity);
        std::string gethasBin_PartSkuRef();
        \textbf{void} sethasBin_PartSkuRef(
            std::string _hasBin_PartSkuRef);
        \textbf{int} getPartsBinID();
        DAO* getdao();
        \textbf{void} setdao(DAO* _dao);
        \textbf{void} copy(std::map<std::string,
            std::string> object);
        std::vector<std::string> Explode(
            \textbf{const} std::string & str, \textbf{char} separator);
\};
\textbf{#endif} /* PARTSBIN_H_ */
\end{Verbatim}
\end{mylisting}
\end{minipage}
\caption{Header of a generated class.}
\label{fig:headerclass}
\end{figure}



%\lstset{frame=single, language=C++, caption=Header of a generated class, label=Header of a generated class,
%captionpos=b}
%\begin{lstlisting}
%#ifndef PARTSBIN_H_
%#define PARTSBIN_H_
%#include <cstdlib>
%#include <iostream>
%#include <map>
%#include <string>
%#include <vector>
%#include <sstream>
%
%#include "BoxyObject.h"
%class DAO;
%class PartsBin: public BoxyObject {
%private:
%	std::string hasBin_PartQuantity;
%	std::string hasBin_PartSkuRef;
%	int PartsBinID;
%	DAO* dao;
%public:
%	PartsBin(std::string name);
%	~PartsBin();
%	void get(int id);
%	void get(std::string name);
%	void set(int id, PartsBin* obj);
%	void set(std::string name);
%	std::string gethasBin_PartQuantity();
%	void sethasBin_PartQuantity(
%		std::string _hasBin_PartQuantity);
%	std::string gethasBin_PartSkuRef();
%	void sethasBin_PartSkuRef(
%		std::string _hasBin_PartSkuRef);
%	int getPartsBinID();
%	DAO* getdao();
%	void setdao(DAO* _dao);
%	void copy(std::map<std::string, std::string> object);
%	std::vector<std::string> Explode(
%		  const std::string & str, char separator);
%};
%#endif /* PARTSBIN_H_ */
%\end{lstlisting}



\subsubsection{Data Access Object}

A data access object (DAO) provides an abstract interface to some type of database or other persistence
mechanism. By mapping application calls to the persistence layer, DAOs provide some specific data operations without exposing
details of the database. This isolation separates the concerns of what data accesses the application needs, in terms of
domain-specific objects and data types (the public interface of the DAO), and how these needs can be satisfied with a specific
DBMS, database schema, etc.

A similar mechanism has been used in this project for the interaction between the C++ classes used by the executor module and 
the MySQL database (see Figure~\ref{fig:headerdao}). The different methods of the DAO are the same for any ontology. 
We don't care about the data here, only the way we retrieve or store them. Only the four vectors filled by the\texttt{fillGetSqlQueries} method differ from one C++ file to another file.

When the DAO is generated, four vectors are built as follows:

\begin{itemize}
\item line \textcolor{BrickRed}{17} : A structure with the SQL query to select the content of the tables relative to an entity : the table relative to the entity itself and the ones relative to its super classes
\item line \textcolor{BrickRed}{18} : A structure with the SQL query to select the multi-valued attributes (multi-valued data) for a given entity
\item line \textcolor{BrickRed}{19} : A structure with the names of the tables linked to this entity in the ontology
\item line \textcolor{BrickRed}{20} : A structure with the names of the association tables linked to an object
\end{itemize}

With these four structures, we are able to read (\texttt{get} method) and write (\texttt{set} method) data from and to the MySQL database. The \texttt{get} method fill a C++ map and let the object itself and the \texttt{copy} method deal with the data. As for the method \texttt{set}, the object calls it with a C++ map with the values of his different attributes in input and the \texttt{set} method writes these values into the MySQL database.


\begin{figure}[t!h!]
\begin{minipage}{.5\paperwidth}
\begin{mylisting}
\begin{Verbatim}[commandchars=\\\{\},fontsize=\scriptsize, numbers=left, numbersep=2pt]
\textbf{#ifndef} DAO_H_
\textbf{#define} DAO_H_
\textbf{#include} <cstdlib>
\textbf{#include} <iostream>
\textbf{#include} <map>
\textbf{#include} <vector>
\textbf{#include} <sstream>

\textbf{#include} "Connection.h"
\textbf{class} DAO \{
    \textbf{private}:
      std::vector<std::string> className;
      Connection* connection;
      std::vector<std::string> nameDone;
      std::map<std::string, std::string> map;
      std::string path; std::string pathmulti;
      \textbf{static} std::map<std::string, std::string>
        getSqlQueriesDataSingle;
      \textbf{static} std::map<std::string, std::vector<std::string>>
			getSqlQueriesDataMulti;
      \textbf{static} std::map<std::string, std::vector<std::string>>
			getSqlQueriesObjectSingle;
      \textbf{static} std::map<std::string, std::vector<std::string>>
			getSqlQueriesObjectMulti;
      \textbf{static} std::map<std::string, std::vector<std::string>>
				  setSqlQueries;
      \textbf{static} std::map<std::string, std::vector<std::string>>
				updateSqlQueries;
      \textbf{void} fillGetSqlQueries();
    \textbf{public}:
      DAO(std::string name); ~DAO();
      std::vector<std::string> getclassName();
      \textbf{void} setclassName(std::vector<std::string> _className);
      Connection* getconnection();
      \textbf{void} setconnection(Connection* _connection);
      std::map<std::string,std::string> get(std::string name);
      \textbf{void} set(std::map<std::string, std::string> data);
      std::vector<std::string> Explode(\textbf{const} std::string & str,
      \textbf{char separator});
\};
\textbf{#endif} /* DAO_H_ */
\end{Verbatim}
\end{mylisting}
\end{minipage}
\caption{Header of the DAO class.}
\label{fig:headerdao}
\end{figure}


%\lstset{frame=single, language=C++, caption=Header of our DAO class, label=Header of our DAO class,
%captionpos=b}
%\begin{lstlisting}
%#ifndef DAO_H_
%#define DAO_H_
%#include <cstdlib>
%#include <iostream>
%#include <map>
%#include <vector>
%#include <sstream>
%#include "Connection.h"
%class DAO {
%private:
%	std::vector<std::string> className;
%	Connection* connection;
%	std::vector<std::string> nameDone;
%	std::map<std::string, std::string> map;
%	std::string path; std::string pathmulti;
%	static std::map<std::string, std::string>
%				  getSqlQueriesDataSingle;
%	static std::map<std::string, std::vector<std::string> >
%			getSqlQueriesDataMulti;
%	static std::map<std::string, std::vector<std::string> >
%			getSqlQueriesObjectSingle;
%	static std::map<std::string, std::vector<std::string> >
%			getSqlQueriesObjectMulti;
%	static std::map<std::string, std::vector<std::string> >
%				  setSqlQueries;
%	static std::map<std::string, std::vector<std::string> >
%				updateSqlQueries;
%	void fillGetSqlQueries();
%public:
%	DAO(std::string name); ~DAO();
%	std::vector<std::string> getclassName();
%	void setclassName(std::vector<std::string> _className);
%	Connection* getconnection();
%	void setconnection(Connection* _connection);
%	std::map<std::string,std::string> get(std::string name);
%	void set(std::map<std::string, std::string> data);
%	std::vector<std::string> Explode(const
%			std::string & str, char separator);
%};
%#endif /* DAO_H_ */
%\end{lstlisting}


\subsubsection{How to Use the C++ Classes to Access Data from the MySQL Database}

\begin{figure}[t!h!]
\begin{minipage}{.5\paperwidth}
\begin{mylisting}
\begin{Verbatim}[commandchars=\\\{\},fontsize=\scriptsize, numbers=left, numbersep=2pt]
#include "Point.h"
#include "PoseLocation.h"
#include "Vector.h"
#include "KitTray.h"

void CanonicalRobotCommand::
 getKitTrayLocation(string kit_tray_name)\{

  KitTray* kit_tray = \textbf{new} KitTray(kit_tray_name);
  kit_tray->get(kit_tray_name);

  PoseLocation* kit_tray_pose = \textbf{new} PoseLocation(
  kit_tray->gethasSolidObject_PrimaryLocation()->getname());
  kit_tray_pose->get(kit_tray_pose->getname());

  //--Retrieve hasPoseLocation_Point
  Point * kit_tray_point =
  kit_tray_pose->gethasPoseLocation_Point();

  //--Retrieve hasPoseLocation_XAxis
  Vector * kit_tray_x_axis  =
  kit_tray_pose->gethasPoseLocation_XAxis();

  //--Retrieve hasPoseLocation_ZAxis
  Vector * kit_tray_z_axis  =
  kit_tray_pose->gethasPoseLocation_ZAxis();
\}
\end{Verbatim}
\end{mylisting}
\end{minipage}
\caption{Example using the generated C++ classes.}
\label{fig:exampleofuse}
\end{figure}


%\lstset{frame=single, language=C++, caption=How to use the C++ classes, label=How to use the C++ classes,
%captionpos=b}
%\begin{lstlisting}
%KitTrayLocStruct CanonicalRobotCommand::getKitTrayLocation(string kit_tray_name){
%
%	KitTrayLocStruct kit_tray_loc_struct;
%
%	KitTray* kit_tray = new KitTray(kit_tray_name);
%	kit_tray->get(kit_tray_name);
%
%	PoseLocation* kit_tray_pose = new PoseLocation(kit_tray->gethasSolidObject_PrimaryLocation()->getname());
%	kit_tray_pose->get(kit_tray_pose->getname());
%
%	//--Retrieve hasPoseLocation_Point
%	Point * kit_tray_point = kit_tray_pose->gethasPoseLocation_Point();
%	//--Retrieve hasPoseLocation_XAxis
%	Vector * kit_tray_x_axis  = kit_tray_pose->gethasPoseLocation_XAxis();
%	//--Retrieve hasPoseLocation_ZAxis
%	Vector * kit_tray_z_axis  = kit_tray_pose->gethasPoseLocation_ZAxis();
%
%	kit_tray_loc_struct.point=kit_tray_point;
%	kit_tray_loc_struct.x_axis=kit_tray_x_axis;
%	kit_tray_loc_struct.z_axis=kit_tray_z_axis;
%
%	return kit_tray_loc_struct;
%}
%\end{lstlisting}

Figure~\ref{fig:exampleofuse} depicts an example using the generated classes to retrieve the location of the kit tray \texttt{kit\_tray\_name} from the MySQL database. The different sections of the example are described below:

\begin{itemize}
\item lines \textcolor{BrickRed}{1--4}: Include the different headers necessary to query MySQL tables. Here, the tables Point, PoseLocation, Vector, and KitTray are required.
\item line \textcolor{BrickRed}{9}: Initialize an object from the class \texttt{KitTray} by passing his name.
\item line \textcolor{BrickRed}{10}: Allow access to any data from the table KitTray.
\item lines \textcolor{BrickRed}{12--13}: Initialize an object of type \texttt{PoseLocation} and allow access to any data from the table PoseLocation.
\item lines \textcolor{BrickRed}{17--18}: Retrieve X, Y, and Z coordinates from the table Point for the kit tray \texttt{kit\_tray\_name}.
\item lines \textcolor{BrickRed}{21--22}: Retrieve the X axis vector ($X_i$, $X_j$, $X_k$) from the table Vector for the kit tray \texttt{kit\_tray\_name}.
\item lines \textcolor{BrickRed}{17--18}: Retrieve the y axis vector ($Y_i$, $Y_j$, $Y_k$) from the table Vector for the kit tray \texttt{kit\_tray\_name}.
\end{itemize}


