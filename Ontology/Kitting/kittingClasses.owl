Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingClasses.owl#>)

Ontology(<http://www.nist.gov/el/ontologies/kittingClasses.owl>

Annotation(rdfs:comment
  "This kitting ontology models a kitting workstation including objects
  in the workstation and data associated with the workstation. The
  ontology assumes coordinate systems are right handed. For objects
  such as trays or a robot with a preferred orientation with respect to
  gravity, the Z axis points up (opposite the pull of gravity).")



DatatypeDefinition(:angleUnit 
  DataOneOf("degree" "radian"))

DatatypeDefinition(:lengthUnit 
  DataOneOf("meter" "millimeter" "inch"))

DatatypeDefinition(:positiveDecimal 
  DatatypeRestriction(xsd:decimal xsd:minExclusive "0"^^xsd:decimal))

DatatypeDefinition(:weightUnit 
  DataOneOf("kilogram" "gram" "milligram" "ounce" "pound"))



Declaration(Class(:BoxVolume))

AnnotationAssertion(rdfs:comment :BoxVolume
  "A BoxVolumeType has a Name element inherited from DataThingType. It
  also has MaximumPoint and MinimumPoint elements. These are
  diagonally opposite corner points of a box shaped volume whose
  edges are aligned with the coordinate system in which the
  BoxVolumeType is located. The MinimumPoint has the minimum values
  of X, Y, and Z. The MaximumPoint has the maximum values of X, Y,
  and Z.")

Declaration(ObjectProperty(:hasBoxVolume_MaximumPoint))
ObjectPropertyDomain(:hasBoxVolume_MaximumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MaximumPoint :Point)
InverseFunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
FunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
EquivalentClasses(:BoxVolume ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBoxVolume_MaximumPoint :Point)
  ObjectAllValuesFrom (:hasBoxVolume_MaximumPoint :Point)))

Declaration(ObjectProperty(:hadByMaximumPoint_BoxVolume))
InverseObjectProperties(:hasBoxVolume_MaximumPoint
                        :hadByMaximumPoint_BoxVolume)
ObjectPropertyDomain(:hadByMaximumPoint_BoxVolume :Point)
ObjectPropertyRange(:hadByMaximumPoint_BoxVolume :BoxVolume)

Declaration(ObjectProperty(:hasBoxVolume_MinimumPoint))
ObjectPropertyDomain(:hasBoxVolume_MinimumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MinimumPoint :Point)
InverseFunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
FunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
EquivalentClasses(:BoxVolume ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBoxVolume_MinimumPoint :Point)
  ObjectAllValuesFrom (:hasBoxVolume_MinimumPoint :Point)))

Declaration(ObjectProperty(:hadByMinimumPoint_BoxVolume))
InverseObjectProperties(:hasBoxVolume_MinimumPoint
                        :hadByMinimumPoint_BoxVolume)
ObjectPropertyDomain(:hadByMinimumPoint_BoxVolume :Point)
ObjectPropertyRange(:hadByMinimumPoint_BoxVolume :BoxVolume)



Declaration(Class(:BoxyShape))

AnnotationAssertion(rdfs:comment :BoxyShape
  "A BoxyShapeType is an InternalShapeType that is box shaped. It has
  a Name, Description, and GraspPose elements inherited from
  InternalShapeType. It also has Length, Width, Height, and HasTop
  elements. The length is larger of the two dimensions that are not
  the height. The width is smaller of the two dimensions that are not
  the height. The coordinate system of a BoxyShapeType (i.e. the
  thing that is located and oriented by a pose) has its origin in the
  middle of the bottom, its Z-axis parallel to the height sides, and
  its X-axis parallel to the length sides. If HasTop is true, the top
  of the box (i.e. the side through which the +Z axis passes) exists
  and is closed. If HasTop is false, the box has no top.")

Declaration(DataProperty(:hasBoxyShape_Length))
DataPropertyDomain(:hasBoxyShape_Length :BoxyShape)
DataPropertyRange(:hasBoxyShape_Length :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Length)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Length :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Length :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_Width))
DataPropertyDomain(:hasBoxyShape_Width :BoxyShape)
DataPropertyRange(:hasBoxyShape_Width :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Width)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Width :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Width :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_Height))
DataPropertyDomain(:hasBoxyShape_Height :BoxyShape)
DataPropertyRange(:hasBoxyShape_Height :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Height)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Height :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Height :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_HasTop))
DataPropertyDomain(:hasBoxyShape_HasTop :BoxyShape)
DataPropertyRange(:hasBoxyShape_HasTop xsd:boolean)
FunctionalDataProperty(:hasBoxyShape_HasTop)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_HasTop xsd:boolean)
  DataAllValuesFrom (:hasBoxyShape_HasTop xsd:boolean)))



Declaration(Class(:CylindricalShape))

AnnotationAssertion(rdfs:comment :CylindricalShape
  "A CylindricalShapeType is an InternalShapeType that is cylindrical.
  It has a Name, Description, and GraspPose elements inherited from
  InternalShapeType. It also has Diameter, Height, and HasTop
  elements. The cylinder is a right circular cylinder with a
  circular base having the given diameter. The axis is perpendicular
  to the base. The base is always a surface that is part of the
  cylinder. The sides of the cylinder stop at the given height as if
  cut by a plane perpendicular to the axis. The coordinate system
  of a CylindrialShapeType (i.e. the thing that is located and
  oriented by a pose) has its origin in the middle of the bottom, and
  its Z-axis on the axis of the cylinder. If HasTop is true, the top
  of the cylinder (i.e. the side through which the +Z axis passes)
  exists and is closed. If HasTop is false, the cylinder has no top.")

Declaration(DataProperty(:hasCylindricalShape_Diameter))
DataPropertyDomain(:hasCylindricalShape_Diameter :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_Diameter :positiveDecimal)
FunctionalDataProperty(:hasCylindricalShape_Diameter)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_Diameter :positiveDecimal)
  DataAllValuesFrom (:hasCylindricalShape_Diameter :positiveDecimal)))

Declaration(DataProperty(:hasCylindricalShape_Height))
DataPropertyDomain(:hasCylindricalShape_Height :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_Height :positiveDecimal)
FunctionalDataProperty(:hasCylindricalShape_Height)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_Height :positiveDecimal)
  DataAllValuesFrom (:hasCylindricalShape_Height :positiveDecimal)))

Declaration(DataProperty(:hasCylindricalShape_HasTop))
DataPropertyDomain(:hasCylindricalShape_HasTop :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_HasTop xsd:boolean)
FunctionalDataProperty(:hasCylindricalShape_HasTop)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_HasTop xsd:boolean)
  DataAllValuesFrom (:hasCylindricalShape_HasTop xsd:boolean)))



Declaration(Class(:DataThing))

AnnotationAssertion(rdfs:comment :DataThing
  "A DataThing includes all complex data types such as Vector,
  PhysicalLocation, etc. A DataThing has a Name to make it easy
  to reference when generating OWL. Names are of type xs:ID so that
  all names must be unique. Names also must not be the same as Ids.")
SubClassOf(:BoxVolume :DataThing)
SubClassOf(:KitDesign :DataThing)
SubClassOf(:PartRefAndPose :DataThing)
SubClassOf(:PhysicalLocation :DataThing)
SubClassOf(:Point :DataThing)
SubClassOf(:ShapeDesign :DataThing)
SubClassOf(:Slot :DataThing)
SubClassOf(:StockKeepingUnit :DataThing)
SubClassOf(:Vector :DataThing)
DisjointUnion(:DataThing
              :BoxVolume
              :KitDesign
              :PartRefAndPose
              :PhysicalLocation
              :Point
              :ShapeDesign
              :Slot
              :StockKeepingUnit
              :Vector)



Declaration(Class(:EndEffector))

AnnotationAssertion(rdfs:comment :EndEffector
  "An EndEffectorType is a SolidObjectType. It is an end effector for
  a robot. It has Name, PrimaryLocation, SecondaryLocation,
  InternalShape, and ExternalShape elements inherited from
  SolidObjectType. An EndEffectorType also has Description, Weight,
  MaximumLoadWeight, and HeldObject elements. The optional HeldObject
  element is for the object being held by the end effector, if the
  end effector is holding an object. Every EndEffectorType is either
  a GripperEffectorType or a VacuumEffectorType. Every
  EndEffectorType in a KittingWorkstation is either attached to the
  end of a robot arm or sitting in an EndEffectorHolderType at an
  EndEffectorChangingStationType.")
SubClassOf(:GripperEffector :EndEffector)
SubClassOf(:VacuumEffector :EndEffector)
DisjointUnion(:EndEffector
              :GripperEffector
              :VacuumEffector)

Declaration(DataProperty(:hasEndEffector_Description))
DataPropertyDomain(:hasEndEffector_Description :EndEffector)
DataPropertyRange(:hasEndEffector_Description xsd:string)
FunctionalDataProperty(:hasEndEffector_Description)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_Description xsd:string)
  DataAllValuesFrom (:hasEndEffector_Description xsd:string)))

Declaration(DataProperty(:hasEndEffector_Weight))
DataPropertyDomain(:hasEndEffector_Weight :EndEffector)
DataPropertyRange(:hasEndEffector_Weight :positiveDecimal)
FunctionalDataProperty(:hasEndEffector_Weight)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_Weight :positiveDecimal)
  DataAllValuesFrom (:hasEndEffector_Weight :positiveDecimal)))

Declaration(DataProperty(:hasEndEffector_MaximumLoadWeight))
DataPropertyDomain(:hasEndEffector_MaximumLoadWeight :EndEffector)
DataPropertyRange(:hasEndEffector_MaximumLoadWeight :positiveDecimal)
FunctionalDataProperty(:hasEndEffector_MaximumLoadWeight)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_MaximumLoadWeight :positiveDecimal)
  DataAllValuesFrom (:hasEndEffector_MaximumLoadWeight :positiveDecimal)))

Declaration(ObjectProperty(:hasEndEffector_HeldObject))
ObjectPropertyDomain(:hasEndEffector_HeldObject :EndEffector)
ObjectPropertyRange(:hasEndEffector_HeldObject :SolidObject)
InverseFunctionalObjectProperty(:hasEndEffector_HeldObject)
FunctionalObjectProperty(:hasEndEffector_HeldObject)

Declaration(ObjectProperty(:hadByHeldObject_EndEffector))
InverseObjectProperties(:hasEndEffector_HeldObject
                        :hadByHeldObject_EndEffector)
ObjectPropertyDomain(:hadByHeldObject_EndEffector :SolidObject)
ObjectPropertyRange(:hadByHeldObject_EndEffector :EndEffector)



Declaration(Class(:EndEffectorChangingStation))

AnnotationAssertion(rdfs:comment :EndEffectorChangingStation
  "An EndEffectorChangingStationType is a SolidObjectType. It has
  Name, PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  a Base element and one to many EndEffectorHolder elements. It is a
  place where end effectors are stored and where the robot can change
  end effectors. The coordinate system of an
  EndEffectorChangingStationType is in the same place as the
  coordinate system of its Base. The shape of an
  EndEffectorChangingStationType may also be found from the shapes of
  the Base and the EndEffectorHolders and their relative positions.")

Declaration(ObjectProperty(:hasEndEffectorChangingStation_Base))
ObjectPropertyDomain(:hasEndEffectorChangingStation_Base :EndEffectorChangingStation)
ObjectPropertyRange(:hasEndEffectorChangingStation_Base :MechanicalComponent)
InverseFunctionalObjectProperty(:hasEndEffectorChangingStation_Base)
FunctionalObjectProperty(:hasEndEffectorChangingStation_Base)
EquivalentClasses(:EndEffectorChangingStation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasEndEffectorChangingStation_Base :MechanicalComponent)
  ObjectAllValuesFrom (:hasEndEffectorChangingStation_Base :MechanicalComponent)))

Declaration(ObjectProperty(:hadByBase_EndEffectorChangingStation))
InverseObjectProperties(:hasEndEffectorChangingStation_Base
                        :hadByBase_EndEffectorChangingStation)
ObjectPropertyDomain(:hadByBase_EndEffectorChangingStation :MechanicalComponent)
ObjectPropertyRange(:hadByBase_EndEffectorChangingStation :EndEffectorChangingStation)

Declaration(ObjectProperty(:hasEndEffectorChangingStation_EndEffectorHolder))
ObjectPropertyDomain(:hasEndEffectorChangingStation_EndEffectorHolder :EndEffectorChangingStation)
ObjectPropertyRange(:hasEndEffectorChangingStation_EndEffectorHolder :EndEffectorHolder)
InverseFunctionalObjectProperty(:hasEndEffectorChangingStation_EndEffectorHolder)

Declaration(ObjectProperty(:hadByEndEffectorHolder_EndEffectorChangingStation))
InverseObjectProperties(:hasEndEffectorChangingStation_EndEffectorHolder
                        :hadByEndEffectorHolder_EndEffectorChangingStation)
ObjectPropertyDomain(:hadByEndEffectorHolder_EndEffectorChangingStation :EndEffectorHolder)
ObjectPropertyRange(:hadByEndEffectorHolder_EndEffectorChangingStation :EndEffectorChangingStation)



Declaration(Class(:EndEffectorHolder))

AnnotationAssertion(rdfs:comment :EndEffectorHolder
  "An EndEffectorHolderType is a SolidObjectType,
  from which it has the following inherited elements:
  Name
  PrimaryLocation
  SecondaryLocation
  InternalShape
  ExternalShape
  It also has zero or one EndEffectorType element. An
  EndEffectorHolderType is part of an EndEffectorChangingStationType.")

Declaration(ObjectProperty(:hasEndEffectorHolder_EndEffector))
ObjectPropertyDomain(:hasEndEffectorHolder_EndEffector :EndEffectorHolder)
ObjectPropertyRange(:hasEndEffectorHolder_EndEffector :EndEffector)
InverseFunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
FunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)

Declaration(ObjectProperty(:hadByEndEffector_EndEffectorHolder))
InverseObjectProperties(:hasEndEffectorHolder_EndEffector
                        :hadByEndEffector_EndEffectorHolder)
ObjectPropertyDomain(:hadByEndEffector_EndEffectorHolder :EndEffector)
ObjectPropertyRange(:hadByEndEffector_EndEffectorHolder :EndEffectorHolder)



Declaration(Class(:ExternalShape))

AnnotationAssertion(rdfs:comment :ExternalShape
  "An ExternalShapeType is a ShapeDesignType whose shape is defined in
  an external file. It has Name, Description, and GraspPose elements
  inherited from ShapeDesignType. It also has ModelTypeName,
  ModelFileName, and ModelName elements. ModelTypeName is the name of
  the type of model (for example, 'STEP Advanced Brep' or 'USARSim').
  ModelFileName is the name of the file containing the model and may
  include a path (for example 'partFiles/STEP/ANC101.stp'). The model
  file may contain more than one shape model. The ModelName is
  optional and is the name of a model within the model file. The
  ModelName is necessary if the model file contains more than one
  model.")

Declaration(DataProperty(:hasExternalShape_ModelTypeName))
DataPropertyDomain(:hasExternalShape_ModelTypeName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelTypeName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelTypeName)
EquivalentClasses(:ExternalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasExternalShape_ModelTypeName xsd:string)
  DataAllValuesFrom (:hasExternalShape_ModelTypeName xsd:string)))

Declaration(DataProperty(:hasExternalShape_ModelFileName))
DataPropertyDomain(:hasExternalShape_ModelFileName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelFileName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelFileName)
EquivalentClasses(:ExternalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasExternalShape_ModelFileName xsd:string)
  DataAllValuesFrom (:hasExternalShape_ModelFileName xsd:string)))

Declaration(DataProperty(:hasExternalShape_ModelName))
DataPropertyDomain(:hasExternalShape_ModelName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelName)



Declaration(Class(:GripperEffector))

AnnotationAssertion(rdfs:comment :GripperEffector
  "A GripperEffectorType is an EndEffectorType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, ExternalShape,
  Description, Weight, and MaximumLoadWeight elements inherited from
  EndEffectorType. A GripperEffectorType holds an object by gripping
  it with fingers or claws or by suction.")



Declaration(Class(:Human))

AnnotationAssertion(rdfs:comment :Human
  "A HumanType is a type representing a human being. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. The shape of
  a human is the shape of a bounding box (or other bounding shape)
  that encloses the human completely.")



Declaration(Class(:InternalShape))

AnnotationAssertion(rdfs:comment :InternalShape
  "An InternalShapeType is an abstract type derived from
  ShapeDesignType from which more specific types of shape are
  derived. It has Name, Description, and GraspPose elements inherited
  from ShapeDesignType. Instances of InternalShapeType in a data file
  conforming to this schema contain information about the appearance
  of the shape without referring to another file.")
SubClassOf(:BoxyShape :InternalShape)
SubClassOf(:CylindricalShape :InternalShape)
DisjointUnion(:InternalShape
              :BoxyShape
              :CylindricalShape)



Declaration(Class(:Kit))

AnnotationAssertion(rdfs:comment :Kit
  "A KitType is a SolidObjectType. It has Name, PrimaryLocation,
  SecondaryLocation, InternalShape, and ExternalShape elements
  inherited from SolidObjectType. A KitType also has
  DesignName(IDREF), Tray, and Finished elements, zero to many Part
  elements, and zero to many Slot elements. Finished is a boolean
  indicator of whether the Kit is finished. The Part element may
  occur several times (once for each part in the kit). The optional
  Slot elements may be used to keep track of whether each place in
  the kit that should have a part on it does have a part on it. The
  PartRefAndPoseName of each Slot should be the name of a
  PartRefAndPose in the design of the kit (different for each slot).
  The locating point of the Tray in the kit should be (0,0,0), and
  its X and Z axes should be (1,0,0) and (0,0,1), respectively.")


Declaration(ObjectProperty(:hasKit_Design))
ObjectPropertyDomain(:hasKit_Design :Kit)
ObjectPropertyRange(:hasKit_Design :KitDesign)
FunctionalObjectProperty(:hasKit_Design)
EquivalentClasses(:Kit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKit_Design :KitDesign)
  ObjectAllValuesFrom (:hasKit_Design :KitDesign)))

HasKey(:KitTray (:hasKitTray_Sku) (:hasKitTray_SerialNumber))

Declaration(ObjectProperty(:hasKit_KitTray))
ObjectPropertyDomain(:hasKit_KitTray :Kit)
ObjectPropertyRange(:hasKit_KitTray :KitTray)
InverseFunctionalObjectProperty(:hasKit_KitTray)
FunctionalObjectProperty(:hasKit_KitTray)
EquivalentClasses(:Kit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKit_KitTray :KitTray)
  ObjectAllValuesFrom (:hasKit_KitTray :KitTray)))

Declaration(ObjectProperty(:hadByKitTray_Kit))
InverseObjectProperties(:hasKit_KitTray
                        :hadByKitTray_Kit)
ObjectPropertyDomain(:hadByKitTray_Kit :KitTray)
ObjectPropertyRange(:hadByKitTray_Kit :Kit)

HasKey(:Part (:hasPart_Sku) (:hasPart_SerialNumber))

Declaration(ObjectProperty(:hasKit_Part))
ObjectPropertyDomain(:hasKit_Part :Kit)
ObjectPropertyRange(:hasKit_Part :Part)
InverseFunctionalObjectProperty(:hasKit_Part)

Declaration(ObjectProperty(:hadByPart_Kit))
InverseObjectProperties(:hasKit_Part
                        :hadByPart_Kit)
ObjectPropertyDomain(:hadByPart_Kit :Part)
ObjectPropertyRange(:hadByPart_Kit :Kit)

Declaration(ObjectProperty(:hasKit_Slot))
ObjectPropertyDomain(:hasKit_Slot :Kit)
ObjectPropertyRange(:hasKit_Slot :Slot)
InverseFunctionalObjectProperty(:hasKit_Slot)

Declaration(ObjectProperty(:hadBySlot_Kit))
InverseObjectProperties(:hasKit_Slot
                        :hadBySlot_Kit)
ObjectPropertyDomain(:hadBySlot_Kit :Slot)
ObjectPropertyRange(:hadBySlot_Kit :Kit)

Declaration(DataProperty(:hasKit_Finished))
DataPropertyDomain(:hasKit_Finished :Kit)
DataPropertyRange(:hasKit_Finished xsd:boolean)
FunctionalDataProperty(:hasKit_Finished)
EquivalentClasses(:Kit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKit_Finished xsd:boolean)
  DataAllValuesFrom (:hasKit_Finished xsd:boolean)))



Declaration(Class(:KitDesign))

AnnotationAssertion(rdfs:comment :KitDesign
  "A KitDesignType is a DataThingType. A KitDesignType has a Name
  element inherited from DataThingType. It also has a KitTraySkuName
  element and one to many PartRefAndPose elements. The KitTraySkuName
  identifies a type of kit tray. The Pose in a PartRefAndPose is the
  location of the part relative to the coordinate system of the
  ShapeDesign of the tray.")


Declaration(ObjectProperty(:hasKitDesign_KitTraySku))
ObjectPropertyDomain(:hasKitDesign_KitTraySku :KitDesign)
ObjectPropertyRange(:hasKitDesign_KitTraySku :StockKeepingUnit)
FunctionalObjectProperty(:hasKitDesign_KitTraySku)
EquivalentClasses(:KitDesign ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKitDesign_KitTraySku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasKitDesign_KitTraySku :StockKeepingUnit)))

Declaration(ObjectProperty(:hasKitDesign_PartRefAndPose))
ObjectPropertyDomain(:hasKitDesign_PartRefAndPose :KitDesign)
ObjectPropertyRange(:hasKitDesign_PartRefAndPose :PartRefAndPose)
InverseFunctionalObjectProperty(:hasKitDesign_PartRefAndPose)

Declaration(ObjectProperty(:hadByPartRefAndPose_KitDesign))
InverseObjectProperties(:hasKitDesign_PartRefAndPose
                        :hadByPartRefAndPose_KitDesign)
ObjectPropertyDomain(:hadByPartRefAndPose_KitDesign :PartRefAndPose)
ObjectPropertyRange(:hadByPartRefAndPose_KitDesign :KitDesign)



Declaration(Class(:KittingWorkstation))

AnnotationAssertion(rdfs:comment :KittingWorkstation
  "A KittingWorkstationType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  AngleUnit, LengthUnit, WeightUnit, ChangingStation, one to many
  Object, one to many OtherObstacle, Robot, one to many KitDesign,
  and one to many Sku elements. All angle, length, and
  weight values related to the workstation use the units implicitly.")
AnnotationAssertion(rdfs:comment :KittingWorkstation
  "Containers of various sorts enter and leave the workstation. The
  robot builds kits of parts by executing kitting plans as directed
  by a kitting plan execution system. The location of each instance
  of KittingWorkstation should be given relative to itself in order
  to end the chain of relative locations.")

Declaration(DataProperty(:hasKittingWorkstation_AngleUnit))
DataPropertyDomain(:hasKittingWorkstation_AngleUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_AngleUnit :angleUnit)
FunctionalDataProperty(:hasKittingWorkstation_AngleUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_AngleUnit :angleUnit)
  DataAllValuesFrom (:hasKittingWorkstation_AngleUnit :angleUnit)))

Declaration(ObjectProperty(:hasKittingWorkstation_ChangingStation))
ObjectPropertyDomain(:hasKittingWorkstation_ChangingStation :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)
InverseFunctionalObjectProperty(:hasKittingWorkstation_ChangingStation)
FunctionalObjectProperty(:hasKittingWorkstation_ChangingStation)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)
  ObjectAllValuesFrom (:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)))

Declaration(ObjectProperty(:hadByChangingStation_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_ChangingStation
                        :hadByChangingStation_KittingWorkstation)
ObjectPropertyDomain(:hadByChangingStation_KittingWorkstation :EndEffectorChangingStation)
ObjectPropertyRange(:hadByChangingStation_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_KitDesign))
ObjectPropertyDomain(:hasKittingWorkstation_KitDesign :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_KitDesign :KitDesign)
InverseFunctionalObjectProperty(:hasKittingWorkstation_KitDesign)

Declaration(ObjectProperty(:hadByKitDesign_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_KitDesign
                        :hadByKitDesign_KittingWorkstation)
ObjectPropertyDomain(:hadByKitDesign_KittingWorkstation :KitDesign)
ObjectPropertyRange(:hadByKitDesign_KittingWorkstation :KittingWorkstation)

Declaration(DataProperty(:hasKittingWorkstation_LengthUnit))
DataPropertyDomain(:hasKittingWorkstation_LengthUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_LengthUnit :lengthUnit)
FunctionalDataProperty(:hasKittingWorkstation_LengthUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_LengthUnit :lengthUnit)
  DataAllValuesFrom (:hasKittingWorkstation_LengthUnit :lengthUnit)))

Declaration(ObjectProperty(:hasKittingWorkstation_Object))
ObjectPropertyDomain(:hasKittingWorkstation_Object :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Object :SolidObject)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Object)

Declaration(ObjectProperty(:hadByObject_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Object
                        :hadByObject_KittingWorkstation)
ObjectPropertyDomain(:hadByObject_KittingWorkstation :SolidObject)
ObjectPropertyRange(:hadByObject_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_OtherObstacle))
ObjectPropertyDomain(:hasKittingWorkstation_OtherObstacle :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_OtherObstacle :BoxVolume)
InverseFunctionalObjectProperty(:hasKittingWorkstation_OtherObstacle)

Declaration(ObjectProperty(:hadByOtherObstacle_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_OtherObstacle
                        :hadByOtherObstacle_KittingWorkstation)
ObjectPropertyDomain(:hadByOtherObstacle_KittingWorkstation :BoxVolume)
ObjectPropertyRange(:hadByOtherObstacle_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_Robot))
ObjectPropertyDomain(:hasKittingWorkstation_Robot :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Robot :Robot)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Robot)
FunctionalObjectProperty(:hasKittingWorkstation_Robot)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKittingWorkstation_Robot :Robot)
  ObjectAllValuesFrom (:hasKittingWorkstation_Robot :Robot)))

Declaration(ObjectProperty(:hadByRobot_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Robot
                        :hadByRobot_KittingWorkstation)
ObjectPropertyDomain(:hadByRobot_KittingWorkstation :Robot)
ObjectPropertyRange(:hadByRobot_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_Sku))
ObjectPropertyDomain(:hasKittingWorkstation_Sku :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Sku :StockKeepingUnit)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Sku)

Declaration(ObjectProperty(:hadBySku_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Sku
                        :hadBySku_KittingWorkstation)
ObjectPropertyDomain(:hadBySku_KittingWorkstation :StockKeepingUnit)
ObjectPropertyRange(:hadBySku_KittingWorkstation :KittingWorkstation)

Declaration(DataProperty(:hasKittingWorkstation_WeightUnit))
DataPropertyDomain(:hasKittingWorkstation_WeightUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_WeightUnit :weightUnit)
FunctionalDataProperty(:hasKittingWorkstation_WeightUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_WeightUnit :weightUnit)
  DataAllValuesFrom (:hasKittingWorkstation_WeightUnit :weightUnit)))



Declaration(Class(:KitTray))

AnnotationAssertion(rdfs:comment :KitTray
  "A KitTrayType is a SolidObjectType. It has Name, PrimaryLocation,
  SecondaryLocation, InternalShape, and ExternalShape elements
  inherited from SolidObjectType. It also has SkuName (the name of
  its SKU) and SerialNumber elements. The shape of the SKU should be
  a BoxyShape. A KitTrayType is designed to hold PartTypes with
  various SKUs in known positions.")


Declaration(ObjectProperty(:hasKitTray_Sku))
ObjectPropertyDomain(:hasKitTray_Sku :KitTray)
ObjectPropertyRange(:hasKitTray_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasKitTray_Sku)
EquivalentClasses(:KitTray ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKitTray_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasKitTray_Sku :StockKeepingUnit)))

Declaration(DataProperty(:hasKitTray_SerialNumber))
DataPropertyDomain(:hasKitTray_SerialNumber :KitTray)
DataPropertyRange(:hasKitTray_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasKitTray_SerialNumber)
EquivalentClasses(:KitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKitTray_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasKitTray_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:LargeBoxWithEmptyKitTrays))

AnnotationAssertion(rdfs:comment :LargeBoxWithEmptyKitTrays
  "A LargeBoxWithEmptyKitTraysType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  LargeContainer and zero to many KitTrays elements. The location
  point of the LargeContainer should be (0,0,0), its Z axis should be
  (0,0,1), and its X axis should be (1,0,0). The PrimaryLocation of a
  KitTray in a LargeBoxWithEmptyKitTrays should be given by a
  PoseLocationIn or RelativeLocationInType that is relative to the
  LargeContainer. The KitTrayTypes in a LargeBoxWithEmptyKitTraysType
  are intended to all be of the same SKU, although there is currently
  no formal requirement for that.")

HasKey(:LargeContainer (:hasLargeContainer_Sku) (:hasLargeContainer_SerialNumber))

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer))
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
EquivalentClasses(:LargeBoxWithEmptyKitTrays ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)
  ObjectAllValuesFrom (:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)))

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays))
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                        :hadByLargeContainer_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTray))
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_KitTray :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_KitTray :KitTray)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTray)

Declaration(ObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays))
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_KitTray
                        :hadByKitTray_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByKitTray_LargeBoxWithEmptyKitTrays :KitTray)
ObjectPropertyRange(:hadByKitTray_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)



Declaration(Class(:LargeBoxWithKits))

AnnotationAssertion(rdfs:comment :LargeBoxWithKits
  "A LargeBoxWithKitsType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  LargeContainer, zero to many Kit, KitDesignName, and Capacity
  elements. The coordinate system of a LargeBoxWithKits is in the
  same place as the coordinate system of its LargeContainer. The
  PrimaryLocation of the LargeContainer should be relative to the
  LargeBoxWithKitsType. The KitDesignName is an identifier for a
  KitDesignType. The PrimaryLocation of a Kit in a LargeBoxWithKits
  should be given by a PoseLocationIn or RelativeLocationInType that
  is relative to the LargeContainer. The Capacity is an
  xs:positiveInteger giving the maximum number of kits of the given
  design that can be held in the box. The KitTypes in a
  LargeBoxWithKitsType are intended to all be of the given design,
  but there is currently no formal constraint requiring that.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_LargeContainer))
ObjectPropertyDomain(:hasLargeBoxWithKits_LargeContainer :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
  ObjectAllValuesFrom (:hasLargeBoxWithKits_LargeContainer :LargeContainer)))

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithKits))
InverseObjectProperties(:hasLargeBoxWithKits_LargeContainer
                        :hadByLargeContainer_LargeBoxWithKits)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithKits :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithKits :LargeBoxWithKits)

Declaration(ObjectProperty(:hasLargeBoxWithKits_Kit))
ObjectPropertyDomain(:hasLargeBoxWithKits_Kit :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_Kit :Kit)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_Kit)

Declaration(ObjectProperty(:hadByKit_LargeBoxWithKits))
InverseObjectProperties(:hasLargeBoxWithKits_Kit
                        :hadByKit_LargeBoxWithKits)
ObjectPropertyDomain(:hadByKit_LargeBoxWithKits :Kit)
ObjectPropertyRange(:hadByKit_LargeBoxWithKits :LargeBoxWithKits)


Declaration(ObjectProperty(:hasLargeBoxWithKits_KitDesign))
ObjectPropertyDomain(:hasLargeBoxWithKits_KitDesign :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_KitDesign :KitDesign)
FunctionalObjectProperty(:hasLargeBoxWithKits_KitDesign)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithKits_KitDesign :KitDesign)
  ObjectAllValuesFrom (:hasLargeBoxWithKits_KitDesign :KitDesign)))

Declaration(DataProperty(:hasLargeBoxWithKits_Capacity))
DataPropertyDomain(:hasLargeBoxWithKits_Capacity :LargeBoxWithKits)
DataPropertyRange(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
FunctionalDataProperty(:hasLargeBoxWithKits_Capacity)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  DataSomeValuesFrom(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
  DataAllValuesFrom (:hasLargeBoxWithKits_Capacity xsd:positiveInteger)))



Declaration(Class(:LargeContainer))

AnnotationAssertion(rdfs:comment :LargeContainer
  "A LargeContainerType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  SkuName and SerialNumber elements. The SkuName is the name of its
  SKU. The shape of the SKU should be a BoxyShape. A
  LargeContainerType can hold one or more instances of a single type
  of tray or bin. The single type may be (1) KitTrayType (2)
  PartsBinType (3) PartsTrayType (4) KitInstanceType.")


Declaration(ObjectProperty(:hasLargeContainer_Sku))
ObjectPropertyDomain(:hasLargeContainer_Sku :LargeContainer)
ObjectPropertyRange(:hasLargeContainer_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasLargeContainer_Sku)
EquivalentClasses(:LargeContainer ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeContainer_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasLargeContainer_Sku :StockKeepingUnit)))

Declaration(DataProperty(:hasLargeContainer_SerialNumber))
DataPropertyDomain(:hasLargeContainer_SerialNumber :LargeContainer)
DataPropertyRange(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasLargeContainer_SerialNumber)
EquivalentClasses(:LargeContainer ObjectIntersectionOf(
  DataSomeValuesFrom(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasLargeContainer_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:MechanicalComponent))

AnnotationAssertion(rdfs:comment :MechanicalComponent
  "A MechanicalComponentType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. A
  MechanicalComponentType is a component of kitting workstation
  device such as a robot or an end effector changing station.")



Declaration(Class(:Part))

AnnotationAssertion(rdfs:comment :Part
  "A PartType is a SolidObjectType. It has Name, PrimaryLocation,
  SecondaryLocation, InternalShape, and ExternalShape elements
  inherited from SolidObjectType. It also has SerialNumber and
  SkuName elements. The SkuName is the name of a StockKeepingUnit.")


Declaration(ObjectProperty(:hasPart_Sku))
ObjectPropertyDomain(:hasPart_Sku :Part)
ObjectPropertyRange(:hasPart_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasPart_Sku)
EquivalentClasses(:Part ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPart_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPart_Sku :StockKeepingUnit)))

Declaration(DataProperty(:hasPart_SerialNumber))
DataPropertyDomain(:hasPart_SerialNumber :Part)
DataPropertyRange(:hasPart_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasPart_SerialNumber)
EquivalentClasses(:Part ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPart_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasPart_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:PartRefAndPose))

AnnotationAssertion(rdfs:comment :PartRefAndPose
  "A PartRefAndPoseType is a DataThingType. It has a Name inherited
  from DataThingType. A PartRefAndPoseType also has SkuName, Point,
  ZAxis, and XAxis elements. The SkuName identifies a type of part.
  The Point specifies the location of the origin of the part in the
  coordinate system of the tray of the KitDesignType to which the
  PartRefAndPoseType belongs. The ZAxis and XAxis specify the
  orientation of the part relative to that coordinate system.")


Declaration(ObjectProperty(:hasPartRefAndPose_Sku))
ObjectPropertyDomain(:hasPartRefAndPose_Sku :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartRefAndPose_Sku)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartRefAndPose_Sku :StockKeepingUnit)))

Declaration(ObjectProperty(:hasPartRefAndPose_Point))
ObjectPropertyDomain(:hasPartRefAndPose_Point :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Point :Point)
InverseFunctionalObjectProperty(:hasPartRefAndPose_Point)
FunctionalObjectProperty(:hasPartRefAndPose_Point)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_Point :Point)
  ObjectAllValuesFrom (:hasPartRefAndPose_Point :Point)))

Declaration(ObjectProperty(:hadByPoint_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_Point
                        :hadByPoint_PartRefAndPose)
ObjectPropertyDomain(:hadByPoint_PartRefAndPose :Point)
ObjectPropertyRange(:hadByPoint_PartRefAndPose :PartRefAndPose)

Declaration(ObjectProperty(:hasPartRefAndPose_XAxis))
ObjectPropertyDomain(:hasPartRefAndPose_XAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_XAxis :Vector)
InverseFunctionalObjectProperty(:hasPartRefAndPose_XAxis)
FunctionalObjectProperty(:hasPartRefAndPose_XAxis)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_XAxis :Vector)
  ObjectAllValuesFrom (:hasPartRefAndPose_XAxis :Vector)))

Declaration(ObjectProperty(:hadByXAxis_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_XAxis
                        :hadByXAxis_PartRefAndPose)
ObjectPropertyDomain(:hadByXAxis_PartRefAndPose :Vector)
ObjectPropertyRange(:hadByXAxis_PartRefAndPose :PartRefAndPose)

Declaration(ObjectProperty(:hasPartRefAndPose_ZAxis))
ObjectPropertyDomain(:hasPartRefAndPose_ZAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_ZAxis :Vector)
InverseFunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
FunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_ZAxis :Vector)
  ObjectAllValuesFrom (:hasPartRefAndPose_ZAxis :Vector)))

Declaration(ObjectProperty(:hadByZAxis_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_ZAxis
                        :hadByZAxis_PartRefAndPose)
ObjectPropertyDomain(:hadByZAxis_PartRefAndPose :Vector)
ObjectPropertyRange(:hadByZAxis_PartRefAndPose :PartRefAndPose)



Declaration(Class(:PartsBin))

AnnotationAssertion(rdfs:comment :PartsBin
  "A PartsBinType is a SolidObjectType. It has Name, PrimaryLocation,
  SecondaryLocation, InternalShape, and ExternalShape elements
  inherited from SolidObjectType. It also has SkuName, SerialNumber,
  PartSkuName and PartQuantity elements. The SkuName is the name of
  the SKU for the PartsBinType. The shape of the SKU identified by
  the SkuName should be a BoxyShape. A PartsBinType holds a number of
  PartTypes (PartQuantity) with the same SKU name (PartSkuName) in
  unknown random positions.")


Declaration(ObjectProperty(:hasPartsBin_Sku))
ObjectPropertyDomain(:hasPartsBin_Sku :PartsBin)
ObjectPropertyRange(:hasPartsBin_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartsBin_Sku)
EquivalentClasses(:PartsBin ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsBin_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartsBin_Sku :StockKeepingUnit)))

Declaration(DataProperty(:hasPartsBin_SerialNumber))
DataPropertyDomain(:hasPartsBin_SerialNumber :PartsBin)
DataPropertyRange(:hasPartsBin_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasPartsBin_SerialNumber)
EquivalentClasses(:PartsBin ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsBin_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasPartsBin_SerialNumber xsd:NMTOKEN)))


Declaration(ObjectProperty(:hasPartsBin_PartSku))
ObjectPropertyDomain(:hasPartsBin_PartSku :PartsBin)
ObjectPropertyRange(:hasPartsBin_PartSku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartsBin_PartSku)
EquivalentClasses(:PartsBin ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsBin_PartSku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartsBin_PartSku :StockKeepingUnit)))

Declaration(DataProperty(:hasPartsBin_PartQuantity))
DataPropertyDomain(:hasPartsBin_PartQuantity :PartsBin)
DataPropertyRange(:hasPartsBin_PartQuantity xsd:nonNegativeInteger)
FunctionalDataProperty(:hasPartsBin_PartQuantity)
EquivalentClasses(:PartsBin ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsBin_PartQuantity xsd:nonNegativeInteger)
  DataAllValuesFrom (:hasPartsBin_PartQuantity xsd:nonNegativeInteger)))



Declaration(Class(:PartsTray))

AnnotationAssertion(rdfs:comment :PartsTray
  "A PartsTrayType is a SolidObjectType used to hold Parts. It has
  Name,o PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  SkuName and SerialNumber elements. The SkuName is the name of the
  SKU of the PartsTrayType, not the name of the SKU of a type of part
  the tray can hold. The shape of the SKU identified by the SkuName
  should be a BoxyShape.A PartsTrayType holds a number of
  PartTypes (PartQuantity) with the same SKU name (PartSkuName) in
  known positions.")


Declaration(ObjectProperty(:hasPartsTray_Sku))
ObjectPropertyDomain(:hasPartsTray_Sku :PartsTray)
ObjectPropertyRange(:hasPartsTray_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartsTray_Sku)
EquivalentClasses(:PartsTray ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsTray_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartsTray_Sku :StockKeepingUnit)))

Declaration(DataProperty(:hasPartsTray_SerialNumber))
DataPropertyDomain(:hasPartsTray_SerialNumber :PartsTray)
DataPropertyRange(:hasPartsTray_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasPartsTray_SerialNumber)
EquivalentClasses(:PartsTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsTray_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasPartsTray_SerialNumber xsd:NMTOKEN)))

Declaration(ObjectProperty(:hasPartsTray_PartSku))
ObjectPropertyDomain(:hasPartsTray_PartSku :PartsTray)
ObjectPropertyRange(:hasPartsTray_PartSku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartsTray_PartSku)
EquivalentClasses(:PartsTray ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsTray_PartSku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartsTray_PartSku :StockKeepingUnit)))

Declaration(DataProperty(:hasPartsTray_PartQuantity))
DataPropertyDomain(:hasPartsTray_PartQuantity :PartsTray)
DataPropertyRange(:hasPartsTray_PartQuantity xsd:nonNegativeInteger)
FunctionalDataProperty(:hasPartsTray_PartQuantity)
EquivalentClasses(:PartsTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsTray_PartQuantity xsd:nonNegativeInteger)
  DataAllValuesFrom (:hasPartsTray_PartQuantity xsd:nonNegativeInteger)))


Declaration(Class(:PartsTrayWithParts))

AnnotationAssertion(rdfs:comment :PartsTrayWithParts
  "A PartsTrayWithPartsType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also has
  a PartsTray and zero to many Part elements. The coordinate system
  of a PartsTrayWithParts is in the same place as the coordinate
  system of its PartsTray. To implement this, the PartsTray should
  have the PartsTrayWithPartsType as the RefObject of its location,
  the location point of the PartsTray should be (0,0,0), its Z axis
  should be (0,0,1), and its X axis should be (1,0,0). The
  PrimaryLocation of a Part in a PartsTrayWithPartsType should be
  given by a PoseLocationInType that is relative to the PartsTray.
  The PartTypes in a PartsTrayWithPartsType are intended to all be of
  the same SKU, although there is currently no formal requirement for
  that.")

HasKey(:PartsTray (:hasPartsTray_Sku) (:hasPartsTray_SerialNumber))

Declaration(ObjectProperty(:hasPartsTrayWithParts_PartsTray))
ObjectPropertyDomain(:hasPartsTrayWithParts_PartsTray :PartsTrayWithParts)
ObjectPropertyRange(:hasPartsTrayWithParts_PartsTray :PartsTray)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_PartsTray)
FunctionalObjectProperty(:hasPartsTrayWithParts_PartsTray)
EquivalentClasses(:PartsTrayWithParts ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsTrayWithParts_PartsTray :PartsTray)
  ObjectAllValuesFrom (:hasPartsTrayWithParts_PartsTray :PartsTray)))

Declaration(ObjectProperty(:hadByPartsTray_PartsTrayWithParts))
InverseObjectProperties(:hasPartsTrayWithParts_PartsTray
                        :hadByPartsTray_PartsTrayWithParts)
ObjectPropertyDomain(:hadByPartsTray_PartsTrayWithParts :PartsTray)
ObjectPropertyRange(:hadByPartsTray_PartsTrayWithParts :PartsTrayWithParts)

Declaration(ObjectProperty(:hasPartsTrayWithParts_Part))
ObjectPropertyDomain(:hasPartsTrayWithParts_Part :PartsTrayWithParts)
ObjectPropertyRange(:hasPartsTrayWithParts_Part :Part)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Part)

Declaration(ObjectProperty(:hadByPart_PartsTrayWithParts))
InverseObjectProperties(:hasPartsTrayWithParts_Part
                        :hadByPart_PartsTrayWithParts)
ObjectPropertyDomain(:hadByPart_PartsTrayWithParts :Part)
ObjectPropertyRange(:hadByPart_PartsTrayWithParts :PartsTrayWithParts)



Declaration(Class(:PhysicalLocation))

AnnotationAssertion(rdfs:comment :PhysicalLocation
  "A PhysicalLocationType is a DataThingType. A PhysicalLocationType
  says where a SolidObjectType is. A PhysicalLocationType has a Name
  inherited from DataThingType. It also has a RefObjectName element that
  is a SolidObjectType and an optional Timestamp element. The
  Timestamp element represents the most recent date and time when
  the location was updated. A PhysicalLocationType is either a
  RelativeLocationType or a PoseLocationType.")
SubClassOf(:PoseLocation :PhysicalLocation)
SubClassOf(:RelativeLocation :PhysicalLocation)
DisjointUnion(:PhysicalLocation
              :PoseLocation
              :RelativeLocation)


Declaration(ObjectProperty(:hasPhysicalLocation_RefObject))
ObjectPropertyDomain(:hasPhysicalLocation_RefObject :PhysicalLocation)
ObjectPropertyRange(:hasPhysicalLocation_RefObject :SolidObject)
FunctionalObjectProperty(:hasPhysicalLocation_RefObject)
EquivalentClasses(:PhysicalLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPhysicalLocation_RefObject :SolidObject)
  ObjectAllValuesFrom (:hasPhysicalLocation_RefObject :SolidObject)))

Declaration(DataProperty(:hasPhysicalLocation_Timestamp))
DataPropertyDomain(:hasPhysicalLocation_Timestamp :PhysicalLocation)
DataPropertyRange(:hasPhysicalLocation_Timestamp xsd:dateTime)
FunctionalDataProperty(:hasPhysicalLocation_Timestamp)



Declaration(Class(:Point))

AnnotationAssertion(rdfs:comment :Point
  "A PointType is a DataThingType. A PointType has a Name element
  inherited from DataThingType. A PointType also has X, Y, and Z
  elements that are the Cartesian coordinates of the Point.")

Declaration(DataProperty(:hasPoint_X))
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyRange(:hasPoint_X xsd:decimal)
FunctionalDataProperty(:hasPoint_X)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_X xsd:decimal)
  DataAllValuesFrom (:hasPoint_X xsd:decimal)))

Declaration(DataProperty(:hasPoint_Y))
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyRange(:hasPoint_Y xsd:decimal)
FunctionalDataProperty(:hasPoint_Y)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Y xsd:decimal)
  DataAllValuesFrom (:hasPoint_Y xsd:decimal)))

Declaration(DataProperty(:hasPoint_Z))
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyRange(:hasPoint_Z xsd:decimal)
FunctionalDataProperty(:hasPoint_Z)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Z xsd:decimal)
  DataAllValuesFrom (:hasPoint_Z xsd:decimal)))



Declaration(Class(:PoseLocation))

AnnotationAssertion(rdfs:comment :PoseLocation
  "A PoseLocationType is a PhysicalLocationType. A PoseLocationType
  has Name and RefObjectName elements inherited from
  PhysicalLocationType. A PoseLocationType also also has:
  - a Point element of PointType
  - an XAxis element of VectorType
  - a ZAxis element of VectorType
  - an optional PositionStandardDeviation element measured
  in the length units being used
  - an optional OrientationStandardDeviation element measured
  in the angle units being used
  The Point locates the origin of a coordinate system. The XAxis
  and ZAxis give the orientation of the coordinate system. The data
  for the Point, the ZAxis and the XAxis are expressed relative to
  the coordinate system of the reference object. A PoseLocationType
  must be a PoseOnlyLocationType, a PoseLocationInType, or a
  PoseLocationOnType.")
AnnotationAssertion(rdfs:comment :PoseLocation
  "The PositionStandardDeviation is based on a normal distribution of
  actual position about its given value. Thus, for example, the
  actual position is expected to be within the given
  PositionStandardDeviation amount 68% of the time and within twice
  the given amount 95% of the time.")
AnnotationAssertion(rdfs:comment :PoseLocation
  "The OrientationStandardDeviation is based on a normal distribution
  of orientation about its given value. The error is to be measured
  as the angle of rotation about a single axis needed to rotate a
  solid object from its stated orientation to its actual orientation.")
SubClassOf(:PoseLocationIn :PoseLocation)
SubClassOf(:PoseLocationOn :PoseLocation)
SubClassOf(:PoseOnlyLocation :PoseLocation)
DisjointUnion(:PoseLocation
              :PoseLocationIn
              :PoseLocationOn
              :PoseOnlyLocation)

Declaration(ObjectProperty(:hasPoseLocation_Point))
ObjectPropertyDomain(:hasPoseLocation_Point :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_Point :Point)
InverseFunctionalObjectProperty(:hasPoseLocation_Point)
FunctionalObjectProperty(:hasPoseLocation_Point)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_Point :Point)
  ObjectAllValuesFrom (:hasPoseLocation_Point :Point)))

Declaration(ObjectProperty(:hadByPoint_PoseLocation))
InverseObjectProperties(:hasPoseLocation_Point
                        :hadByPoint_PoseLocation)
ObjectPropertyDomain(:hadByPoint_PoseLocation :Point)
ObjectPropertyRange(:hadByPoint_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_XAxis))
ObjectPropertyDomain(:hasPoseLocation_XAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_XAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_XAxis)
FunctionalObjectProperty(:hasPoseLocation_XAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_XAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_XAxis :Vector)))

Declaration(ObjectProperty(:hadByXAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_XAxis
                        :hadByXAxis_PoseLocation)
ObjectPropertyDomain(:hadByXAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByXAxis_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_ZAxis))
ObjectPropertyDomain(:hasPoseLocation_ZAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_ZAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_ZAxis)
FunctionalObjectProperty(:hasPoseLocation_ZAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_ZAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_ZAxis :Vector)))

Declaration(ObjectProperty(:hadByZAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_ZAxis
                        :hadByZAxis_PoseLocation)
ObjectPropertyDomain(:hadByZAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByZAxis_PoseLocation :PoseLocation)

Declaration(DataProperty(:hasPoseLocation_PositionStandardDeviation))
DataPropertyDomain(:hasPoseLocation_PositionStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_PositionStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_PositionStandardDeviation)

Declaration(DataProperty(:hasPoseLocation_OrientationStandardDeviation))
DataPropertyDomain(:hasPoseLocation_OrientationStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_OrientationStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_OrientationStandardDeviation)



Declaration(Class(:PoseLocationIn))

AnnotationAssertion(rdfs:comment :PoseLocationIn
  "A PoseLocationInType is a PoseLocationType. It has Point, ZAxis (a
  Vector for the Z axis), XAxis (a Vector for the X axis) and
  RefObjectName (a reference object) elements inherited from
  PoseLocationType. The data for the Point, the ZAxis and the XAxis
  are expressed relative to the coordinate system of the reference
  object. A PoseLocationInType indicates that the Object is inside
  the location-parent. The notion of 'inside' is vague and might be
  made more precise.")



Declaration(Class(:PoseLocationOn))

AnnotationAssertion(rdfs:comment :PoseLocationOn
  "A PoseLocationOnType is a PoseLocationType. It has Point, ZAxis (a
  Vector for the Z axis), XAxis (a Vector for the X axis) and
  RefObjectName (a reference object) elements inherited from
  PoseLocationType. The data for the Point, the ZAxis and the XAxis
  are expressed relative to the coordinate system of the reference
  object. A PoseLocationOnType indicates that the Object is on top of
  the location-parent. The notion of 'on top of' is vague and might
  be made more precise.")



Declaration(Class(:PoseOnlyLocation))

AnnotationAssertion(rdfs:comment :PoseOnlyLocation
  "A PoseOnlyLocationType is a PoseLocationType. It has Point, ZAxis
  (a Vector for the Z axis), XAxis (a Vector for the X axis) and
  RefObjectName (a reference object) elements inherited from
  PoseLocationType. The data for the Point, the ZAxis and the XAxis
  are expressed relative to the coordinate system of the reference
  object. An object located by a PoseOnlyLocationType may or may not
  be inside or on top of the reference object of the
  PoseOnlyLocationType.")



Declaration(Class(:RelativeLocation))

AnnotationAssertion(rdfs:comment :RelativeLocation
  "A RelativeLocationType is a PhysicalLocationType. It has a
  RefObjectName element inherited from PhysicalLocationType that
  identifies a reference object. It also has a Description element
  that is a string. A RelativeLocationType indicates that the
  SolidObjectType that has the RelativeLocationType is on or in the
  object identified by the RefObjectName. A RelativeLocationType is a
  RelativeLocationInType or a RelativeLocationOnType.")
SubClassOf(:RelativeLocationIn :RelativeLocation)
SubClassOf(:RelativeLocationOn :RelativeLocation)
DisjointUnion(:RelativeLocation
              :RelativeLocationIn
              :RelativeLocationOn)

Declaration(DataProperty(:hasRelativeLocation_Description))
DataPropertyDomain(:hasRelativeLocation_Description :RelativeLocation)
DataPropertyRange(:hasRelativeLocation_Description xsd:string)
FunctionalDataProperty(:hasRelativeLocation_Description)
EquivalentClasses(:RelativeLocation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRelativeLocation_Description xsd:string)
  DataAllValuesFrom (:hasRelativeLocation_Description xsd:string)))



Declaration(Class(:RelativeLocationIn))

AnnotationAssertion(rdfs:comment :RelativeLocationIn
  "A RelativeLocationInType is a RelativeLocationType. It has
  reference object (RefObjectName) and description (Description)
  elements inherited from RelativeLocationType. A
  RelativeLocationInType indicates that the SolidObjectType that has
  the RelativeLocationType is in the object identified by the
  RefObjectName. The notion of 'in' is vague and might be made more
  precise.")



Declaration(Class(:RelativeLocationOn))

AnnotationAssertion(rdfs:comment :RelativeLocationOn
  "A RelativeLocationOnType is a RelativeLocationType. It has
  RefObjectName and Description elements inherited from
  RelativeLocationType. A RelativeLocationOnType indicates that the
  SolidObjectType that has the RelativeLocationType is on top of the
  object identified by the RefObjectName. The notion of 'on top of'
  is vague and might be made more precise.")



Declaration(Class(:Robot))

AnnotationAssertion(rdfs:comment :Robot
  "A RobotType is a SolidObjectType. It has Name, PrimaryLocation,
  SecondaryLocation, InternalShape, and ExternalShape elements
  inherited from SolidObjectType. It also has Description,
  EndEffector, MaximumLoadWeight, and WorkVolume elements.")
AnnotationAssertion(rdfs:comment :Robot
  "The Robot ontology given here might be expanded greatly to include,
  for example, its kinematic description, the values of joint angles,
  arm lengths of variable length arms, gripper actuation (open,
  closed, etc.), ranges, velocities, and accelerations of each joint,
  etc.")

Declaration(DataProperty(:hasRobot_Description))
DataPropertyDomain(:hasRobot_Description :Robot)
DataPropertyRange(:hasRobot_Description xsd:string)
FunctionalDataProperty(:hasRobot_Description)
EquivalentClasses(:Robot ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRobot_Description xsd:string)
  DataAllValuesFrom (:hasRobot_Description xsd:string)))

Declaration(ObjectProperty(:hasRobot_EndEffector))
ObjectPropertyDomain(:hasRobot_EndEffector :Robot)
ObjectPropertyRange(:hasRobot_EndEffector :EndEffector)
InverseFunctionalObjectProperty(:hasRobot_EndEffector)
FunctionalObjectProperty(:hasRobot_EndEffector)

Declaration(ObjectProperty(:hadByEndEffector_Robot))
InverseObjectProperties(:hasRobot_EndEffector
                        :hadByEndEffector_Robot)
ObjectPropertyDomain(:hadByEndEffector_Robot :EndEffector)
ObjectPropertyRange(:hadByEndEffector_Robot :Robot)

Declaration(DataProperty(:hasRobot_MaximumLoadWeight))
DataPropertyDomain(:hasRobot_MaximumLoadWeight :Robot)
DataPropertyRange(:hasRobot_MaximumLoadWeight :positiveDecimal)
FunctionalDataProperty(:hasRobot_MaximumLoadWeight)
EquivalentClasses(:Robot ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRobot_MaximumLoadWeight :positiveDecimal)
  DataAllValuesFrom (:hasRobot_MaximumLoadWeight :positiveDecimal)))

Declaration(ObjectProperty(:hasRobot_WorkVolume))
ObjectPropertyDomain(:hasRobot_WorkVolume :Robot)
ObjectPropertyRange(:hasRobot_WorkVolume :BoxVolume)
InverseFunctionalObjectProperty(:hasRobot_WorkVolume)

Declaration(ObjectProperty(:hadByWorkVolume_Robot))
InverseObjectProperties(:hasRobot_WorkVolume
                        :hadByWorkVolume_Robot)
ObjectPropertyDomain(:hadByWorkVolume_Robot :BoxVolume)
ObjectPropertyRange(:hadByWorkVolume_Robot :Robot)



Declaration(Class(:ShapeDesign))

AnnotationAssertion(rdfs:comment :ShapeDesign
  "A ShapeDesignType is an abstract type that is a DataThingType. A
  ShapeDesignType has a Name element inherited from DataThingType. It
  also has a Description element that is a string and an optional
  GraspPose element that is a PoseLocationType. Each ShapeDesignType
  has a coordinate system that is expected to be specified explicitly
  or implicitly. A shape defined using coordinate values has an
  implicit coordinate system. The GraspPose is relative to the
  coordinate system of the ShapeDesignType. The Point in the pose is
  the point at which a gripper should make contact with the shape.
  The ZAxis of the pose may be used to indicate a direction for
  aligning the ZAxis of the gripper (parallel or antiparallel) and is
  usually normal to the the object having the shape and pointing away
  from the object.")
SubClassOf(:ExternalShape :ShapeDesign)
SubClassOf(:InternalShape :ShapeDesign)
DisjointUnion(:ShapeDesign
              :ExternalShape
              :InternalShape)

Declaration(DataProperty(:hasShapeDesign_Description))
DataPropertyDomain(:hasShapeDesign_Description :ShapeDesign)
DataPropertyRange(:hasShapeDesign_Description xsd:string)
FunctionalDataProperty(:hasShapeDesign_Description)
EquivalentClasses(:ShapeDesign ObjectIntersectionOf(
  DataSomeValuesFrom(:hasShapeDesign_Description xsd:string)
  DataAllValuesFrom (:hasShapeDesign_Description xsd:string)))

Declaration(ObjectProperty(:hasShapeDesign_GraspPose))
ObjectPropertyDomain(:hasShapeDesign_GraspPose :ShapeDesign)
ObjectPropertyRange(:hasShapeDesign_GraspPose :PoseLocation)
InverseFunctionalObjectProperty(:hasShapeDesign_GraspPose)
FunctionalObjectProperty(:hasShapeDesign_GraspPose)

Declaration(ObjectProperty(:hadByGraspPose_ShapeDesign))
InverseObjectProperties(:hasShapeDesign_GraspPose
                        :hadByGraspPose_ShapeDesign)
ObjectPropertyDomain(:hadByGraspPose_ShapeDesign :PoseLocation)
ObjectPropertyRange(:hadByGraspPose_ShapeDesign :ShapeDesign)



Declaration(Class(:Slot))

AnnotationAssertion(rdfs:comment :Slot
  "A SlotType is a DataThingType that identifies whether or not a
  particular PartRefAndPose from the design of a Kit is occupied in
  an instance of a Kit. A SlotType has a Name element inherited from
  DataThingType. It also has a PartRefAndPoseName that identifies a
  PartRefAndPose and an optional PartName that identifies a Part that
  occupies the PartRefAndPose. The Sku of the PartRefAndPose should
  be the Sku of the Part, the PartRefAndPose should be in the Kit
  design, and the Part should be in the Kit. The location described
  by the Pose of the Part in the Kit may differ from the location
  described by the Pose in the PartRefAndPose, but will usually be
  very close to it. If the PartName is not used for a slot, that
  means the slot is empty.")


Declaration(ObjectProperty(:hasSlot_PartRefAndPose))
ObjectPropertyDomain(:hasSlot_PartRefAndPose :Slot)
ObjectPropertyRange(:hasSlot_PartRefAndPose :PartRefAndPose)
FunctionalObjectProperty(:hasSlot_PartRefAndPose)
EquivalentClasses(:Slot ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasSlot_PartRefAndPose :PartRefAndPose)
  ObjectAllValuesFrom (:hasSlot_PartRefAndPose :PartRefAndPose)))


Declaration(ObjectProperty(:hasSlot_Part))
ObjectPropertyDomain(:hasSlot_Part :Slot)
ObjectPropertyRange(:hasSlot_Part :Part)
FunctionalObjectProperty(:hasSlot_Part)



Declaration(Class(:SolidObject))

AnnotationAssertion(rdfs:comment :SolidObject
  "A SolidObjectType has (1) a Name, (2) a PrimaryLocation that is a
  PhysicalLocationType, (3) zero to many SecondaryLocations, also
  PhysicalLocationType, (4) an optional InternalShape, and (5) an
  optional ExternalShape. The secondary locations are required to be
  logically and mathematically consistent with the value of the
  PrimaryLocation so that all locations of a SolidObjectType describe
  (or are consistent with) a single place in space. Names are of type
  xs:ID so that all names must be unique. No SolidObjectType except
  the Workstation may be located with respect to itself, and all
  chains of primary location must end at the Workstation. The shapes
  are not required to represent the same shape, but they should not
  be inconsistent. If a solid object consists of components it may
  also get its shape from the shape of the components and their
  relative positions.")
SubClassOf(:EndEffectorChangingStation :SolidObject)
SubClassOf(:EndEffectorHolder :SolidObject)
SubClassOf(:EndEffector :SolidObject)
SubClassOf(:Human :SolidObject)
SubClassOf(:KitTray :SolidObject)
SubClassOf(:Kit :SolidObject)
SubClassOf(:KittingWorkstation :SolidObject)
SubClassOf(:LargeBoxWithEmptyKitTrays :SolidObject)
SubClassOf(:LargeBoxWithKits :SolidObject)
SubClassOf(:LargeContainer :SolidObject)
SubClassOf(:MechanicalComponent :SolidObject)
SubClassOf(:Part :SolidObject)
SubClassOf(:PartsBin :SolidObject)
SubClassOf(:PartsTray :SolidObject)
SubClassOf(:PartsTrayWithParts :SolidObject)
SubClassOf(:Robot :SolidObject)
SubClassOf(:WorkTable :SolidObject)
DisjointUnion(:SolidObject
              :EndEffectorChangingStation
              :EndEffectorHolder
              :EndEffector
              :Human
              :KitTray
              :Kit
              :KittingWorkstation
              :LargeBoxWithEmptyKitTrays
              :LargeBoxWithKits
              :LargeContainer
              :MechanicalComponent
              :Part
              :PartsBin
              :PartsTray
              :PartsTrayWithParts
              :Robot
              :WorkTable)

Declaration(ObjectProperty(:hasSolidObject_PrimaryLocation))
ObjectPropertyDomain(:hasSolidObject_PrimaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_PrimaryLocation :PhysicalLocation)
InverseFunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
FunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
EquivalentClasses(:SolidObject ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasSolidObject_PrimaryLocation :PhysicalLocation)
  ObjectAllValuesFrom (:hasSolidObject_PrimaryLocation :PhysicalLocation)))

Declaration(ObjectProperty(:hadByPrimaryLocation_SolidObject))
InverseObjectProperties(:hasSolidObject_PrimaryLocation
                        :hadByPrimaryLocation_SolidObject)
ObjectPropertyDomain(:hadByPrimaryLocation_SolidObject :PhysicalLocation)
ObjectPropertyRange(:hadByPrimaryLocation_SolidObject :SolidObject)

Declaration(ObjectProperty(:hasSolidObject_SecondaryLocation))
ObjectPropertyDomain(:hasSolidObject_SecondaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_SecondaryLocation :PhysicalLocation)
InverseFunctionalObjectProperty(:hasSolidObject_SecondaryLocation)

Declaration(ObjectProperty(:hadBySecondaryLocation_SolidObject))
InverseObjectProperties(:hasSolidObject_SecondaryLocation
                        :hadBySecondaryLocation_SolidObject)
ObjectPropertyDomain(:hadBySecondaryLocation_SolidObject :PhysicalLocation)
ObjectPropertyRange(:hadBySecondaryLocation_SolidObject :SolidObject)

Declaration(ObjectProperty(:hasSolidObject_InternalShape))
ObjectPropertyDomain(:hasSolidObject_InternalShape :SolidObject)
ObjectPropertyRange(:hasSolidObject_InternalShape :InternalShape)
InverseFunctionalObjectProperty(:hasSolidObject_InternalShape)
FunctionalObjectProperty(:hasSolidObject_InternalShape)

Declaration(ObjectProperty(:hadByInternalShape_SolidObject))
InverseObjectProperties(:hasSolidObject_InternalShape
                        :hadByInternalShape_SolidObject)
ObjectPropertyDomain(:hadByInternalShape_SolidObject :InternalShape)
ObjectPropertyRange(:hadByInternalShape_SolidObject :SolidObject)

Declaration(ObjectProperty(:hasSolidObject_ExternalShape))
ObjectPropertyDomain(:hasSolidObject_ExternalShape :SolidObject)
ObjectPropertyRange(:hasSolidObject_ExternalShape :ExternalShape)
InverseFunctionalObjectProperty(:hasSolidObject_ExternalShape)
FunctionalObjectProperty(:hasSolidObject_ExternalShape)

Declaration(ObjectProperty(:hadByExternalShape_SolidObject))
InverseObjectProperties(:hasSolidObject_ExternalShape
                        :hadByExternalShape_SolidObject)
ObjectPropertyDomain(:hadByExternalShape_SolidObject :ExternalShape)
ObjectPropertyRange(:hadByExternalShape_SolidObject :SolidObject)



Declaration(Class(:StockKeepingUnit))

AnnotationAssertion(rdfs:comment :StockKeepingUnit
  "A StockKeepingUnitType is a DataThingType. A StockKeepingUnitType
  is a description of a type of object. A StockKeepinUnitType has a
  Name element inherited from DataThingType. A StockKeepingUnitType
  also has Description, Shape (a ShapeDesignType), and Weight
  elements, and zero to many EndEffectorName elements (the names of
  one or more instances of EndEffectorType that can handle it).")

Declaration(DataProperty(:hasStockKeepingUnit_Description))
DataPropertyDomain(:hasStockKeepingUnit_Description :StockKeepingUnit)
DataPropertyRange(:hasStockKeepingUnit_Description xsd:string)
FunctionalDataProperty(:hasStockKeepingUnit_Description)
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasStockKeepingUnit_Description xsd:string)
  DataAllValuesFrom (:hasStockKeepingUnit_Description xsd:string)))

Declaration(ObjectProperty(:hasStockKeepingUnit_Shape))
ObjectPropertyDomain(:hasStockKeepingUnit_Shape :StockKeepingUnit)
ObjectPropertyRange(:hasStockKeepingUnit_Shape :ShapeDesign)
InverseFunctionalObjectProperty(:hasStockKeepingUnit_Shape)
FunctionalObjectProperty(:hasStockKeepingUnit_Shape)
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasStockKeepingUnit_Shape :ShapeDesign)
  ObjectAllValuesFrom (:hasStockKeepingUnit_Shape :ShapeDesign)))

Declaration(ObjectProperty(:hadByShape_StockKeepingUnit))
InverseObjectProperties(:hasStockKeepingUnit_Shape
                        :hadByShape_StockKeepingUnit)
ObjectPropertyDomain(:hadByShape_StockKeepingUnit :ShapeDesign)
ObjectPropertyRange(:hadByShape_StockKeepingUnit :StockKeepingUnit)

Declaration(DataProperty(:hasStockKeepingUnit_Weight))
DataPropertyDomain(:hasStockKeepingUnit_Weight :StockKeepingUnit)
DataPropertyRange(:hasStockKeepingUnit_Weight :positiveDecimal)
FunctionalDataProperty(:hasStockKeepingUnit_Weight)
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasStockKeepingUnit_Weight :positiveDecimal)
  DataAllValuesFrom (:hasStockKeepingUnit_Weight :positiveDecimal)))


Declaration(ObjectProperty(:hasStockKeepingUnit_EndEffector))
ObjectPropertyDomain(:hasStockKeepingUnit_EndEffector :StockKeepingUnit)
ObjectPropertyRange(:hasStockKeepingUnit_EndEffector :EndEffector)



Declaration(Class(:VacuumEffector))

AnnotationAssertion(rdfs:comment :VacuumEffector
  "A VacuumEffectorType is an EndEffectorType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, ExternalShape,
  Description, Weight, and MaximumLoadWeight elements inherited from
  EndEffectorType. It also has CupDiameter and Length elements. A
  VacuumEffectorType holds an object by putting a cup against the
  object and applying a vacuum. A VacuumEffectorType is either a
  VacuumEffectorSingleCupType or a VacuumEffectorMultiCupType.")
SubClassOf(:VacuumEffectorMultiCup :VacuumEffector)
SubClassOf(:VacuumEffectorSingleCup :VacuumEffector)
DisjointUnion(:VacuumEffector
              :VacuumEffectorMultiCup
              :VacuumEffectorSingleCup)

Declaration(DataProperty(:hasVacuumEffector_CupDiameter))
DataPropertyDomain(:hasVacuumEffector_CupDiameter :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_CupDiameter :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffector_CupDiameter)
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffector_CupDiameter :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffector_CupDiameter :positiveDecimal)))

Declaration(DataProperty(:hasVacuumEffector_Length))
DataPropertyDomain(:hasVacuumEffector_Length :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_Length :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffector_Length)
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffector_Length :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffector_Length :positiveDecimal)))



Declaration(Class(:VacuumEffectorMultiCup))

AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "A VacuumEffectorMultiCupType is a VacuumEffectorType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, ExternalShape,
  Description, Weight, MaximumLoadWeight, CupDiameter, and Length
  elements inherited from VacuumEffectorType. A
  VacuumEffectorMultiCup also has ArrayNumber (number of cups -- at
  least 2) and ArrayRadius elements. The cups are arranged in a
  circular array spaced evenly apart. The center of the wide end of
  one cup is on the X-axis of the coordinate system of the
  VacuumEffectorMultiCupType. The center of the circular array is at
  the origin of the coordinate system. The axis of the array circle
  is the Z axis of the coordinate system, and the length of the
  VacuumEffectorType is measured along that axis. The wide ends of
  the cups lie on the XY plane of the coordinate system.")
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "Note that a square array can be represented easily as circular array.")

Declaration(DataProperty(:hasVacuumEffectorMultiCup_ArrayNumber))
DataPropertyDomain(:hasVacuumEffectorMultiCup_ArrayNumber :VacuumEffectorMultiCup)
DataPropertyRange(:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)
FunctionalDataProperty(:hasVacuumEffectorMultiCup_ArrayNumber)
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)
  DataAllValuesFrom (:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)))

Declaration(DataProperty(:hasVacuumEffectorMultiCup_ArrayRadius))
DataPropertyDomain(:hasVacuumEffectorMultiCup_ArrayRadius :VacuumEffectorMultiCup)
DataPropertyRange(:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffectorMultiCup_ArrayRadius)
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)))



Declaration(Class(:VacuumEffectorSingleCup))

AnnotationAssertion(rdfs:comment :VacuumEffectorSingleCup
  "A VacuumEffectorSingleCupType is a VacuumEffectorType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, ExternalShape,
  Description, Weight, MaximumLoadWeight, CupDiameter, and Length
  elements inherited from VacuumEffectorType. A
  VacuumEffectorSingleCupType has one cup. The center of the wide end
  of the cup (which is a circle) is at the origin of the coordinate
  system of the VacuumEffectorSingleCupType. The Z axis of the
  coordinate system is the axis of that circle, and the length of the
  VacuumEffectorType is measured along that axis.")



Declaration(Class(:Vector))

AnnotationAssertion(rdfs:comment :Vector
  "A VectorType is a DataThingType. A Vector has a Name element
  inherited from DataThingType. It also has I, J, and K elements
  which represent the usual I, J, and K components of a 3D vector.")

Declaration(DataProperty(:hasVector_I))
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyRange(:hasVector_I xsd:decimal)
FunctionalDataProperty(:hasVector_I)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_I xsd:decimal)
  DataAllValuesFrom (:hasVector_I xsd:decimal)))

Declaration(DataProperty(:hasVector_J))
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyRange(:hasVector_J xsd:decimal)
FunctionalDataProperty(:hasVector_J)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_J xsd:decimal)
  DataAllValuesFrom (:hasVector_J xsd:decimal)))

Declaration(DataProperty(:hasVector_K))
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyRange(:hasVector_K xsd:decimal)
FunctionalDataProperty(:hasVector_K)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_K xsd:decimal)
  DataAllValuesFrom (:hasVector_K xsd:decimal)))



Declaration(Class(:WorkTable))

AnnotationAssertion(rdfs:comment :WorkTable
  "A WorkTableType is a SolidObjectType. It has Name,
  PrimaryLocation, SecondaryLocation, InternalShape, and
  ExternalShape elements inherited from SolidObjectType. It also
  has zero to many SolidObject elements, which are SolidObjectTypes
  located with respect to the WorkTableType. The reference object of
  each SolidObject element should be the WorkTable. Typically, those
  objects will be on top of the WorkTable. Typically, the shape of a
  WorkTableType will be a BoxyShape, so that the table has Length,
  Width, and Height.")

Declaration(ObjectProperty(:hasWorkTable_SolidObject))
ObjectPropertyDomain(:hasWorkTable_SolidObject :WorkTable)
ObjectPropertyRange(:hasWorkTable_SolidObject :SolidObject)
InverseFunctionalObjectProperty(:hasWorkTable_SolidObject)

Declaration(ObjectProperty(:hadBySolidObject_WorkTable))
InverseObjectProperties(:hasWorkTable_SolidObject
                        :hadBySolidObject_WorkTable)
ObjectPropertyDomain(:hadBySolidObject_WorkTable :SolidObject)
ObjectPropertyRange(:hadBySolidObject_WorkTable :WorkTable)

DisjointClasses(:DataThing
                :SolidObject)
)
