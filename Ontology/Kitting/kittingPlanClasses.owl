Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingPlanClasses.owl#>)

Ontology(<http://www.nist.gov/el/ontologies/kittingPlanClasses.owl>

Annotation(rdfs:comment
  "This kitting plan ontology models a plan for actions in a kitting
      workstation. It is expected that most plans conforming to the 
      model will be plans for building kits.
      This ontology uses the following items from the kitting workstation
      ontology:
      DataThing
      PhysicalLocation (and its derived subtypes)
      Point
      PositiveDecimal
      Vector
      Those definitions are included at the end of this file.
 
      The model includes:
      - a tree-like plan structure of arbitrary length and depth
      - a variety of methods of ordering the steps of the tree
      - arithmetic variables
      - boolean expressions
      - arithmetic expressions
      - actions specific to kitting
      - a 'while' loop
      - an If-ElseIf-Else structure
 
      The appinfo entries in the model are solely for the benefit of the
      xmlSchemaOwlPrinter, which needs to know the type of the named
      objects.")



DatatypeDefinition(:positiveDecimal 
  DatatypeRestriction(xsd:decimal xsd:minExclusive "0"^^xsd:decimal))



Declaration(Class(:ActionBase))

AnnotationAssertion(rdfs:comment :ActionBase
  "ActionBase is derived from PlanElementBase.
  An instance of ActionBase has the following:
    .
 
  ActionBase is the abstract base type that defines a single
  action to be carried out.")

SubClassOf(:CreateKit :ActionBase)
SubClassOf(:RobotActionBase :ActionBase)
SubClassOf(:SensorActionBase :ActionBase)
DisjointUnion(:ActionBase
              :CreateKit
              :RobotActionBase
              :SensorActionBase)



Declaration(Class(:ActionGroupBase))

AnnotationAssertion(rdfs:comment :ActionGroupBase
  "ActionGroupBase is derived from PlanElementBase.
  An instance of ActionGroupBase has the following:
    .
 
  ActionGroupBase is the abstract base type that defines an
  action group. An action group consists of a control structure
  and the plan elements to which the control structure applies.")

SubClassOf(:IfActionGroup :ActionGroupBase)
SubClassOf(:OneOfActionGroup :ActionGroupBase)
SubClassOf(:OrderedActionGroup :ActionGroupBase)
SubClassOf(:PartiallyOrderedActionGroup :ActionGroupBase)
SubClassOf(:SomeOfActionGroup :ActionGroupBase)
SubClassOf(:UnorderedActionGroup :ActionGroupBase)
SubClassOf(:WhileActionGroup :ActionGroupBase)
DisjointUnion(:ActionGroupBase
              :IfActionGroup
              :OneOfActionGroup
              :OrderedActionGroup
              :PartiallyOrderedActionGroup
              :SomeOfActionGroup
              :UnorderedActionGroup
              :WhileActionGroup)



Declaration(Class(:AttachEndEffector))

AnnotationAssertion(rdfs:comment :AttachEndEffector
  "AttachEndEffector is derived from RobotActionBase.
  An instance of AttachEndEffector has the following:
    RobotName
    EndEffectorName
    EndEffectorHolderName.
 
  Immediately before an instance of AttachEndEffector is executed:
  (1) The named robot must not have an end effector in its tool changer.
  (2) The end effector must be located relative to the named
      end effector holder.
 
  As an instance of AttachEndEffector is executed:
  If the tool changer is closed, the robot opens the tool changer.
  The robot moves to a position relative to the tool holder at
  which it can attach to the end effector. The robot closes the
  tool changer so as to attach the end effector. The location of
  the end effector changes from being relative to the end effector
  holder to being relative to the robot. The robot withdraws the end
  end effector from the tool holder a slight amount that is far
  enough so that any end effector sensor on the end effector holder no
  longer indicates that there is an end effector in the holder.")

Declaration(DataProperty(:hasAttachEndEffector_RobotName))
DataPropertyDomain(:hasAttachEndEffector_RobotName :AttachEndEffector)
DataPropertyRange(:hasAttachEndEffector_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasAttachEndEffector_RobotName)
EquivalentClasses(:AttachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasAttachEndEffector_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasAttachEndEffector_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasAttachEndEffector_EndEffectorName))
DataPropertyDomain(:hasAttachEndEffector_EndEffectorName :AttachEndEffector)
DataPropertyRange(:hasAttachEndEffector_EndEffectorName xsd:NMTOKEN)
FunctionalDataProperty(:hasAttachEndEffector_EndEffectorName)
EquivalentClasses(:AttachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasAttachEndEffector_EndEffectorName xsd:NMTOKEN)
  DataAllValuesFrom (:hasAttachEndEffector_EndEffectorName xsd:NMTOKEN)))

Declaration(DataProperty(:hasAttachEndEffector_EndEffectorHolderName))
DataPropertyDomain(:hasAttachEndEffector_EndEffectorHolderName :AttachEndEffector)
DataPropertyRange(:hasAttachEndEffector_EndEffectorHolderName xsd:NMTOKEN)
FunctionalDataProperty(:hasAttachEndEffector_EndEffectorHolderName)
EquivalentClasses(:AttachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasAttachEndEffector_EndEffectorHolderName xsd:NMTOKEN)
  DataAllValuesFrom (:hasAttachEndEffector_EndEffectorHolderName xsd:NMTOKEN)))



Declaration(Class(:CreateKit))

AnnotationAssertion(rdfs:comment :CreateKit
  "CreateKit is derived from ActionBase.
  An instance of CreateKit has the following:
    KitTrayName
    KitName.
 
  Immediately before an instance of CreateKit is executed:
  (1) The named kit tray must not be in a kit.
  (2) A kit with the given name must not exist.
 
  As an instance of CreateKit is executed:
  A kit with the given name is created at the location of the kit
  tray, and the location of the kit tray becomes relative to the kit,
  in the same place relative to the kitting workstation as before.
  The location of any parts in the kit tray becomes relative to the
  kit.")

Declaration(DataProperty(:hasCreateKit_KitTrayName))
DataPropertyDomain(:hasCreateKit_KitTrayName :CreateKit)
DataPropertyRange(:hasCreateKit_KitTrayName xsd:NMTOKEN)
FunctionalDataProperty(:hasCreateKit_KitTrayName)
EquivalentClasses(:CreateKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCreateKit_KitTrayName xsd:NMTOKEN)
  DataAllValuesFrom (:hasCreateKit_KitTrayName xsd:NMTOKEN)))

Declaration(DataProperty(:hasCreateKit_KitName))
DataPropertyDomain(:hasCreateKit_KitName :CreateKit)
DataPropertyRange(:hasCreateKit_KitName xsd:NMTOKEN)
FunctionalDataProperty(:hasCreateKit_KitName)
EquivalentClasses(:CreateKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCreateKit_KitName xsd:NMTOKEN)
  DataAllValuesFrom (:hasCreateKit_KitName xsd:NMTOKEN)))



Declaration(Class(:DetachEndEffector))

AnnotationAssertion(rdfs:comment :DetachEndEffector
  "DetachEndEffector is derived from RobotActionBase.
  An instance of DetachEndEffector has the following:
    RobotName
    EndEffectorName
    EndEffectorHolderName.
 
  Immediately before an instance of DetachEndEffector is executed:
  (1) The named robot must have the named end effector in its tool
      changer.
  (2) The end effector must be located relative to the robot.
  (3) The end effector holder must be empty.
 
  As an instance of DetachEndEffector is executed:
  The robot moves to a position relative to the tool holder at which
  it can detach from the end effector. The robot opens the tool
  changer so as to detach the end effector. The location of the end
  effector changes from being relative to the robot to being relative
  to the end effector holder. The robot moves a small distance away
  from the end effector holder.")

Declaration(DataProperty(:hasDetachEndEffector_RobotName))
DataPropertyDomain(:hasDetachEndEffector_RobotName :DetachEndEffector)
DataPropertyRange(:hasDetachEndEffector_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasDetachEndEffector_RobotName)
EquivalentClasses(:DetachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasDetachEndEffector_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasDetachEndEffector_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasDetachEndEffector_EndEffectorName))
DataPropertyDomain(:hasDetachEndEffector_EndEffectorName :DetachEndEffector)
DataPropertyRange(:hasDetachEndEffector_EndEffectorName xsd:NMTOKEN)
FunctionalDataProperty(:hasDetachEndEffector_EndEffectorName)
EquivalentClasses(:DetachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasDetachEndEffector_EndEffectorName xsd:NMTOKEN)
  DataAllValuesFrom (:hasDetachEndEffector_EndEffectorName xsd:NMTOKEN)))

Declaration(DataProperty(:hasDetachEndEffector_EndEffectorHolderName))
DataPropertyDomain(:hasDetachEndEffector_EndEffectorHolderName :DetachEndEffector)
DataPropertyRange(:hasDetachEndEffector_EndEffectorHolderName xsd:NMTOKEN)
FunctionalDataProperty(:hasDetachEndEffector_EndEffectorHolderName)
EquivalentClasses(:DetachEndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasDetachEndEffector_EndEffectorHolderName xsd:NMTOKEN)
  DataAllValuesFrom (:hasDetachEndEffector_EndEffectorHolderName xsd:NMTOKEN)))



Declaration(Class(:Else))

AnnotationAssertion(rdfs:comment :Else
  "Else type represents the 'else' part of an If-ElseIf-Else
  construct.
  An instance of Else has the following:
    Step.
  Step is the plan element to execute.")

Declaration(ObjectProperty(:hasElse_Step))
ObjectPropertyDomain(:hasElse_Step :Else)
ObjectPropertyRange(:hasElse_Step :PlanElementBase)
InverseFunctionalObjectProperty(:hasElse_Step)
FunctionalObjectProperty(:hasElse_Step)
EquivalentClasses(:Else ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasElse_Step :PlanElementBase)
  ObjectAllValuesFrom (:hasElse_Step :PlanElementBase)))

Declaration(ObjectProperty(:hadByStep_Else))
InverseObjectProperties(:hasElse_Step
                        :hadByStep_Else)
ObjectPropertyDomain(:hadByStep_Else :PlanElementBase)
ObjectPropertyRange(:hadByStep_Else :Else)



Declaration(Class(:IfActionGroup))

AnnotationAssertion(rdfs:comment :IfActionGroup
  "IfActionGroup is derived from ActionGroupBase and
  represents an If-ElseIf-Else construct with zero to many Else-Ifs
  and an optional Else.
  An instance of IfActionGroup has the following:
    If
    ElseIf (optional, multiple)
    Else (optional).
 
  If is a test to evaluate and the plan element to execute if the
  test evaluates to true.
 
  Each optional ElseIf is a test to evaluate and the plan
  element to execute if the test evaluates to true.
 
  The optional Else is a plan element to execute if none
  of the If or ElseIf tests evaluates to true.
 
  To execute an instance of IfActionGroup:
  1. Evaluate the test in the If. If it evaluates to true,
     execute the plan element in the If and return.
 
  2. Otherwise, evaluate the test in the next ElseIf if there is one.
     If it evaluates to true, execute the plan element in the ElseIf
     and return. Repeat until either return occurs or there are no
     more ElseIfs.
 
  3. Otherwise, if there is an Else, execute the plan element in the
     Else and return.
 
  4. Otherwise, return.
 
  It is possible that no plan element will be executed when an
  instance of IfActionGroup is executed.")

Declaration(ObjectProperty(:hasIfActionGroup_If))
ObjectPropertyDomain(:hasIfActionGroup_If :IfActionGroup)
ObjectPropertyRange(:hasIfActionGroup_If :TestAndStep)
InverseFunctionalObjectProperty(:hasIfActionGroup_If)
FunctionalObjectProperty(:hasIfActionGroup_If)
EquivalentClasses(:IfActionGroup ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasIfActionGroup_If :TestAndStep)
  ObjectAllValuesFrom (:hasIfActionGroup_If :TestAndStep)))

Declaration(ObjectProperty(:hadByIf_IfActionGroup))
InverseObjectProperties(:hasIfActionGroup_If
                        :hadByIf_IfActionGroup)
ObjectPropertyDomain(:hadByIf_IfActionGroup :TestAndStep)
ObjectPropertyRange(:hadByIf_IfActionGroup :IfActionGroup)

Declaration(ObjectProperty(:hasIfActionGroup_ElseIf))
ObjectPropertyDomain(:hasIfActionGroup_ElseIf :IfActionGroup)
ObjectPropertyRange(:hasIfActionGroup_ElseIf :TestAndStep)
InverseFunctionalObjectProperty(:hasIfActionGroup_ElseIf)

Declaration(ObjectProperty(:hadByElseIf_IfActionGroup))
InverseObjectProperties(:hasIfActionGroup_ElseIf
                        :hadByElseIf_IfActionGroup)
ObjectPropertyDomain(:hadByElseIf_IfActionGroup :TestAndStep)
ObjectPropertyRange(:hadByElseIf_IfActionGroup :IfActionGroup)

Declaration(ObjectProperty(:hasIfActionGroup_Else))
ObjectPropertyDomain(:hasIfActionGroup_Else :IfActionGroup)
ObjectPropertyRange(:hasIfActionGroup_Else :Else)
InverseFunctionalObjectProperty(:hasIfActionGroup_Else)
FunctionalObjectProperty(:hasIfActionGroup_Else)

Declaration(ObjectProperty(:hadByElse_IfActionGroup))
InverseObjectProperties(:hasIfActionGroup_Else
                        :hadByElse_IfActionGroup)
ObjectPropertyDomain(:hadByElse_IfActionGroup :Else)
ObjectPropertyRange(:hadByElse_IfActionGroup :IfActionGroup)



Declaration(Class(:KittingPlan))

AnnotationAssertion(rdfs:comment :KittingPlan
  "KittingPlan is derived from DataThing
  An instance of KittingPlan has the following:
    PlanId
    PlanVersion
    PlanDateAndTime
    PlanAuthor
    PlanDescription
    Object (multiple)
    Variable (optional, multiple)
    PlanRoot.
 
  The KittingPlan defines information about a kitting plan.
 
  The PlanId identifies the plan. It would be a good idea to 
  use a universally unique identifier instead of a NMTOKEN.
 
  The PlanDescription is a natural language description of the plan.
 
  Each object is the name of an object mentioned by name elsewhere in
  the plan.
 
  Each Variable is a numeric variable used in the plan.
 
  The PlanRoot gives information about the activities to be carried
  out in executing the kitting plan and how execution of the kitting
  plan is to be controlled. Structurally, the PlanRoot is at the top
  of an (upside down) plan tree of PlanElements. All PlanElement
  instances occur within the tree. The PlanRoot consists of a control
  structure and the plan elements to which the control structure
  applies.")

Declaration(DataProperty(:hasKittingPlan_PlanId))
DataPropertyDomain(:hasKittingPlan_PlanId :KittingPlan)
DataPropertyRange(:hasKittingPlan_PlanId xsd:NMTOKEN)
FunctionalDataProperty(:hasKittingPlan_PlanId)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingPlan_PlanId xsd:NMTOKEN)
  DataAllValuesFrom (:hasKittingPlan_PlanId xsd:NMTOKEN)))

Declaration(DataProperty(:hasKittingPlan_PlanVersion))
DataPropertyDomain(:hasKittingPlan_PlanVersion :KittingPlan)
DataPropertyRange(:hasKittingPlan_PlanVersion xsd:token)
FunctionalDataProperty(:hasKittingPlan_PlanVersion)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingPlan_PlanVersion xsd:token)
  DataAllValuesFrom (:hasKittingPlan_PlanVersion xsd:token)))

Declaration(DataProperty(:hasKittingPlan_PlanDateAndTime))
DataPropertyDomain(:hasKittingPlan_PlanDateAndTime :KittingPlan)
DataPropertyRange(:hasKittingPlan_PlanDateAndTime xsd:dateTime)
FunctionalDataProperty(:hasKittingPlan_PlanDateAndTime)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingPlan_PlanDateAndTime xsd:dateTime)
  DataAllValuesFrom (:hasKittingPlan_PlanDateAndTime xsd:dateTime)))

Declaration(DataProperty(:hasKittingPlan_PlanAuthor))
DataPropertyDomain(:hasKittingPlan_PlanAuthor :KittingPlan)
DataPropertyRange(:hasKittingPlan_PlanAuthor xsd:token)
FunctionalDataProperty(:hasKittingPlan_PlanAuthor)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingPlan_PlanAuthor xsd:token)
  DataAllValuesFrom (:hasKittingPlan_PlanAuthor xsd:token)))

Declaration(DataProperty(:hasKittingPlan_PlanDescription))
DataPropertyDomain(:hasKittingPlan_PlanDescription :KittingPlan)
DataPropertyRange(:hasKittingPlan_PlanDescription xsd:string)
FunctionalDataProperty(:hasKittingPlan_PlanDescription)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingPlan_PlanDescription xsd:string)
  DataAllValuesFrom (:hasKittingPlan_PlanDescription xsd:string)))

Declaration(DataProperty(:hasKittingPlan_Object))
DataPropertyDomain(:hasKittingPlan_Object :KittingPlan)
DataPropertyRange(:hasKittingPlan_Object xsd:NMTOKEN)

Declaration(ObjectProperty(:hasKittingPlan_Variable))
ObjectPropertyDomain(:hasKittingPlan_Variable :KittingPlan)
ObjectPropertyRange(:hasKittingPlan_Variable :VariableDeclaration)
InverseFunctionalObjectProperty(:hasKittingPlan_Variable)

Declaration(ObjectProperty(:hadByVariable_KittingPlan))
InverseObjectProperties(:hasKittingPlan_Variable
                        :hadByVariable_KittingPlan)
ObjectPropertyDomain(:hadByVariable_KittingPlan :VariableDeclaration)
ObjectPropertyRange(:hadByVariable_KittingPlan :KittingPlan)

Declaration(ObjectProperty(:hasKittingPlan_PlanRoot))
ObjectPropertyDomain(:hasKittingPlan_PlanRoot :KittingPlan)
ObjectPropertyRange(:hasKittingPlan_PlanRoot :PlanElementBase)
InverseFunctionalObjectProperty(:hasKittingPlan_PlanRoot)
FunctionalObjectProperty(:hasKittingPlan_PlanRoot)
EquivalentClasses(:KittingPlan ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKittingPlan_PlanRoot :PlanElementBase)
  ObjectAllValuesFrom (:hasKittingPlan_PlanRoot :PlanElementBase)))

Declaration(ObjectProperty(:hadByPlanRoot_KittingPlan))
InverseObjectProperties(:hasKittingPlan_PlanRoot
                        :hadByPlanRoot_KittingPlan)
ObjectPropertyDomain(:hadByPlanRoot_KittingPlan :PlanElementBase)
ObjectPropertyRange(:hadByPlanRoot_KittingPlan :KittingPlan)



Declaration(Class(:LocatePart))

AnnotationAssertion(rdfs:comment :LocatePart
  "LocatePart is derived from SensorActionBase.
  An instance of LocatePart has the following:
    PartName.
 
  The LocatePart is an action that locates the specified
  part. This may change the location information in the part.")

Declaration(DataProperty(:hasLocatePart_PartName))
DataPropertyDomain(:hasLocatePart_PartName :LocatePart)
DataPropertyRange(:hasLocatePart_PartName xsd:NMTOKEN)
FunctionalDataProperty(:hasLocatePart_PartName)
EquivalentClasses(:LocatePart ObjectIntersectionOf(
  DataSomeValuesFrom(:hasLocatePart_PartName xsd:NMTOKEN)
  DataAllValuesFrom (:hasLocatePart_PartName xsd:NMTOKEN)))



Declaration(Class(:NumberedPlanElement))

AnnotationAssertion(rdfs:comment :NumberedPlanElement
  "NumberedPlanElement is derived from DataThing.
  An instance of NumberedPlanElement has the following:
    SequenceNumber
    PlanElement.
 
  The NumberedPlanElement defines a single ordered plan element.
 
  The SequenceNumber is a positive integer used in determining either
  the order within a set of PlanElements in which a plan element
  should be executed or which plan element in the set should be
  executed.
 
  The PlanElement is the plan element associated with the
  SequenceNumber.")

Declaration(DataProperty(:hasNumberedPlanElement_SequenceNumber))
DataPropertyDomain(:hasNumberedPlanElement_SequenceNumber :NumberedPlanElement)
DataPropertyRange(:hasNumberedPlanElement_SequenceNumber xsd:positiveInteger)
FunctionalDataProperty(:hasNumberedPlanElement_SequenceNumber)
EquivalentClasses(:NumberedPlanElement ObjectIntersectionOf(
  DataSomeValuesFrom(:hasNumberedPlanElement_SequenceNumber xsd:positiveInteger)
  DataAllValuesFrom (:hasNumberedPlanElement_SequenceNumber xsd:positiveInteger)))

Declaration(ObjectProperty(:hasNumberedPlanElement_PlanElement))
ObjectPropertyDomain(:hasNumberedPlanElement_PlanElement :NumberedPlanElement)
ObjectPropertyRange(:hasNumberedPlanElement_PlanElement :PlanElementBase)
InverseFunctionalObjectProperty(:hasNumberedPlanElement_PlanElement)
FunctionalObjectProperty(:hasNumberedPlanElement_PlanElement)
EquivalentClasses(:NumberedPlanElement ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasNumberedPlanElement_PlanElement :PlanElementBase)
  ObjectAllValuesFrom (:hasNumberedPlanElement_PlanElement :PlanElementBase)))

Declaration(ObjectProperty(:hadByPlanElement_NumberedPlanElement))
InverseObjectProperties(:hasNumberedPlanElement_PlanElement
                        :hadByPlanElement_NumberedPlanElement)
ObjectPropertyDomain(:hadByPlanElement_NumberedPlanElement :PlanElementBase)
ObjectPropertyRange(:hadByPlanElement_NumberedPlanElement :NumberedPlanElement)



Declaration(Class(:OneOfActionGroup))

AnnotationAssertion(rdfs:comment :OneOfActionGroup
  "OneOfActionGroup is derived from ActionGroupBase.
  An instance of OneOfActionGroup has the following:
    Step (multiple).
 
  The OneOfActionGroup defines an action group for which exactly
  one of the steps it contains must be executed. Any step in the list
  will do. The SequenceNumbers of the Steps in an instance of
  OneOfActionGroup are not required to be distinct. The
  SequenceNumbers indicate a preference for which step is executed,
  with 1 the most preferred, 2 the second most preferred, and so on.
  Steps with the same SequenceNumber are equally preferred.
 
  Each Step is a numbered plan element.")

Declaration(ObjectProperty(:hasOneOfActionGroup_Step))
ObjectPropertyDomain(:hasOneOfActionGroup_Step :OneOfActionGroup)
ObjectPropertyRange(:hasOneOfActionGroup_Step :NumberedPlanElement)
InverseFunctionalObjectProperty(:hasOneOfActionGroup_Step)

Declaration(ObjectProperty(:hadByStep_OneOfActionGroup))
InverseObjectProperties(:hasOneOfActionGroup_Step
                        :hadByStep_OneOfActionGroup)
ObjectPropertyDomain(:hadByStep_OneOfActionGroup :NumberedPlanElement)
ObjectPropertyRange(:hadByStep_OneOfActionGroup :OneOfActionGroup)



Declaration(Class(:OrderedActionGroup))

AnnotationAssertion(rdfs:comment :OrderedActionGroup
  "OrderedActionGroup is derived from ActionGroupBase.
  An instance of OrderedActionGroup has the following:
    Step (multiple).
 
  The OrderedActionGroup defines an action group for which the
  all the steps it contains must be executed in order of increasing
  sequence number. The SequenceNumbers of the Steps in an instance of
  OrderedActionGroup must be present, must be assigned 1, 2, 3,
  ..., and must be executed in that order.
 
  Each Step is a numbered plan element.")

Declaration(ObjectProperty(:hasOrderedActionGroup_Step))
ObjectPropertyDomain(:hasOrderedActionGroup_Step :OrderedActionGroup)
ObjectPropertyRange(:hasOrderedActionGroup_Step :NumberedPlanElement)
InverseFunctionalObjectProperty(:hasOrderedActionGroup_Step)

Declaration(ObjectProperty(:hadByStep_OrderedActionGroup))
InverseObjectProperties(:hasOrderedActionGroup_Step
                        :hadByStep_OrderedActionGroup)
ObjectPropertyDomain(:hadByStep_OrderedActionGroup :NumberedPlanElement)
ObjectPropertyRange(:hadByStep_OrderedActionGroup :OrderedActionGroup)



Declaration(Class(:PartiallyOrderedActionGroup))

AnnotationAssertion(rdfs:comment :PartiallyOrderedActionGroup
  "PartiallyOrderedActionGroup is derived from ActionGroupBase.
  An instance of Partially OrderedActionGroup has the following
  elements:
    Step (multiple).
 
  The PartiallyOrderedActionGroup defines an action group for
  which all of the steps it contains should be executed, but each
  step may be executed only after all of the predecessors of that
  step have been executed. If more than one step meets that
  condition, any order of executing those steps will work, and no
  particular order is required by the plan. The SequenceNumbers of
  the steps in an instance of PartiallyOrderedActionGroup must be
  assigned 1, 2, 3, ... but usually will not be executed in that
  order.
 
  Each Step is a PlanElement with predecessors.")

Declaration(ObjectProperty(:hasPartiallyOrderedActionGroup_Step))
ObjectPropertyDomain(:hasPartiallyOrderedActionGroup_Step :PartiallyOrderedActionGroup)
ObjectPropertyRange(:hasPartiallyOrderedActionGroup_Step :StepWithPredecessors)
InverseFunctionalObjectProperty(:hasPartiallyOrderedActionGroup_Step)

Declaration(ObjectProperty(:hadByStep_PartiallyOrderedActionGroup))
InverseObjectProperties(:hasPartiallyOrderedActionGroup_Step
                        :hadByStep_PartiallyOrderedActionGroup)
ObjectPropertyDomain(:hadByStep_PartiallyOrderedActionGroup :StepWithPredecessors)
ObjectPropertyRange(:hadByStep_PartiallyOrderedActionGroup :PartiallyOrderedActionGroup)



Declaration(Class(:PlanElementBase))

AnnotationAssertion(rdfs:comment :PlanElementBase
  "PlanElementBase is derived from DataThing.
  An instance of PlanElementBase has the following:
    .
 
  PlanElementBase is the abstract base type for plan element
  types.")

SubClassOf(:ActionBase :PlanElementBase)
SubClassOf(:ActionGroupBase :PlanElementBase)
SubClassOf(:VarSet :PlanElementBase)
DisjointUnion(:PlanElementBase
              :ActionBase
              :ActionGroupBase
              :VarSet)



Declaration(Class(:PutKit))

AnnotationAssertion(rdfs:comment :PutKit
  "PutKit is derived from RobotActionBase.
  An instance of PutKit has the following:
    RobotName
    KitName
    Location.
 
  When an instance of PutKit is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be holding the named kit.
  (3) The gripper must be closed.
  (4) The location of the kit should be relative to the gripper.
  The robot moves to the specified location at which it opens the
  gripper so as to release the kit. The location of the kit
  changes so that the kit is located as specified. The Location
  may be a relative location or a pose location. The gripper is
  open and not holding anything after the action is complete.")

Declaration(DataProperty(:hasPutKit_RobotName))
DataPropertyDomain(:hasPutKit_RobotName :PutKit)
DataPropertyRange(:hasPutKit_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutKit_RobotName)
EquivalentClasses(:PutKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutKit_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutKit_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasPutKit_KitName))
DataPropertyDomain(:hasPutKit_KitName :PutKit)
DataPropertyRange(:hasPutKit_KitName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutKit_KitName)
EquivalentClasses(:PutKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutKit_KitName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutKit_KitName xsd:NMTOKEN)))

Declaration(ObjectProperty(:hasPutKit_Location))
ObjectPropertyDomain(:hasPutKit_Location :PutKit)
ObjectPropertyRange(:hasPutKit_Location :PhysicalLocation)
InverseFunctionalObjectProperty(:hasPutKit_Location)
FunctionalObjectProperty(:hasPutKit_Location)
EquivalentClasses(:PutKit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPutKit_Location :PhysicalLocation)
  ObjectAllValuesFrom (:hasPutKit_Location :PhysicalLocation)))

Declaration(ObjectProperty(:hadByLocation_PutKit))
InverseObjectProperties(:hasPutKit_Location
                        :hadByLocation_PutKit)
ObjectPropertyDomain(:hadByLocation_PutKit :PhysicalLocation)
ObjectPropertyRange(:hadByLocation_PutKit :PutKit)



Declaration(Class(:PutKitTray))

AnnotationAssertion(rdfs:comment :PutKitTray
  "PutKitTray is derived from RobotActionBase.
  An instance of PutKitTray has the following:
    RobotName
    KitTrayName
    Location.
 
  When an instance of PutKitTray is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be holding the named kit tray.
  (3) The gripper must be closed.
  (4) The location of the kit tray should be relative to the gripper.
  The robot moves to the specified location at which it opens the
  gripper so as to release the kit tray. The location of the kit tray
  changes so that the kit tray is located as specified. The Location
  may be a relative location or a pose location. The gripper is
  open and not holding anything after the action is complete.")

Declaration(DataProperty(:hasPutKitTray_RobotName))
DataPropertyDomain(:hasPutKitTray_RobotName :PutKitTray)
DataPropertyRange(:hasPutKitTray_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutKitTray_RobotName)
EquivalentClasses(:PutKitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutKitTray_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutKitTray_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasPutKitTray_KitTrayName))
DataPropertyDomain(:hasPutKitTray_KitTrayName :PutKitTray)
DataPropertyRange(:hasPutKitTray_KitTrayName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutKitTray_KitTrayName)
EquivalentClasses(:PutKitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutKitTray_KitTrayName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutKitTray_KitTrayName xsd:NMTOKEN)))

Declaration(ObjectProperty(:hasPutKitTray_Location))
ObjectPropertyDomain(:hasPutKitTray_Location :PutKitTray)
ObjectPropertyRange(:hasPutKitTray_Location :PhysicalLocation)
InverseFunctionalObjectProperty(:hasPutKitTray_Location)
FunctionalObjectProperty(:hasPutKitTray_Location)
EquivalentClasses(:PutKitTray ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPutKitTray_Location :PhysicalLocation)
  ObjectAllValuesFrom (:hasPutKitTray_Location :PhysicalLocation)))

Declaration(ObjectProperty(:hadByLocation_PutKitTray))
InverseObjectProperties(:hasPutKitTray_Location
                        :hadByLocation_PutKitTray)
ObjectPropertyDomain(:hadByLocation_PutKitTray :PhysicalLocation)
ObjectPropertyRange(:hadByLocation_PutKitTray :PutKitTray)



Declaration(Class(:PutPart))

AnnotationAssertion(rdfs:comment :PutPart
  "PutPart is derived from RobotActionBase.
  An instance of PutPart has the following:
    RobotName
    PartName
    Location.
 
  When an instance of PutPart is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be holding the named part.
  (3) The gripper must be closed.
  (4) The location of the part should be relative to the gripper.
  The robot moves to the specified location at which it opens the
  gripper so as to release the part. The location of the part
  changes so that the part is located as specified. The Location
  may be a relative location or a pose location. The gripper is
  open and not holding anything after the action is complete.")

Declaration(DataProperty(:hasPutPart_RobotName))
DataPropertyDomain(:hasPutPart_RobotName :PutPart)
DataPropertyRange(:hasPutPart_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutPart_RobotName)
EquivalentClasses(:PutPart ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutPart_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutPart_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasPutPart_PartName))
DataPropertyDomain(:hasPutPart_PartName :PutPart)
DataPropertyRange(:hasPutPart_PartName xsd:NMTOKEN)
FunctionalDataProperty(:hasPutPart_PartName)
EquivalentClasses(:PutPart ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPutPart_PartName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPutPart_PartName xsd:NMTOKEN)))

Declaration(ObjectProperty(:hasPutPart_Location))
ObjectPropertyDomain(:hasPutPart_Location :PutPart)
ObjectPropertyRange(:hasPutPart_Location :PhysicalLocation)
InverseFunctionalObjectProperty(:hasPutPart_Location)
FunctionalObjectProperty(:hasPutPart_Location)
EquivalentClasses(:PutPart ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPutPart_Location :PhysicalLocation)
  ObjectAllValuesFrom (:hasPutPart_Location :PhysicalLocation)))

Declaration(ObjectProperty(:hadByLocation_PutPart))
InverseObjectProperties(:hasPutPart_Location
                        :hadByLocation_PutPart)
ObjectPropertyDomain(:hadByLocation_PutPart :PhysicalLocation)
ObjectPropertyRange(:hadByLocation_PutPart :PutPart)



Declaration(Class(:RobotActionBase))

AnnotationAssertion(rdfs:comment :RobotActionBase
  "RobotActionBase is derived from ActionBase.
  An instance of RobotActionBase has the following:
    .
 
  The RobotActionBase defines the base type for robot actions.")

SubClassOf(:AttachEndEffector :RobotActionBase)
SubClassOf(:DetachEndEffector :RobotActionBase)
SubClassOf(:PutKitTray :RobotActionBase)
SubClassOf(:PutKit :RobotActionBase)
SubClassOf(:PutPart :RobotActionBase)
SubClassOf(:TakeKitTray :RobotActionBase)
SubClassOf(:TakeKit :RobotActionBase)
SubClassOf(:TakePart :RobotActionBase)
DisjointUnion(:RobotActionBase
              :AttachEndEffector
              :DetachEndEffector
              :PutKitTray
              :PutKit
              :PutPart
              :TakeKitTray
              :TakeKit
              :TakePart)



Declaration(Class(:SensorActionBase))

AnnotationAssertion(rdfs:comment :SensorActionBase
  "SensorActionBase is derived from ActionBase.
  An instance of SensorActionBase has the following:
    .
 
  The SensorActionBase defines the base type for sensor actions.")

SubClassOf(:LocatePart :SensorActionBase)



Declaration(Class(:SomeOfActionGroup))

AnnotationAssertion(rdfs:comment :SomeOfActionGroup
  "SomeOfActionGroup is derived from ActionGroupBase.
  An instance of SomeOfActionGroup has the following:
    Step
    NumberOfSteps.
 
  The SomeOfActionGroup defines an action group for which a
  specified number of the steps it contains must be executed; they
  may be executed in any order.
 
  Each Step is a plan element.
 
  The NumberOfSteps is the number of steps from the Step
  list to be executed. This must be at least one and must not be
  larger than the number of items in the Step list.")

Declaration(ObjectProperty(:hasSomeOfActionGroup_Step))
ObjectPropertyDomain(:hasSomeOfActionGroup_Step :SomeOfActionGroup)
ObjectPropertyRange(:hasSomeOfActionGroup_Step :PlanElementBase)
InverseFunctionalObjectProperty(:hasSomeOfActionGroup_Step)

Declaration(ObjectProperty(:hadByStep_SomeOfActionGroup))
InverseObjectProperties(:hasSomeOfActionGroup_Step
                        :hadByStep_SomeOfActionGroup)
ObjectPropertyDomain(:hadByStep_SomeOfActionGroup :PlanElementBase)
ObjectPropertyRange(:hadByStep_SomeOfActionGroup :SomeOfActionGroup)

Declaration(DataProperty(:hasSomeOfActionGroup_NumberOfSteps))
DataPropertyDomain(:hasSomeOfActionGroup_NumberOfSteps :SomeOfActionGroup)
DataPropertyRange(:hasSomeOfActionGroup_NumberOfSteps xsd:positiveInteger)
FunctionalDataProperty(:hasSomeOfActionGroup_NumberOfSteps)
EquivalentClasses(:SomeOfActionGroup ObjectIntersectionOf(
  DataSomeValuesFrom(:hasSomeOfActionGroup_NumberOfSteps xsd:positiveInteger)
  DataAllValuesFrom (:hasSomeOfActionGroup_NumberOfSteps xsd:positiveInteger)))



Declaration(Class(:StepWithPredecessors))

AnnotationAssertion(rdfs:comment :StepWithPredecessors
  "StepWithPredecessors is derived from DataThing
  An instance of StepWithPredecessors has the following:
    SequenceNumber
    Predecessor (optional, multiple)
    PlanElement.
 
  The StepWithPredecessors defines information about a single
  PlanElement that has predecessors.
 
  Each optional Predecessor is the number of a step that must be
  executed before this step is executed. Care should be taken that no
  step has itself as a predecessor and that there are no loops of
  predecessors, as when step 1 is a predecessor of step 2 and step 2
  is a predecessor of step 1.
 
  The PlanElement is a plan element to be executed.")

Declaration(DataProperty(:hasStepWithPredecessors_SequenceNumber))
DataPropertyDomain(:hasStepWithPredecessors_SequenceNumber :StepWithPredecessors)
DataPropertyRange(:hasStepWithPredecessors_SequenceNumber xsd:positiveInteger)
FunctionalDataProperty(:hasStepWithPredecessors_SequenceNumber)
EquivalentClasses(:StepWithPredecessors ObjectIntersectionOf(
  DataSomeValuesFrom(:hasStepWithPredecessors_SequenceNumber xsd:positiveInteger)
  DataAllValuesFrom (:hasStepWithPredecessors_SequenceNumber xsd:positiveInteger)))

Declaration(DataProperty(:hasStepWithPredecessors_Predecessor))
DataPropertyDomain(:hasStepWithPredecessors_Predecessor :StepWithPredecessors)
DataPropertyRange(:hasStepWithPredecessors_Predecessor xsd:positiveInteger)

Declaration(ObjectProperty(:hasStepWithPredecessors_PlanElement))
ObjectPropertyDomain(:hasStepWithPredecessors_PlanElement :StepWithPredecessors)
ObjectPropertyRange(:hasStepWithPredecessors_PlanElement :PlanElementBase)
InverseFunctionalObjectProperty(:hasStepWithPredecessors_PlanElement)
FunctionalObjectProperty(:hasStepWithPredecessors_PlanElement)
EquivalentClasses(:StepWithPredecessors ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasStepWithPredecessors_PlanElement :PlanElementBase)
  ObjectAllValuesFrom (:hasStepWithPredecessors_PlanElement :PlanElementBase)))

Declaration(ObjectProperty(:hadByPlanElement_StepWithPredecessors))
InverseObjectProperties(:hasStepWithPredecessors_PlanElement
                        :hadByPlanElement_StepWithPredecessors)
ObjectPropertyDomain(:hadByPlanElement_StepWithPredecessors :PlanElementBase)
ObjectPropertyRange(:hadByPlanElement_StepWithPredecessors :StepWithPredecessors)



Declaration(Class(:TakeKit))

AnnotationAssertion(rdfs:comment :TakeKit
  "TakeKit is derived from RobotActionBase.
  An instance of TakeKit has the following:
    RobotName
    KitName.
 
  Immediately before an instance of TakeKit is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be appropriate for picking up the named kit.
  (3) The gripper must be empty.
  (4) The gripper must be open.
 
  As an instance of TakeKit is executed:
  The robot moves to a position from which it may pick up the kit
  and closes the gripper on the kit. The kit is not moved but
  the location of the kit changes so that the kit is located
  relative to the gripper.")

Declaration(DataProperty(:hasTakeKit_RobotName))
DataPropertyDomain(:hasTakeKit_RobotName :TakeKit)
DataPropertyRange(:hasTakeKit_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakeKit_RobotName)
EquivalentClasses(:TakeKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakeKit_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakeKit_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasTakeKit_KitName))
DataPropertyDomain(:hasTakeKit_KitName :TakeKit)
DataPropertyRange(:hasTakeKit_KitName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakeKit_KitName)
EquivalentClasses(:TakeKit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakeKit_KitName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakeKit_KitName xsd:NMTOKEN)))



Declaration(Class(:TakeKitTray))

AnnotationAssertion(rdfs:comment :TakeKitTray
  "TakeKitTray is derived from RobotActionBase.
  An instance of TakeKitTray has the following:
    RobotName
    KitTrayName.
 
  Immediately before an instance of TakeKitTray is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be appropriate for picking up the named kit tray.
  (3) The gripper must be empty.
  (4) The gripper must be open.
 
  As an instance of TakeKitTray is executed:
  The robot moves to a position from which it may pick up the kit tray
  and closes the gripper on the kit tray. The kit tray is not moved but
  the location of the kit tray changes so that the kit tray is located
  relative to the gripper.")

Declaration(DataProperty(:hasTakeKitTray_RobotName))
DataPropertyDomain(:hasTakeKitTray_RobotName :TakeKitTray)
DataPropertyRange(:hasTakeKitTray_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakeKitTray_RobotName)
EquivalentClasses(:TakeKitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakeKitTray_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakeKitTray_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasTakeKitTray_KitTrayName))
DataPropertyDomain(:hasTakeKitTray_KitTrayName :TakeKitTray)
DataPropertyRange(:hasTakeKitTray_KitTrayName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakeKitTray_KitTrayName)
EquivalentClasses(:TakeKitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakeKitTray_KitTrayName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakeKitTray_KitTrayName xsd:NMTOKEN)))



Declaration(Class(:TakePart))

AnnotationAssertion(rdfs:comment :TakePart
  "TakePart is derived from RobotActionBase.
  An instance of TakePart has the following:
    RobotName
    PartName.
 
  Immediately before an instance of TakePart is executed:
  (1) The named robot must have a gripper in its tool changer.
  (2) The gripper must be appropriate for picking up the named part.
  (3) The gripper must be empty.
  (4) The gripper must be open.
 
  As an instance of TakePart is executed:
  The robot moves to a position from which it may pick up the part
  and closes the gripper on the part. The part is not moved but
  the location of the part changes so that the part is located
  relative to the gripper.")

Declaration(DataProperty(:hasTakePart_RobotName))
DataPropertyDomain(:hasTakePart_RobotName :TakePart)
DataPropertyRange(:hasTakePart_RobotName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakePart_RobotName)
EquivalentClasses(:TakePart ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakePart_RobotName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakePart_RobotName xsd:NMTOKEN)))

Declaration(DataProperty(:hasTakePart_PartName))
DataPropertyDomain(:hasTakePart_PartName :TakePart)
DataPropertyRange(:hasTakePart_PartName xsd:NMTOKEN)
FunctionalDataProperty(:hasTakePart_PartName)
EquivalentClasses(:TakePart ObjectIntersectionOf(
  DataSomeValuesFrom(:hasTakePart_PartName xsd:NMTOKEN)
  DataAllValuesFrom (:hasTakePart_PartName xsd:NMTOKEN)))



Declaration(Class(:TestAndStep))

AnnotationAssertion(rdfs:comment :TestAndStep
  "TestAndStep represents a test to evaluate and a plan element
  to execute if the test evaluates to true.
  An instance of TestAndStep has the following:
    Test
    Step.
 
  Test is a boolean expression to evaluate.
  Step is the plan element to execute if the Test evaluates to true.")

Declaration(ObjectProperty(:hasTestAndStep_Test))
ObjectPropertyDomain(:hasTestAndStep_Test :TestAndStep)
ObjectPropertyRange(:hasTestAndStep_Test :BooleanExpression)
InverseFunctionalObjectProperty(:hasTestAndStep_Test)
FunctionalObjectProperty(:hasTestAndStep_Test)
EquivalentClasses(:TestAndStep ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasTestAndStep_Test :BooleanExpression)
  ObjectAllValuesFrom (:hasTestAndStep_Test :BooleanExpression)))

Declaration(ObjectProperty(:hadByTest_TestAndStep))
InverseObjectProperties(:hasTestAndStep_Test
                        :hadByTest_TestAndStep)
ObjectPropertyDomain(:hadByTest_TestAndStep :BooleanExpression)
ObjectPropertyRange(:hadByTest_TestAndStep :TestAndStep)

Declaration(ObjectProperty(:hasTestAndStep_Step))
ObjectPropertyDomain(:hasTestAndStep_Step :TestAndStep)
ObjectPropertyRange(:hasTestAndStep_Step :PlanElementBase)
InverseFunctionalObjectProperty(:hasTestAndStep_Step)
FunctionalObjectProperty(:hasTestAndStep_Step)
EquivalentClasses(:TestAndStep ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasTestAndStep_Step :PlanElementBase)
  ObjectAllValuesFrom (:hasTestAndStep_Step :PlanElementBase)))

Declaration(ObjectProperty(:hadByStep_TestAndStep))
InverseObjectProperties(:hasTestAndStep_Step
                        :hadByStep_TestAndStep)
ObjectPropertyDomain(:hadByStep_TestAndStep :PlanElementBase)
ObjectPropertyRange(:hadByStep_TestAndStep :TestAndStep)



Declaration(Class(:UnorderedActionGroup))

AnnotationAssertion(rdfs:comment :UnorderedActionGroup
  "UnorderedActionGroup is derived from ActionGroupBase.
  An instance of UnorderedActionGroup has the following:
    Step.
 
  The UnorderedActionGroup defines an action group for which all
  of the steps it contains should be executed, but any order of
  executing them will work, and no particular order of execution is
  required.
 
  Each Step is a plan element to execute.")

Declaration(ObjectProperty(:hasUnorderedActionGroup_Step))
ObjectPropertyDomain(:hasUnorderedActionGroup_Step :UnorderedActionGroup)
ObjectPropertyRange(:hasUnorderedActionGroup_Step :PlanElementBase)
InverseFunctionalObjectProperty(:hasUnorderedActionGroup_Step)

Declaration(ObjectProperty(:hadByStep_UnorderedActionGroup))
InverseObjectProperties(:hasUnorderedActionGroup_Step
                        :hadByStep_UnorderedActionGroup)
ObjectPropertyDomain(:hadByStep_UnorderedActionGroup :PlanElementBase)
ObjectPropertyRange(:hadByStep_UnorderedActionGroup :UnorderedActionGroup)



Declaration(Class(:WhileActionGroup))

AnnotationAssertion(rdfs:comment :WhileActionGroup
  "WhileActionGroup represents a loop.
  An instance of WhileActionGroup has the following:
    Test
    Step.
 
  Test is a boolean expression to evaluate.
  Step is a plan element to execute if the test evaluates to true.
 
  To execute an instance of WhileActionGroup, evaluate the Test.
  If the Test evaluates to true, execute the Step. Repeat evaluating
  and executing as long as the Test evaluates to true. The first time
  the Test evaluates to false, return.
 
  If the Test evaluates to false the first time it is evaluated, the
  Step is never executed.")

Declaration(ObjectProperty(:hasWhileActionGroup_Test))
ObjectPropertyDomain(:hasWhileActionGroup_Test :WhileActionGroup)
ObjectPropertyRange(:hasWhileActionGroup_Test :BooleanExpression)
InverseFunctionalObjectProperty(:hasWhileActionGroup_Test)
FunctionalObjectProperty(:hasWhileActionGroup_Test)
EquivalentClasses(:WhileActionGroup ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasWhileActionGroup_Test :BooleanExpression)
  ObjectAllValuesFrom (:hasWhileActionGroup_Test :BooleanExpression)))

Declaration(ObjectProperty(:hadByTest_WhileActionGroup))
InverseObjectProperties(:hasWhileActionGroup_Test
                        :hadByTest_WhileActionGroup)
ObjectPropertyDomain(:hadByTest_WhileActionGroup :BooleanExpression)
ObjectPropertyRange(:hadByTest_WhileActionGroup :WhileActionGroup)

Declaration(ObjectProperty(:hasWhileActionGroup_Step))
ObjectPropertyDomain(:hasWhileActionGroup_Step :WhileActionGroup)
ObjectPropertyRange(:hasWhileActionGroup_Step :PlanElementBase)
InverseFunctionalObjectProperty(:hasWhileActionGroup_Step)
FunctionalObjectProperty(:hasWhileActionGroup_Step)
EquivalentClasses(:WhileActionGroup ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasWhileActionGroup_Step :PlanElementBase)
  ObjectAllValuesFrom (:hasWhileActionGroup_Step :PlanElementBase)))

Declaration(ObjectProperty(:hadByStep_WhileActionGroup))
InverseObjectProperties(:hasWhileActionGroup_Step
                        :hadByStep_WhileActionGroup)
ObjectPropertyDomain(:hadByStep_WhileActionGroup :PlanElementBase)
ObjectPropertyRange(:hadByStep_WhileActionGroup :WhileActionGroup)



Declaration(Class(:And))

AnnotationAssertion(rdfs:comment :And
  "And is derived from BinaryBooleanExpression.
  An instance of And has the following:
    B1 (inherited)
    B2 (inherited).
 
  B1 and B2 are two boolean expressions to be considered. The And
  returns True if the value of B1 is True and the value of B2 is
  True. Otherwise, it returns False.")



Declaration(Class(:ArithmeticComparisonBooleanExpression))

AnnotationAssertion(rdfs:comment :ArithmeticComparisonBooleanExpression
  "ArithmeticComparisonBooleanExpression is an abstract type
  derived from BooleanExpression representing an expression
  with a value that is an xs:boolean. An instance of
  ArithmeticComparisonBooleanExpression has the following:
    A1
    A2.
 
  A1 and A2 are two arithmetic expressions to be compared.")

SubClassOf(:Equal :ArithmeticComparisonBooleanExpression)
SubClassOf(:GreaterOrEqual :ArithmeticComparisonBooleanExpression)
SubClassOf(:Greater :ArithmeticComparisonBooleanExpression)
SubClassOf(:LessOrEqual :ArithmeticComparisonBooleanExpression)
SubClassOf(:Less :ArithmeticComparisonBooleanExpression)
SubClassOf(:NotEqual :ArithmeticComparisonBooleanExpression)
DisjointUnion(:ArithmeticComparisonBooleanExpression
              :Equal
              :GreaterOrEqual
              :Greater
              :LessOrEqual
              :Less
              :NotEqual)

Declaration(ObjectProperty(:hasArithmeticComparisonBooleanExpression_A1))
ObjectPropertyDomain(:hasArithmeticComparisonBooleanExpression_A1 :ArithmeticComparisonBooleanExpression)
ObjectPropertyRange(:hasArithmeticComparisonBooleanExpression_A1 :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasArithmeticComparisonBooleanExpression_A1)
FunctionalObjectProperty(:hasArithmeticComparisonBooleanExpression_A1)
EquivalentClasses(:ArithmeticComparisonBooleanExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasArithmeticComparisonBooleanExpression_A1 :ArithmeticExpression)
  ObjectAllValuesFrom (:hasArithmeticComparisonBooleanExpression_A1 :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByA1_ArithmeticComparisonBooleanExpression))
InverseObjectProperties(:hasArithmeticComparisonBooleanExpression_A1
                        :hadByA1_ArithmeticComparisonBooleanExpression)
ObjectPropertyDomain(:hadByA1_ArithmeticComparisonBooleanExpression :ArithmeticExpression)
ObjectPropertyRange(:hadByA1_ArithmeticComparisonBooleanExpression :ArithmeticComparisonBooleanExpression)

Declaration(ObjectProperty(:hasArithmeticComparisonBooleanExpression_A2))
ObjectPropertyDomain(:hasArithmeticComparisonBooleanExpression_A2 :ArithmeticComparisonBooleanExpression)
ObjectPropertyRange(:hasArithmeticComparisonBooleanExpression_A2 :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasArithmeticComparisonBooleanExpression_A2)
FunctionalObjectProperty(:hasArithmeticComparisonBooleanExpression_A2)
EquivalentClasses(:ArithmeticComparisonBooleanExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasArithmeticComparisonBooleanExpression_A2 :ArithmeticExpression)
  ObjectAllValuesFrom (:hasArithmeticComparisonBooleanExpression_A2 :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByA2_ArithmeticComparisonBooleanExpression))
InverseObjectProperties(:hasArithmeticComparisonBooleanExpression_A2
                        :hadByA2_ArithmeticComparisonBooleanExpression)
ObjectPropertyDomain(:hadByA2_ArithmeticComparisonBooleanExpression :ArithmeticExpression)
ObjectPropertyRange(:hadByA2_ArithmeticComparisonBooleanExpression :ArithmeticComparisonBooleanExpression)



Declaration(Class(:ArithmeticExpression))

AnnotationAssertion(rdfs:comment :ArithmeticExpression
  "ArithmeticExpression is an abstract type derived from
  DataThing and representing an expression with a value that
  is an xs:decimal.
  An instance of ArithmeticExpression has the following:
    .
 
  ArithmeticExpression has the following derivation hierarchy:
  DataThing
  |-ArithmeticExpression
    |-Decimal
    |-BinaryArithmeticExpression
    | |-Div
    | |-Minus
    | |-Mod
    | |-Plus
    | |-Times
    |-Negate
    |-PropVal
    |-VarVal")

SubClassOf(:BinaryArithmeticExpression :ArithmeticExpression)
SubClassOf(:Decimal :ArithmeticExpression)
SubClassOf(:Negate :ArithmeticExpression)
SubClassOf(:PropVal :ArithmeticExpression)
SubClassOf(:VarVal :ArithmeticExpression)
DisjointUnion(:ArithmeticExpression
              :BinaryArithmeticExpression
              :Decimal
              :Negate
              :PropVal
              :VarVal)



Declaration(Class(:BinaryArithmeticExpression))

AnnotationAssertion(rdfs:comment :BinaryArithmeticExpression
  "BinaryArithmeticExpression is an abstract type derived from
  ArithmeticExpression that represents an arithmetic operation
  with two operands, both of which are ArithmeticExpression.
  An instance of BinaryArithmeticExpression has the
  following:
    A1
    A2.
 
  A1 is the first arithmetic expression.
  A2 is the second arithmetic expression.")

SubClassOf(:Div :BinaryArithmeticExpression)
SubClassOf(:Minus :BinaryArithmeticExpression)
SubClassOf(:Mod :BinaryArithmeticExpression)
SubClassOf(:Plus :BinaryArithmeticExpression)
SubClassOf(:Times :BinaryArithmeticExpression)
DisjointUnion(:BinaryArithmeticExpression
              :Div
              :Minus
              :Mod
              :Plus
              :Times)

Declaration(ObjectProperty(:hasBinaryArithmeticExpression_A1))
ObjectPropertyDomain(:hasBinaryArithmeticExpression_A1 :BinaryArithmeticExpression)
ObjectPropertyRange(:hasBinaryArithmeticExpression_A1 :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasBinaryArithmeticExpression_A1)
FunctionalObjectProperty(:hasBinaryArithmeticExpression_A1)
EquivalentClasses(:BinaryArithmeticExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBinaryArithmeticExpression_A1 :ArithmeticExpression)
  ObjectAllValuesFrom (:hasBinaryArithmeticExpression_A1 :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByA1_BinaryArithmeticExpression))
InverseObjectProperties(:hasBinaryArithmeticExpression_A1
                        :hadByA1_BinaryArithmeticExpression)
ObjectPropertyDomain(:hadByA1_BinaryArithmeticExpression :ArithmeticExpression)
ObjectPropertyRange(:hadByA1_BinaryArithmeticExpression :BinaryArithmeticExpression)

Declaration(ObjectProperty(:hasBinaryArithmeticExpression_A2))
ObjectPropertyDomain(:hasBinaryArithmeticExpression_A2 :BinaryArithmeticExpression)
ObjectPropertyRange(:hasBinaryArithmeticExpression_A2 :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasBinaryArithmeticExpression_A2)
FunctionalObjectProperty(:hasBinaryArithmeticExpression_A2)
EquivalentClasses(:BinaryArithmeticExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBinaryArithmeticExpression_A2 :ArithmeticExpression)
  ObjectAllValuesFrom (:hasBinaryArithmeticExpression_A2 :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByA2_BinaryArithmeticExpression))
InverseObjectProperties(:hasBinaryArithmeticExpression_A2
                        :hadByA2_BinaryArithmeticExpression)
ObjectPropertyDomain(:hadByA2_BinaryArithmeticExpression :ArithmeticExpression)
ObjectPropertyRange(:hadByA2_BinaryArithmeticExpression :BinaryArithmeticExpression)



Declaration(Class(:BinaryBooleanExpression))

AnnotationAssertion(rdfs:comment :BinaryBooleanExpression
  "BinaryBooleanExpression is an abstract type derived from
  BooleanExpression that represents a boolean operation
  with two operands, both of which are BooleanExpression.
  An instance of BinaryBooleanExpression has the
  following:
    B1
    B2.
 
  B1 is the first boolean expression.
  B2 is the second boolean expression.")

SubClassOf(:And :BinaryBooleanExpression)
SubClassOf(:Or :BinaryBooleanExpression)
DisjointUnion(:BinaryBooleanExpression
              :And
              :Or)

Declaration(ObjectProperty(:hasBinaryBooleanExpression_B1))
ObjectPropertyDomain(:hasBinaryBooleanExpression_B1 :BinaryBooleanExpression)
ObjectPropertyRange(:hasBinaryBooleanExpression_B1 :BooleanExpression)
InverseFunctionalObjectProperty(:hasBinaryBooleanExpression_B1)
FunctionalObjectProperty(:hasBinaryBooleanExpression_B1)
EquivalentClasses(:BinaryBooleanExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBinaryBooleanExpression_B1 :BooleanExpression)
  ObjectAllValuesFrom (:hasBinaryBooleanExpression_B1 :BooleanExpression)))

Declaration(ObjectProperty(:hadByB1_BinaryBooleanExpression))
InverseObjectProperties(:hasBinaryBooleanExpression_B1
                        :hadByB1_BinaryBooleanExpression)
ObjectPropertyDomain(:hadByB1_BinaryBooleanExpression :BooleanExpression)
ObjectPropertyRange(:hadByB1_BinaryBooleanExpression :BinaryBooleanExpression)

Declaration(ObjectProperty(:hasBinaryBooleanExpression_B2))
ObjectPropertyDomain(:hasBinaryBooleanExpression_B2 :BinaryBooleanExpression)
ObjectPropertyRange(:hasBinaryBooleanExpression_B2 :BooleanExpression)
InverseFunctionalObjectProperty(:hasBinaryBooleanExpression_B2)
FunctionalObjectProperty(:hasBinaryBooleanExpression_B2)
EquivalentClasses(:BinaryBooleanExpression ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBinaryBooleanExpression_B2 :BooleanExpression)
  ObjectAllValuesFrom (:hasBinaryBooleanExpression_B2 :BooleanExpression)))

Declaration(ObjectProperty(:hadByB2_BinaryBooleanExpression))
InverseObjectProperties(:hasBinaryBooleanExpression_B2
                        :hadByB2_BinaryBooleanExpression)
ObjectPropertyDomain(:hadByB2_BinaryBooleanExpression :BooleanExpression)
ObjectPropertyRange(:hadByB2_BinaryBooleanExpression :BinaryBooleanExpression)



Declaration(Class(:BooleanExpression))

AnnotationAssertion(rdfs:comment :BooleanExpression
  "BooleanExpression is an abstract type derived from
	DataThing and representing an expression with a value that is
  an xs:boolean (i.e., either True or False).
  An instance of BooleanExpression has the following:
    .
 
  BooleanExpression has the following derivation hierarchy:
  DataThing
  |-BooleanExpression
    |-ArithmeticComparisonBooleanExpression
    | |-Equal
    | |-GreaterOrEqual
    | |-Greater
    | |-LessOrEqual
    | |-Less
    | |-NotEqual
    |-BooleanConstant
    | |-True
    | |-False
    |-BinaryBooleanExpression
    | |-And
    | |-Or
    |-Not")

SubClassOf(:ArithmeticComparisonBooleanExpression :BooleanExpression)
SubClassOf(:BinaryBooleanExpression :BooleanExpression)
SubClassOf(:BooleanConstant :BooleanExpression)
SubClassOf(:Not :BooleanExpression)
DisjointUnion(:BooleanExpression
              :ArithmeticComparisonBooleanExpression
              :BinaryBooleanExpression
              :BooleanConstant
              :Not)



Declaration(Class(:BooleanConstant))

AnnotationAssertion(rdfs:comment :BooleanConstant
  "BooleanConstant is an abstract type derived from
  BooleanExpression representing a constant boolean value
  (i.e., either True or False). An instance of BooleanConstant
  has the following:
    .")

SubClassOf(:False :BooleanConstant)
SubClassOf(:True :BooleanConstant)
DisjointUnion(:BooleanConstant
              :False
              :True)



Declaration(Class(:Decimal))

AnnotationAssertion(rdfs:comment :Decimal
  "Decimal is derived from ArithmeticExpression and
  represents a constant number. An instance of Decimal has
  the following:
    A.
 
  A is a number that is an xs:decimal.")

Declaration(DataProperty(:hasDecimal_A))
DataPropertyDomain(:hasDecimal_A :Decimal)
DataPropertyRange(:hasDecimal_A xsd:decimal)
FunctionalDataProperty(:hasDecimal_A)
EquivalentClasses(:Decimal ObjectIntersectionOf(
  DataSomeValuesFrom(:hasDecimal_A xsd:decimal)
  DataAllValuesFrom (:hasDecimal_A xsd:decimal)))



Declaration(Class(:Div))

AnnotationAssertion(rdfs:comment :Div
  "Div is derived from BinaryArithmeticExpression and
  represents one number divided by another.
  An instance of Div has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The value of an instance of Div is the value of A1 divided by
  the value of A2. The value of A2 should not be zero.")



Declaration(Class(:Equal))

AnnotationAssertion(rdfs:comment :Equal
  "Equal is derived from ArithmeticComparisonBooleanExpression.
  An instance of Equal has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The Equal is an arithmetic comparison type. It returns a
  boolean value of True if the value of arithmetic expression A1 is
  equal to the value of arithmetic expression A2. Otherwise, it
  returns False.")



Declaration(Class(:False))

AnnotationAssertion(rdfs:comment :False
  "False is derived from BooleanConstant and represents
  a boolean value of False.
  An instance of False has the following:
    .")



Declaration(Class(:GreaterOrEqual))

AnnotationAssertion(rdfs:comment :GreaterOrEqual
  "GreaterOrEqual is derived from
  ArithmeticComparisonBooleanExpression.
  An instance of GreaterOrEqual has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The GreaterOrEqual is an arithmetic comparison type. It returns
  a boolean value of True if the value of arithmetic expression A1 is
  greater than or equal to the value of arithmetic expression A2.
  Otherwise, it returns False.")



Declaration(Class(:Greater))

AnnotationAssertion(rdfs:comment :Greater
  "Greater is derived from
  ArithmeticComparisonBooleanExpression.
  An instance of Greater has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The Greater is an arithmetic comparison type. It returns a
  boolean value of True if the value of arithmetic expression A1 is
  greater than the value of arithmetic expression A2. Otherwise, it
  returns False.")



Declaration(Class(:LessOrEqual))

AnnotationAssertion(rdfs:comment :LessOrEqual
  "LessOrEqual is derived from
  ArithmeticComparisonBooleanExpression.
  An instance of LessOrEqual has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The LessOrEqual is an arithmetic comparison type. It returns a
  boolean value of True if the value of arithmetic expression A1 is
  less than or equal to the value of arithmetic expression A2.
  Otherwise, it returns False.")



Declaration(Class(:Less))

AnnotationAssertion(rdfs:comment :Less
  "Less is derived from ArithmeticComparisonBooleanExpression.
  An instance of Less has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The Less is an arithmetic comparison type. It returns a boolean
  value of True if the value of arithmetic expression A1 is less than
  the value of arithmetic expression A2. Otherwise, it returns False.")



Declaration(Class(:Minus))

AnnotationAssertion(rdfs:comment :Minus
  "Minus is derived from BinaryArithmeticExpression and
  represents one number subtracted from another.
  An instance of Minus has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The value of an instance of Minus is the value of A1 minus the
  value of A2.")



Declaration(Class(:Mod))

AnnotationAssertion(rdfs:comment :Mod
  "Mod is derived from BinaryArithmeticExpression and
  represents the remainder when one number is divided by another.
  An instance of Mod has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The value of an instance of Mod is the remainder when the value
  of A1 is divided by the value of A2. The value of A2 should not be
  zero.")



Declaration(Class(:Negate))

AnnotationAssertion(rdfs:comment :Negate
  "Negate is derived from ArithmeticExpression and represents
  reversing the sign of the value of an arithmetic expression.
  An instance of Negate has the following:
    A.
 
  A is the arithmetic expression whose value is to have its sign
  reversed. The value of an instance of Negate is the value of
  A multiplied by -1.")

Declaration(ObjectProperty(:hasNegate_A))
ObjectPropertyDomain(:hasNegate_A :Negate)
ObjectPropertyRange(:hasNegate_A :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasNegate_A)
FunctionalObjectProperty(:hasNegate_A)
EquivalentClasses(:Negate ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasNegate_A :ArithmeticExpression)
  ObjectAllValuesFrom (:hasNegate_A :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByA_Negate))
InverseObjectProperties(:hasNegate_A
                        :hadByA_Negate)
ObjectPropertyDomain(:hadByA_Negate :ArithmeticExpression)
ObjectPropertyRange(:hadByA_Negate :Negate)



Declaration(Class(:NotEqual))

AnnotationAssertion(rdfs:comment :NotEqual
  "NotEqual is derived from ArithmeticComparisonBooleanExpression.
  An instance of NotEqual has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The NotEqual is an arithmetic comparison type. It returns a
  boolean value of True if the value of arithmetic expression A1 is
  not equal to the value of arithmetic expression A2. Otherwise, it
  returns False.")



Declaration(Class(:Not))

AnnotationAssertion(rdfs:comment :Not
  "Not is derived from BooleanExpression.
  An instance of Not has the following:
    B.
 
  B is a boolean expression to be negated. The Not returns True
  if the value of B is False. Otherwise, it returns False.")

Declaration(ObjectProperty(:hasNot_B))
ObjectPropertyDomain(:hasNot_B :Not)
ObjectPropertyRange(:hasNot_B :BooleanExpression)
InverseFunctionalObjectProperty(:hasNot_B)
FunctionalObjectProperty(:hasNot_B)
EquivalentClasses(:Not ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasNot_B :BooleanExpression)
  ObjectAllValuesFrom (:hasNot_B :BooleanExpression)))

Declaration(ObjectProperty(:hadByB_Not))
InverseObjectProperties(:hasNot_B
                        :hadByB_Not)
ObjectPropertyDomain(:hadByB_Not :BooleanExpression)
ObjectPropertyRange(:hadByB_Not :Not)



Declaration(Class(:Or))

AnnotationAssertion(rdfs:comment :Or
  "Or is derived from BinaryBooleanExpression.
  An instance of Or has the following:
    B1 (inherited)
    B2 (inherited).
 
  B1 and B2 are two boolean expressions to be considered. The Or
  returns True (a) if the value of B1 is True and the value of B2 is
  False, or (b) if the value of B2 is True and the value of B1 is
  False, or (c) if both values are True. Otherwise, it returns False.")



Declaration(Class(:Plus))

AnnotationAssertion(rdfs:comment :Plus
  "Plus is derived from BinaryArithmeticExpression and
  represents one number added to another.
  An instance of Plus has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The value of an instance of Plus is the value of A1 plus the
  value of A2.")



Declaration(Class(:PropVal))

AnnotationAssertion(rdfs:comment :PropVal
  "PropVal is derived from ArithmeticExpression and represents
  the value of any numerical data property of any SolidObject
  or DataThing.
  An instance of PropVal has the following.
    ThingName
    Property.
 
  ThingName is the name of an instance of DataThing or
  SolidObject.
 
  Property is the name of a numerical property of the identified
  instance. The value of an instance of PropVal is the value
  of the property.")

Declaration(DataProperty(:hasPropVal_ThingName))
DataPropertyDomain(:hasPropVal_ThingName :PropVal)
DataPropertyRange(:hasPropVal_ThingName xsd:NMTOKEN)
FunctionalDataProperty(:hasPropVal_ThingName)
EquivalentClasses(:PropVal ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPropVal_ThingName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPropVal_ThingName xsd:NMTOKEN)))

Declaration(DataProperty(:hasPropVal_Property))
DataPropertyDomain(:hasPropVal_Property :PropVal)
DataPropertyRange(:hasPropVal_Property xsd:NMTOKEN)
FunctionalDataProperty(:hasPropVal_Property)
EquivalentClasses(:PropVal ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPropVal_Property xsd:NMTOKEN)
  DataAllValuesFrom (:hasPropVal_Property xsd:NMTOKEN)))



Declaration(Class(:Times))

AnnotationAssertion(rdfs:comment :Times
  "Times is derived from BinaryArithmeticExpression and
  represents one number multiplied by another.
  An instance of Times has the following:
    A1 (inherited)
    A2 (inherited)
    .
 
  The value of an instance of Times is the value of A1 multiplied
  by the value of A2.")



Declaration(Class(:True))

AnnotationAssertion(rdfs:comment :True
  "True is derived from BooleanConstant and represents
  a boolean value of True.
  An instance of True has the following:
    .")



Declaration(Class(:VariableDeclaration))

AnnotationAssertion(rdfs:comment :VariableDeclaration
  "VariableDeclaration is derived from DataThing and
  represents declaring a numerical variable whose value is
  an xs:decimal.
  An instance of VariableDeclaration has the following:
    Val.
 
  Val is the initial value of the variable. The value may be reset
  using an instance of VarSet. The value may be used using an
  instance of VarVal.")

Declaration(DataProperty(:hasVariableDeclaration_Val))
DataPropertyDomain(:hasVariableDeclaration_Val :VariableDeclaration)
DataPropertyRange(:hasVariableDeclaration_Val xsd:decimal)
FunctionalDataProperty(:hasVariableDeclaration_Val)
EquivalentClasses(:VariableDeclaration ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVariableDeclaration_Val xsd:decimal)
  DataAllValuesFrom (:hasVariableDeclaration_Val xsd:decimal)))



Declaration(Class(:VarVal))

AnnotationAssertion(rdfs:comment :VarVal
  "VarVal is derived from ArithmeticExpression and represents
  the value of a numerical variable.
  An instance of VarVal has the following.
    VarName.
 
  VarName is the name of a variable created with the
  VariableDeclaration. The value of an instance of VarVal is
  the value of the variable at the time the variable is used (as in
  standard programming languages).")


Declaration(ObjectProperty(:hasVarVal_Var))
ObjectPropertyDomain(:hasVarVal_Var :VarVal)
ObjectPropertyRange(:hasVarVal_Var :VariableDeclaration)
FunctionalObjectProperty(:hasVarVal_Var)
EquivalentClasses(:VarVal ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasVarVal_Var :VariableDeclaration)
  ObjectAllValuesFrom (:hasVarVal_Var :VariableDeclaration)))



Declaration(Class(:VarSet))

AnnotationAssertion(rdfs:comment :VarSet
  "VarSet is derived from PlanElementBase and represents
  the setting of a variable.
  An instance of VarSet has the following:
    Var
    Val.
 
  VarName is the name of a variable.
 
  Val is the value to which the variable should be set.")


Declaration(ObjectProperty(:hasVarSet_Var))
ObjectPropertyDomain(:hasVarSet_Var :VarSet)
ObjectPropertyRange(:hasVarSet_Var :VariableDeclaration)
FunctionalObjectProperty(:hasVarSet_Var)
EquivalentClasses(:VarSet ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasVarSet_Var :VariableDeclaration)
  ObjectAllValuesFrom (:hasVarSet_Var :VariableDeclaration)))

Declaration(ObjectProperty(:hasVarSet_Val))
ObjectPropertyDomain(:hasVarSet_Val :VarSet)
ObjectPropertyRange(:hasVarSet_Val :ArithmeticExpression)
InverseFunctionalObjectProperty(:hasVarSet_Val)
FunctionalObjectProperty(:hasVarSet_Val)
EquivalentClasses(:VarSet ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasVarSet_Val :ArithmeticExpression)
  ObjectAllValuesFrom (:hasVarSet_Val :ArithmeticExpression)))

Declaration(ObjectProperty(:hadByVal_VarSet))
InverseObjectProperties(:hasVarSet_Val
                        :hadByVal_VarSet)
ObjectPropertyDomain(:hadByVal_VarSet :ArithmeticExpression)
ObjectPropertyRange(:hadByVal_VarSet :VarSet)



Declaration(Class(:DataThing))

AnnotationAssertion(rdfs:comment :DataThing
  "An instance of DataThing has the following:
    .
 
  DataThing is an abstract type from which more specific types
  of data thing are derived. That includes all complex data
  types such as Vector, PhysicalLocation, etc.")

SubClassOf(:ArithmeticExpression :DataThing)
SubClassOf(:BooleanExpression :DataThing)
SubClassOf(:Else :DataThing)
SubClassOf(:KittingPlan :DataThing)
SubClassOf(:NumberedPlanElement :DataThing)
SubClassOf(:PhysicalLocation :DataThing)
SubClassOf(:PlanElementBase :DataThing)
SubClassOf(:Point :DataThing)
SubClassOf(:StepWithPredecessors :DataThing)
SubClassOf(:TestAndStep :DataThing)
SubClassOf(:VariableDeclaration :DataThing)
SubClassOf(:Vector :DataThing)
DisjointUnion(:DataThing
              :ArithmeticExpression
              :BooleanExpression
              :Else
              :KittingPlan
              :NumberedPlanElement
              :PhysicalLocation
              :PlanElementBase
              :Point
              :StepWithPredecessors
              :TestAndStep
              :VariableDeclaration
              :Vector)



Declaration(Class(:PhysicalLocation))

AnnotationAssertion(rdfs:comment :PhysicalLocation
  "PhysicalLocation is derived from DataThing.
  An instance of PhysicalLocation has the following:
    RefObjectName
    Timestamp (optional).
 
  PhysicalLocation is an abstract type from which more specific
  types of physical location are derived. A PhysicalLocation says
  where a SolidObject is relative to its reference object.
  Timestamp represents the most recent date and time when the
  location was updated.")

SubClassOf(:PoseLocation :PhysicalLocation)
SubClassOf(:RelativeLocation :PhysicalLocation)
DisjointUnion(:PhysicalLocation
              :PoseLocation
              :RelativeLocation)

Declaration(DataProperty(:hasPhysicalLocation_RefObjectName))
DataPropertyDomain(:hasPhysicalLocation_RefObjectName :PhysicalLocation)
DataPropertyRange(:hasPhysicalLocation_RefObjectName xsd:NMTOKEN)
FunctionalDataProperty(:hasPhysicalLocation_RefObjectName)
EquivalentClasses(:PhysicalLocation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPhysicalLocation_RefObjectName xsd:NMTOKEN)
  DataAllValuesFrom (:hasPhysicalLocation_RefObjectName xsd:NMTOKEN)))



Declaration(Class(:Point))

AnnotationAssertion(rdfs:comment :Point
  "Point is derived from DataThing.
  An instance of Point has the following:
    X
    Y
    Z.
 
  The X, Y, and Z elements are the Cartesian coordinates of the Point.")

Declaration(DataProperty(:hasPoint_X))
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyRange(:hasPoint_X xsd:decimal)
FunctionalDataProperty(:hasPoint_X)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_X xsd:decimal)
  DataAllValuesFrom (:hasPoint_X xsd:decimal)))

Declaration(DataProperty(:hasPoint_Y))
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyRange(:hasPoint_Y xsd:decimal)
FunctionalDataProperty(:hasPoint_Y)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Y xsd:decimal)
  DataAllValuesFrom (:hasPoint_Y xsd:decimal)))

Declaration(DataProperty(:hasPoint_Z))
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyRange(:hasPoint_Z xsd:decimal)
FunctionalDataProperty(:hasPoint_Z)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Z xsd:decimal)
  DataAllValuesFrom (:hasPoint_Z xsd:decimal)))



Declaration(Class(:PoseLocation))

AnnotationAssertion(rdfs:comment :PoseLocation
  "PoseLocation is derived from PhysicalLocation.
  An instance of PoseLocation has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional).
    Point
    XAxis
    ZAxis 
    PositionStandardDeviation (optional)
    OrientationStandardDeviation (optional).
 
  PoseLocation is an abstract type from which more specific types
  of pose location are derived. The Point locates the origin of a
  coordinate system. The XAxis and ZAxis give the orientation of the
  coordinate system. The data for the Point, the ZAxis and the XAxis
  are expressed relative to the coordinate system of the reference
  object.
 
  The PositionStandardDeviation is based on a normal distribution of
  actual position about its given value. Thus, for example, the
  actual position is expected to be within the given
  PositionStandardDeviation amount 68% of the time and within twice
  the given amount 95% of the time. The PositionStandardDeviation is
  measured in the length units being used.
 
  The OrientationStandardDeviation is based on a normal distribution
  of orientation about its given value. The error is to be measured
  as the angle of rotation about a single axis needed to rotate a
  solid object from its stated orientation to its actual orientation.
  The OrientationStandardDeviation is measured in the angle units
  being used.")

SubClassOf(:PoseLocationIn :PoseLocation)
SubClassOf(:PoseLocationOn :PoseLocation)
SubClassOf(:PoseOnlyLocation :PoseLocation)
DisjointUnion(:PoseLocation
              :PoseLocationIn
              :PoseLocationOn
              :PoseOnlyLocation)

Declaration(ObjectProperty(:hasPoseLocation_Point))
ObjectPropertyDomain(:hasPoseLocation_Point :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_Point :Point)
InverseFunctionalObjectProperty(:hasPoseLocation_Point)
FunctionalObjectProperty(:hasPoseLocation_Point)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_Point :Point)
  ObjectAllValuesFrom (:hasPoseLocation_Point :Point)))

Declaration(ObjectProperty(:hadByPoint_PoseLocation))
InverseObjectProperties(:hasPoseLocation_Point
                        :hadByPoint_PoseLocation)
ObjectPropertyDomain(:hadByPoint_PoseLocation :Point)
ObjectPropertyRange(:hadByPoint_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_XAxis))
ObjectPropertyDomain(:hasPoseLocation_XAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_XAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_XAxis)
FunctionalObjectProperty(:hasPoseLocation_XAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_XAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_XAxis :Vector)))

Declaration(ObjectProperty(:hadByXAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_XAxis
                        :hadByXAxis_PoseLocation)
ObjectPropertyDomain(:hadByXAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByXAxis_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_ZAxis))
ObjectPropertyDomain(:hasPoseLocation_ZAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_ZAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_ZAxis)
FunctionalObjectProperty(:hasPoseLocation_ZAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_ZAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_ZAxis :Vector)))

Declaration(ObjectProperty(:hadByZAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_ZAxis
                        :hadByZAxis_PoseLocation)
ObjectPropertyDomain(:hadByZAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByZAxis_PoseLocation :PoseLocation)

Declaration(DataProperty(:hasPoseLocation_PositionStandardDeviation))
DataPropertyDomain(:hasPoseLocation_PositionStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_PositionStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_PositionStandardDeviation)

Declaration(DataProperty(:hasPoseLocation_OrientationStandardDeviation))
DataPropertyDomain(:hasPoseLocation_OrientationStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_OrientationStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_OrientationStandardDeviation)



Declaration(Class(:PoseLocationIn))

AnnotationAssertion(rdfs:comment :PoseLocationIn
  "PoseLocationIn is derived from PoseLocation.
  An instance of PoseLocationIn has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  A PoseLocationIn indicates that the object is inside
  the location-parent. The notion of 'inside' is vague and might be
  made more precise.")



Declaration(Class(:PoseLocationOn))

AnnotationAssertion(rdfs:comment :PoseLocationOn
  "PoseLocationOn is derived from PoseLocation.
  An instance of PoseLocationOn has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  A PoseLocationOn indicates that the Object is on top of the
  location-parent. The notion of 'on top of' is vague and might be
  made more precise.")



Declaration(Class(:PoseOnlyLocation))

AnnotationAssertion(rdfs:comment :PoseOnlyLocation
  "PoseOnlyLocation is derived from PoseLocation.
  An instance of PoseOnlyLocation has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  An object located by a PoseOnlyLocation may or may not be
  inside or on top of the reference object of the
  PoseOnlyLocation.")



Declaration(Class(:RelativeLocation))

AnnotationAssertion(rdfs:comment :RelativeLocation
  "RelativeLocation is derived from PhysicalLocation.
  An instance of RelativeLocation has a the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional)
    Description.
 
  RelativeLocation is an abstract type from which more specific
  types of relative location are derived. A RelativeLocation
  indicates that the SolidObject that has the
  RelativeLocation is on or in the RefObject. The Description may
  be used to describe the relative positions of the object and its
  reference object.")

SubClassOf(:RelativeLocationIn :RelativeLocation)
SubClassOf(:RelativeLocationOn :RelativeLocation)
DisjointUnion(:RelativeLocation
              :RelativeLocationIn
              :RelativeLocationOn)

Declaration(DataProperty(:hasRelativeLocation_Description))
DataPropertyDomain(:hasRelativeLocation_Description :RelativeLocation)
DataPropertyRange(:hasRelativeLocation_Description xsd:string)
FunctionalDataProperty(:hasRelativeLocation_Description)
EquivalentClasses(:RelativeLocation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRelativeLocation_Description xsd:string)
  DataAllValuesFrom (:hasRelativeLocation_Description xsd:string)))



Declaration(Class(:RelativeLocationIn))

AnnotationAssertion(rdfs:comment :RelativeLocationIn
  "RelativeLocationIn is derived from RelativeLocation.
  An instance of RelativeLocationIn has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional)
    Description (inherited).
 
  A RelativeLocationIn indicates that the SolidObject that
  has the RelativeLocation is in the RefObject. The notion of
  'in' is vague and might be made more precise.")



Declaration(Class(:RelativeLocationOn))

AnnotationAssertion(rdfs:comment :RelativeLocationOn
  "RelativeLocationOn is derived from RelativeLocation.
  An instance of RelativeLocationOn has the following:
    RefObjectName (inherited)
    Timestamp (inherited, optional)
    Description (inherited).
 
  A RelativeLocationOn indicates that the SolidObject that
  has the RelativeLocation is on top of the the RefObject. The
  notion of 'on top of' is vague and might be made more precise.")



Declaration(Class(:Vector))

AnnotationAssertion(rdfs:comment :Vector
  "Vector is derived from DataThing.
  An instance of Vector has the following:
    I
    J
    K.
 
  I, J, and K represent the usual i, j, and k components of a 3D
  vector.")

Declaration(DataProperty(:hasVector_I))
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyRange(:hasVector_I xsd:decimal)
FunctionalDataProperty(:hasVector_I)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_I xsd:decimal)
  DataAllValuesFrom (:hasVector_I xsd:decimal)))

Declaration(DataProperty(:hasVector_J))
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyRange(:hasVector_J xsd:decimal)
FunctionalDataProperty(:hasVector_J)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_J xsd:decimal)
  DataAllValuesFrom (:hasVector_J xsd:decimal)))

Declaration(DataProperty(:hasVector_K))
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyRange(:hasVector_K xsd:decimal)
FunctionalDataProperty(:hasVector_K)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_K xsd:decimal)
  DataAllValuesFrom (:hasVector_K xsd:decimal)))
)
