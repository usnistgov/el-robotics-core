Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingWorkstationClasses.owl#>)

Ontology(<http://www.nist.gov/el/ontologies/kittingWorkstationClasses.owl>

Annotation(rdfs:comment
  "This kitting ontology models a kitting workstation including objects
      in the workstation and data associated with the workstation. The
      ontology assumes coordinate systems are right handed. For objects
      such as trays or a robot with a preferred orientation with respect to
      gravity, the Z axis points up (opposite the pull of gravity).")



DatatypeDefinition(:angleUnit 
  DataOneOf("degree" "radian"))

DatatypeDefinition(:lengthUnit 
  DataOneOf("meter" "millimeter" "inch"))

DatatypeDefinition(:positiveDecimal 
  DatatypeRestriction(xsd:decimal xsd:minExclusive "0"^^xsd:decimal))

DatatypeDefinition(:weightUnit 
  DataOneOf("kilogram" "gram" "milligram" "ounce" "pound"))



Declaration(Class(:BoxVolume))

AnnotationAssertion(rdfs:comment :BoxVolume
  "BoxVolume is derived from DataThing.
  An instance of BoxVolume has the following:
    MaximumPoint
    MinimumPoint.
 
  The MaximumPoint and MinimumPoint are diagonally opposite corner
  points of a box shaped volume whose edges are aligned with the
  coordinate system in which the BoxVolume is located. The
  MinimumPoint has the minimum values of X, Y, and Z. The
  MaximumPoint has the maximum values of X, Y, and Z.")

Declaration(ObjectProperty(:hasBoxVolume_MaximumPoint))
ObjectPropertyDomain(:hasBoxVolume_MaximumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MaximumPoint :Point)
InverseFunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
FunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
EquivalentClasses(:BoxVolume ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBoxVolume_MaximumPoint :Point)
  ObjectAllValuesFrom (:hasBoxVolume_MaximumPoint :Point)))

Declaration(ObjectProperty(:hadByMaximumPoint_BoxVolume))
InverseObjectProperties(:hasBoxVolume_MaximumPoint
                        :hadByMaximumPoint_BoxVolume)
ObjectPropertyDomain(:hadByMaximumPoint_BoxVolume :Point)
ObjectPropertyRange(:hadByMaximumPoint_BoxVolume :BoxVolume)

Declaration(ObjectProperty(:hasBoxVolume_MinimumPoint))
ObjectPropertyDomain(:hasBoxVolume_MinimumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MinimumPoint :Point)
InverseFunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
FunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
EquivalentClasses(:BoxVolume ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasBoxVolume_MinimumPoint :Point)
  ObjectAllValuesFrom (:hasBoxVolume_MinimumPoint :Point)))

Declaration(ObjectProperty(:hadByMinimumPoint_BoxVolume))
InverseObjectProperties(:hasBoxVolume_MinimumPoint
                        :hadByMinimumPoint_BoxVolume)
ObjectPropertyDomain(:hadByMinimumPoint_BoxVolume :Point)
ObjectPropertyRange(:hadByMinimumPoint_BoxVolume :BoxVolume)



Declaration(Class(:BoxyShape))

AnnotationAssertion(rdfs:comment :BoxyShape
  "BoxyShape is derived from InternalShape.
  An instance of BoxyShape has the following:
    Description (inherited)
    GraspPose (inherited, optional)
    Length
    Width
    Height
    HasTop.
 
  A BoxyShape is box shaped. The Length is larger of the two
  dimensions that are not the Height. The Width is smaller of the two
  dimensions that are not the Height. The coordinate system of a
  BoxyShape (i.e. the thing that is located and oriented by a
  Pose) has its origin in the middle of the bottom, its Z-axis
  parallel to the height sides and pointing into the box, and its
  X-axis parallel to the length sides. If HasTop is true, the top of
  the box (i.e. the side through which the +Z axis passes) exists and
  is closed. If HasTop is false, the box has no top.")

Declaration(DataProperty(:hasBoxyShape_Length))
DataPropertyDomain(:hasBoxyShape_Length :BoxyShape)
DataPropertyRange(:hasBoxyShape_Length :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Length)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Length :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Length :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_Width))
DataPropertyDomain(:hasBoxyShape_Width :BoxyShape)
DataPropertyRange(:hasBoxyShape_Width :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Width)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Width :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Width :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_Height))
DataPropertyDomain(:hasBoxyShape_Height :BoxyShape)
DataPropertyRange(:hasBoxyShape_Height :positiveDecimal)
FunctionalDataProperty(:hasBoxyShape_Height)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_Height :positiveDecimal)
  DataAllValuesFrom (:hasBoxyShape_Height :positiveDecimal)))

Declaration(DataProperty(:hasBoxyShape_HasTop))
DataPropertyDomain(:hasBoxyShape_HasTop :BoxyShape)
DataPropertyRange(:hasBoxyShape_HasTop xsd:boolean)
FunctionalDataProperty(:hasBoxyShape_HasTop)
EquivalentClasses(:BoxyShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasBoxyShape_HasTop xsd:boolean)
  DataAllValuesFrom (:hasBoxyShape_HasTop xsd:boolean)))



Declaration(Class(:CylindricalShape))

AnnotationAssertion(rdfs:comment :CylindricalShape
  "CylindricalShape is derived from InternalShape.
  An instance of CylindricalShape has the following:
    Description (inherited)
    GraspPose (inherited, optional)
    Diameter
    Height
    HasTop.
 
  The cylinder is a right circular cylinder with a circular base
  having the given Diameter. The axis is perpendicular to the base.
  The base is always a surface that is part of the cylinder. The
  sides of the cylinder stop at the given Height as if cut by a plane
  perpendicular to the axis. The coordinate system of a
  CylindricalShape (i.e. the thing that is located and oriented by
  a pose) has its origin in the middle of the bottom, and its Z-axis
  on the axis of the cylinder. If HasTop is true, the top of the
  cylinder (i.e. the side through which the +Z axis passes) exists
  and is closed. If HasTop is false, the cylinder has no top.")

Declaration(DataProperty(:hasCylindricalShape_Diameter))
DataPropertyDomain(:hasCylindricalShape_Diameter :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_Diameter :positiveDecimal)
FunctionalDataProperty(:hasCylindricalShape_Diameter)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_Diameter :positiveDecimal)
  DataAllValuesFrom (:hasCylindricalShape_Diameter :positiveDecimal)))

Declaration(DataProperty(:hasCylindricalShape_Height))
DataPropertyDomain(:hasCylindricalShape_Height :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_Height :positiveDecimal)
FunctionalDataProperty(:hasCylindricalShape_Height)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_Height :positiveDecimal)
  DataAllValuesFrom (:hasCylindricalShape_Height :positiveDecimal)))

Declaration(DataProperty(:hasCylindricalShape_HasTop))
DataPropertyDomain(:hasCylindricalShape_HasTop :CylindricalShape)
DataPropertyRange(:hasCylindricalShape_HasTop xsd:boolean)
FunctionalDataProperty(:hasCylindricalShape_HasTop)
EquivalentClasses(:CylindricalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasCylindricalShape_HasTop xsd:boolean)
  DataAllValuesFrom (:hasCylindricalShape_HasTop xsd:boolean)))



Declaration(Class(:DataThing))

AnnotationAssertion(rdfs:comment :DataThing
  "An instance of DataThing has the following:
    .
  DataThing is an abstract type from which more specific types
  of data thing are derived. That includes all complex data
  types such as Vector, PhysicalLocation, etc.")

SubClassOf(:BoxVolume :DataThing)
SubClassOf(:KitDesign :DataThing)
SubClassOf(:PartRefAndPose :DataThing)
SubClassOf(:PhysicalLocation :DataThing)
SubClassOf(:Point :DataThing)
SubClassOf(:ShapeDesign :DataThing)
SubClassOf(:Slot :DataThing)
SubClassOf(:StockKeepingUnit :DataThing)
SubClassOf(:Vector :DataThing)
DisjointUnion(:DataThing
              :BoxVolume
              :KitDesign
              :PartRefAndPose
              :PhysicalLocation
              :Point
              :ShapeDesign
              :Slot
              :StockKeepingUnit
              :Vector)



Declaration(Class(:EndEffector))

AnnotationAssertion(rdfs:comment :EndEffector
  "EndEffector is derived from NoSkuObject.
  An instance of EndEffector has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description
    Weight
    MaximumLoadWeight
    HeldObject (optional).
 
  EndEffector is an abstract type from which more specific types
  of end effector are derived. An EndEffector is an end effector
  for a robot. The optional HeldObject is for the object being held
  by the end effector, if the end effector is holding an object.
  Every EndEffector is either a GripperEffector or a
  VacuumEffector. Every EndEffector in a KittingWorkstation
  is either attached to the end of a robot arm or sitting in an
  EndEffectorHolder at an EndEffectorChangingStation.")

SubClassOf(:GripperEffector :EndEffector)
SubClassOf(:VacuumEffector :EndEffector)
DisjointUnion(:EndEffector
              :GripperEffector
              :VacuumEffector)

Declaration(DataProperty(:hasEndEffector_Description))
DataPropertyDomain(:hasEndEffector_Description :EndEffector)
DataPropertyRange(:hasEndEffector_Description xsd:string)
FunctionalDataProperty(:hasEndEffector_Description)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_Description xsd:string)
  DataAllValuesFrom (:hasEndEffector_Description xsd:string)))

Declaration(DataProperty(:hasEndEffector_Weight))
DataPropertyDomain(:hasEndEffector_Weight :EndEffector)
DataPropertyRange(:hasEndEffector_Weight :positiveDecimal)
FunctionalDataProperty(:hasEndEffector_Weight)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_Weight :positiveDecimal)
  DataAllValuesFrom (:hasEndEffector_Weight :positiveDecimal)))

Declaration(DataProperty(:hasEndEffector_MaximumLoadWeight))
DataPropertyDomain(:hasEndEffector_MaximumLoadWeight :EndEffector)
DataPropertyRange(:hasEndEffector_MaximumLoadWeight :positiveDecimal)
FunctionalDataProperty(:hasEndEffector_MaximumLoadWeight)
EquivalentClasses(:EndEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasEndEffector_MaximumLoadWeight :positiveDecimal)
  DataAllValuesFrom (:hasEndEffector_MaximumLoadWeight :positiveDecimal)))

Declaration(ObjectProperty(:hasEndEffector_HeldObject))
ObjectPropertyDomain(:hasEndEffector_HeldObject :EndEffector)
ObjectPropertyRange(:hasEndEffector_HeldObject :SolidObject)
InverseFunctionalObjectProperty(:hasEndEffector_HeldObject)
FunctionalObjectProperty(:hasEndEffector_HeldObject)

Declaration(ObjectProperty(:hadByHeldObject_EndEffector))
InverseObjectProperties(:hasEndEffector_HeldObject
                        :hadByHeldObject_EndEffector)
ObjectPropertyDomain(:hadByHeldObject_EndEffector :SolidObject)
ObjectPropertyRange(:hadByHeldObject_EndEffector :EndEffector)



Declaration(Class(:EndEffectorChangingStation))

AnnotationAssertion(rdfs:comment :EndEffectorChangingStation
  "EndEffectorChangingStation is derived from NoSkuObject.
  An instance of EndEffectorChangingStation has the
  following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Base
    EndEffectorHolder (multiple).
 
  An EndEffectorChangingStation is a place where end effectors
  are stored and where the robot can change end effectors. The
  coordinate system of an EndEffectorChangingStation is in the
  same place as the coordinate system of its Base. The shape of an
  EndEffectorChangingStation may also be found from the shapes of
  the Base and the EndEffectorHolders and their relative positions.")

Declaration(ObjectProperty(:hasEndEffectorChangingStation_Base))
ObjectPropertyDomain(:hasEndEffectorChangingStation_Base :EndEffectorChangingStation)
ObjectPropertyRange(:hasEndEffectorChangingStation_Base :MechanicalComponent)
InverseFunctionalObjectProperty(:hasEndEffectorChangingStation_Base)
FunctionalObjectProperty(:hasEndEffectorChangingStation_Base)
EquivalentClasses(:EndEffectorChangingStation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasEndEffectorChangingStation_Base :MechanicalComponent)
  ObjectAllValuesFrom (:hasEndEffectorChangingStation_Base :MechanicalComponent)))

Declaration(ObjectProperty(:hadByBase_EndEffectorChangingStation))
InverseObjectProperties(:hasEndEffectorChangingStation_Base
                        :hadByBase_EndEffectorChangingStation)
ObjectPropertyDomain(:hadByBase_EndEffectorChangingStation :MechanicalComponent)
ObjectPropertyRange(:hadByBase_EndEffectorChangingStation :EndEffectorChangingStation)

Declaration(ObjectProperty(:hasEndEffectorChangingStation_EndEffectorHolder))
ObjectPropertyDomain(:hasEndEffectorChangingStation_EndEffectorHolder :EndEffectorChangingStation)
ObjectPropertyRange(:hasEndEffectorChangingStation_EndEffectorHolder :EndEffectorHolder)
InverseFunctionalObjectProperty(:hasEndEffectorChangingStation_EndEffectorHolder)

Declaration(ObjectProperty(:hadByEndEffectorHolder_EndEffectorChangingStation))
InverseObjectProperties(:hasEndEffectorChangingStation_EndEffectorHolder
                        :hadByEndEffectorHolder_EndEffectorChangingStation)
ObjectPropertyDomain(:hadByEndEffectorHolder_EndEffectorChangingStation :EndEffectorHolder)
ObjectPropertyRange(:hadByEndEffectorHolder_EndEffectorChangingStation :EndEffectorChangingStation)



Declaration(Class(:EndEffectorHolder))

AnnotationAssertion(rdfs:comment :EndEffectorHolder
  "EndEffectorHolder is derived from NoSkuObject.
  An instance of EndEffectorHolder has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    EndEffector (optional).
 
  An EndEffectorHolder holds zero or one end effector and is part
  of an EndEffectorChangingStation.")

Declaration(ObjectProperty(:hasEndEffectorHolder_EndEffector))
ObjectPropertyDomain(:hasEndEffectorHolder_EndEffector :EndEffectorHolder)
ObjectPropertyRange(:hasEndEffectorHolder_EndEffector :EndEffector)
InverseFunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
FunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)

Declaration(ObjectProperty(:hadByEndEffector_EndEffectorHolder))
InverseObjectProperties(:hasEndEffectorHolder_EndEffector
                        :hadByEndEffector_EndEffectorHolder)
ObjectPropertyDomain(:hadByEndEffector_EndEffectorHolder :EndEffector)
ObjectPropertyRange(:hadByEndEffector_EndEffectorHolder :EndEffectorHolder)



Declaration(Class(:ExternalShape))

AnnotationAssertion(rdfs:comment :ExternalShape
  "ExternalShape is derived from ShapeDesign.
  An instance of ExternalShape has the following:
    Description (inherited)
    GraspPose (inherited, optional)
    ModelFormatName
    ModelFileName
    ModelName (optional).
 
  An ExternalShape is a shape defined in an external file. The
  ModelFormatName is the name of the format of model (for example,
  'STEP Advanced Brep' or 'USARSim'). The ModelFileName is the name
  of the file containing the model and may include a path (for
  example 'partFiles/STEP/ANC101.stp'). The model file may contain
  more than one shape model. The ModelName is optional and is the
  name of a model within the model file. The ModelName is necessary
  if the model file contains more than one model.")

Declaration(DataProperty(:hasExternalShape_ModelFormatName))
DataPropertyDomain(:hasExternalShape_ModelFormatName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelFormatName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelFormatName)
EquivalentClasses(:ExternalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasExternalShape_ModelFormatName xsd:string)
  DataAllValuesFrom (:hasExternalShape_ModelFormatName xsd:string)))

Declaration(DataProperty(:hasExternalShape_ModelFileName))
DataPropertyDomain(:hasExternalShape_ModelFileName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelFileName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelFileName)
EquivalentClasses(:ExternalShape ObjectIntersectionOf(
  DataSomeValuesFrom(:hasExternalShape_ModelFileName xsd:string)
  DataAllValuesFrom (:hasExternalShape_ModelFileName xsd:string)))

Declaration(DataProperty(:hasExternalShape_ModelName))
DataPropertyDomain(:hasExternalShape_ModelName :ExternalShape)
DataPropertyRange(:hasExternalShape_ModelName xsd:string)
FunctionalDataProperty(:hasExternalShape_ModelName)



Declaration(Class(:GripperEffector))

AnnotationAssertion(rdfs:comment :GripperEffector
  "GripperEffector is derived from EndEffector.
  An instance of GripperEffector has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description (inherited)
    Weight (inherited)
    MaximumLoadWeight (inherited)
    HeldObject (inherited, optional).
 
  A GripperEffector holds an object by gripping
  it with fingers or claws or by suction.")



Declaration(Class(:Human))

AnnotationAssertion(rdfs:comment :Human
  "Human is derived from NoSkuObject.
  An instance of Human has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional).
 
  A Human is a type representing a human being. The shape of
  a human is the shape of a bounding box (or other bounding shape)
  that encloses the human completely.")



Declaration(Class(:InternalShape))

AnnotationAssertion(rdfs:comment :InternalShape
  "InternalShape is derived from ShapeDesign.
  An instance of InternalShape has the following:
    Description (inherited)
    GraspPose (inherited, optional).
 
  InternalShape is an abstract type from which more specific
  types of shape are derived. Instances of InternalShape in a
  instance file contain information about the appearance of the
  shape without referring to another file.")

SubClassOf(:BoxyShape :InternalShape)
SubClassOf(:CylindricalShape :InternalShape)
DisjointUnion(:InternalShape
              :BoxyShape
              :CylindricalShape)



Declaration(Class(:Kit))

AnnotationAssertion(rdfs:comment :Kit
  "Kit is derived from NoSkuObject.
  An instance of Kit has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Design
    KitTray
    Finished
    Part (optional, multiple)
    Slot (optional, multiple).
 
  Finished is a boolean indicator of whether the Kit is finished.
 
  Part may occur several times (once for each part in the kit).
 
  The optional Slots may be used to keep track of whether each place
  in the kit that should have a part on it does have a part on it.
  The PartRefAndPose of each Slot should indicate a
  PartRefAndPose in the design of the kit (different for each slot).
 
  The locating point of the Tray in the kit should be (0,0,0), and
  its X and Z axes should be (1,0,0) and (0,0,1), respectively.")


Declaration(ObjectProperty(:hasKit_Design))
ObjectPropertyDomain(:hasKit_Design :Kit)
ObjectPropertyRange(:hasKit_Design :KitDesign)
FunctionalObjectProperty(:hasKit_Design)
EquivalentClasses(:Kit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKit_Design :KitDesign)
  ObjectAllValuesFrom (:hasKit_Design :KitDesign)))

HasKey(:KitTray (:hasSkuObject_Sku) (:hasKitTray_SerialNumber))

Declaration(ObjectProperty(:hasKit_KitTray))
ObjectPropertyDomain(:hasKit_KitTray :Kit)
ObjectPropertyRange(:hasKit_KitTray :KitTray)
InverseFunctionalObjectProperty(:hasKit_KitTray)
FunctionalObjectProperty(:hasKit_KitTray)
EquivalentClasses(:Kit ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKit_KitTray :KitTray)
  ObjectAllValuesFrom (:hasKit_KitTray :KitTray)))

Declaration(ObjectProperty(:hadByKitTray_Kit))
InverseObjectProperties(:hasKit_KitTray
                        :hadByKitTray_Kit)
ObjectPropertyDomain(:hadByKitTray_Kit :KitTray)
ObjectPropertyRange(:hadByKitTray_Kit :Kit)

HasKey(:Part (:hasSkuObject_Sku) (:hasPart_SerialNumber))

Declaration(ObjectProperty(:hasKit_Part))
ObjectPropertyDomain(:hasKit_Part :Kit)
ObjectPropertyRange(:hasKit_Part :Part)
InverseFunctionalObjectProperty(:hasKit_Part)

Declaration(ObjectProperty(:hadByPart_Kit))
InverseObjectProperties(:hasKit_Part
                        :hadByPart_Kit)
ObjectPropertyDomain(:hadByPart_Kit :Part)
ObjectPropertyRange(:hadByPart_Kit :Kit)

Declaration(ObjectProperty(:hasKit_Slot))
ObjectPropertyDomain(:hasKit_Slot :Kit)
ObjectPropertyRange(:hasKit_Slot :Slot)
InverseFunctionalObjectProperty(:hasKit_Slot)

Declaration(ObjectProperty(:hadBySlot_Kit))
InverseObjectProperties(:hasKit_Slot
                        :hadBySlot_Kit)
ObjectPropertyDomain(:hadBySlot_Kit :Slot)
ObjectPropertyRange(:hadBySlot_Kit :Kit)

Declaration(DataProperty(:hasKit_Finished))
DataPropertyDomain(:hasKit_Finished :Kit)
DataPropertyRange(:hasKit_Finished xsd:boolean)
FunctionalDataProperty(:hasKit_Finished)
EquivalentClasses(:Kit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKit_Finished xsd:boolean)
  DataAllValuesFrom (:hasKit_Finished xsd:boolean)))



Declaration(Class(:KitDesign))

AnnotationAssertion(rdfs:comment :KitDesign
  "KitDesign is derived from DataThing.
  An instance of KitDesign has the following:
    KitTraySku
    PartRefAndPose (multiple).
 
  The KitTraySku identifies a type of kit tray. The Pose
  in a PartRefAndPose is the location of the part relative to the
  coordinate system of the ShapeDesign of the tray.")


Declaration(ObjectProperty(:hasKitDesign_KitTraySku))
ObjectPropertyDomain(:hasKitDesign_KitTraySku :KitDesign)
ObjectPropertyRange(:hasKitDesign_KitTraySku :StockKeepingUnit)
FunctionalObjectProperty(:hasKitDesign_KitTraySku)
EquivalentClasses(:KitDesign ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKitDesign_KitTraySku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasKitDesign_KitTraySku :StockKeepingUnit)))

Declaration(ObjectProperty(:hasKitDesign_PartRefAndPose))
ObjectPropertyDomain(:hasKitDesign_PartRefAndPose :KitDesign)
ObjectPropertyRange(:hasKitDesign_PartRefAndPose :PartRefAndPose)
InverseFunctionalObjectProperty(:hasKitDesign_PartRefAndPose)

Declaration(ObjectProperty(:hadByPartRefAndPose_KitDesign))
InverseObjectProperties(:hasKitDesign_PartRefAndPose
                        :hadByPartRefAndPose_KitDesign)
ObjectPropertyDomain(:hadByPartRefAndPose_KitDesign :PartRefAndPose)
ObjectPropertyRange(:hadByPartRefAndPose_KitDesign :KitDesign)



Declaration(Class(:KittingWorkstation))

AnnotationAssertion(rdfs:comment :KittingWorkstation
  "KittingWorkstation is derived from NoSkuObject.
  An instance of KittingWorkstation has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    AngleUnit
    LengthUnit
    ChangingStation
    Object (multiple)
    OtherObstacle (optional, multiple)
    Robot
    KitDesign (multiple)
    Sku (multiple)
    WeightUnit.
 
  All angle, length, and weight values related to the workstation
  use the units implicitly.
 
  The workstation includes one robot and one end effector changing
  station. There may be many instances of Object in the workstation,
  including such things as work tables, large boxes with kits,
  large boxes with empty kit trays, and parts trays.
 
  The collection of instances of KitDesign is a library of all kit
  designs known to the workstation.
 
  The collection of instances of Sku is a library of all stock
  keeping units known to the workstation.
 
  The OtherObstacles are obstacles to robot motion of unspecified
  type.
 
  Containers of various sorts enter and leave the workstation. The
  robot builds kits of parts by executing kitting plans as directed
  by a kitting plan execution system.
 
  The location of each instance of KittingWorkstation should be given
  relative to itself in order to end the chain of relative locations.")

Declaration(DataProperty(:hasKittingWorkstation_AngleUnit))
DataPropertyDomain(:hasKittingWorkstation_AngleUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_AngleUnit :angleUnit)
FunctionalDataProperty(:hasKittingWorkstation_AngleUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_AngleUnit :angleUnit)
  DataAllValuesFrom (:hasKittingWorkstation_AngleUnit :angleUnit)))

Declaration(ObjectProperty(:hasKittingWorkstation_ChangingStation))
ObjectPropertyDomain(:hasKittingWorkstation_ChangingStation :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)
InverseFunctionalObjectProperty(:hasKittingWorkstation_ChangingStation)
FunctionalObjectProperty(:hasKittingWorkstation_ChangingStation)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)
  ObjectAllValuesFrom (:hasKittingWorkstation_ChangingStation :EndEffectorChangingStation)))

Declaration(ObjectProperty(:hadByChangingStation_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_ChangingStation
                        :hadByChangingStation_KittingWorkstation)
ObjectPropertyDomain(:hadByChangingStation_KittingWorkstation :EndEffectorChangingStation)
ObjectPropertyRange(:hadByChangingStation_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_KitDesign))
ObjectPropertyDomain(:hasKittingWorkstation_KitDesign :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_KitDesign :KitDesign)
InverseFunctionalObjectProperty(:hasKittingWorkstation_KitDesign)

Declaration(ObjectProperty(:hadByKitDesign_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_KitDesign
                        :hadByKitDesign_KittingWorkstation)
ObjectPropertyDomain(:hadByKitDesign_KittingWorkstation :KitDesign)
ObjectPropertyRange(:hadByKitDesign_KittingWorkstation :KittingWorkstation)

Declaration(DataProperty(:hasKittingWorkstation_LengthUnit))
DataPropertyDomain(:hasKittingWorkstation_LengthUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_LengthUnit :lengthUnit)
FunctionalDataProperty(:hasKittingWorkstation_LengthUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_LengthUnit :lengthUnit)
  DataAllValuesFrom (:hasKittingWorkstation_LengthUnit :lengthUnit)))

Declaration(ObjectProperty(:hasKittingWorkstation_Object))
ObjectPropertyDomain(:hasKittingWorkstation_Object :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Object :SolidObject)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Object)

Declaration(ObjectProperty(:hadByObject_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Object
                        :hadByObject_KittingWorkstation)
ObjectPropertyDomain(:hadByObject_KittingWorkstation :SolidObject)
ObjectPropertyRange(:hadByObject_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_OtherObstacle))
ObjectPropertyDomain(:hasKittingWorkstation_OtherObstacle :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_OtherObstacle :BoxVolume)
InverseFunctionalObjectProperty(:hasKittingWorkstation_OtherObstacle)

Declaration(ObjectProperty(:hadByOtherObstacle_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_OtherObstacle
                        :hadByOtherObstacle_KittingWorkstation)
ObjectPropertyDomain(:hadByOtherObstacle_KittingWorkstation :BoxVolume)
ObjectPropertyRange(:hadByOtherObstacle_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_Robot))
ObjectPropertyDomain(:hasKittingWorkstation_Robot :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Robot :Robot)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Robot)
FunctionalObjectProperty(:hasKittingWorkstation_Robot)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasKittingWorkstation_Robot :Robot)
  ObjectAllValuesFrom (:hasKittingWorkstation_Robot :Robot)))

Declaration(ObjectProperty(:hadByRobot_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Robot
                        :hadByRobot_KittingWorkstation)
ObjectPropertyDomain(:hadByRobot_KittingWorkstation :Robot)
ObjectPropertyRange(:hadByRobot_KittingWorkstation :KittingWorkstation)

Declaration(ObjectProperty(:hasKittingWorkstation_Sku))
ObjectPropertyDomain(:hasKittingWorkstation_Sku :KittingWorkstation)
ObjectPropertyRange(:hasKittingWorkstation_Sku :StockKeepingUnit)
InverseFunctionalObjectProperty(:hasKittingWorkstation_Sku)

Declaration(ObjectProperty(:hadBySku_KittingWorkstation))
InverseObjectProperties(:hasKittingWorkstation_Sku
                        :hadBySku_KittingWorkstation)
ObjectPropertyDomain(:hadBySku_KittingWorkstation :StockKeepingUnit)
ObjectPropertyRange(:hadBySku_KittingWorkstation :KittingWorkstation)

Declaration(DataProperty(:hasKittingWorkstation_WeightUnit))
DataPropertyDomain(:hasKittingWorkstation_WeightUnit :KittingWorkstation)
DataPropertyRange(:hasKittingWorkstation_WeightUnit :weightUnit)
FunctionalDataProperty(:hasKittingWorkstation_WeightUnit)
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKittingWorkstation_WeightUnit :weightUnit)
  DataAllValuesFrom (:hasKittingWorkstation_WeightUnit :weightUnit)))



Declaration(Class(:KitTray))

AnnotationAssertion(rdfs:comment :KitTray
  "KitTray is derived from SkuObject.
  An instance of KitTray has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber.
 
  The Sku specifies the SKU of the kit tray. A
  KitTray is designed to hold Parts with various SKUs in
  known positions.")

Declaration(DataProperty(:hasKitTray_SerialNumber))
DataPropertyDomain(:hasKitTray_SerialNumber :KitTray)
DataPropertyRange(:hasKitTray_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasKitTray_SerialNumber)
EquivalentClasses(:KitTray ObjectIntersectionOf(
  DataSomeValuesFrom(:hasKitTray_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasKitTray_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:LargeBoxWithEmptyKitTrays))

AnnotationAssertion(rdfs:comment :LargeBoxWithEmptyKitTrays
  "LargeBoxWithEmptyKitTrays is derived from NoSkuObject.
  An instance of LargeBoxWithEmptyKitTrays has the
  following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    LargeContainer
    KitTray (optional, multiple).
 
  The location point of the LargeContainer should be (0,0,0), its Z
  axis should be (0,0,1), and its X axis should be (1,0,0). The
  PrimaryLocation of a KitTray in a LargeBoxWithEmptyKitTrays should
  be given by a PoseLocationIn or RelativeLocationIn that
  is relative to the LargeContainer. The KitTrays in a
  LargeBoxWithEmptyKitTrays are intended to all be of the same
  SKU, although there is currently no formal requirement for that.")

HasKey(:LargeContainer (:hasSkuObject_Sku) (:hasLargeContainer_SerialNumber))

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer))
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
EquivalentClasses(:LargeBoxWithEmptyKitTrays ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)
  ObjectAllValuesFrom (:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)))

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays))
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                        :hadByLargeContainer_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTray))
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_KitTray :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_KitTray :KitTray)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTray)

Declaration(ObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays))
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_KitTray
                        :hadByKitTray_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByKitTray_LargeBoxWithEmptyKitTrays :KitTray)
ObjectPropertyRange(:hadByKitTray_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)



Declaration(Class(:LargeBoxWithKits))

AnnotationAssertion(rdfs:comment :LargeBoxWithKits
  "LargeBoxWithKits is derived from NoSkuObject.
  An instance of LargeBoxWithKits has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    LargeContainer
    Kit (optional, multiple)
    KitDesign
    Capacity.
 
  The coordinate system of a LargeBoxWithKits is in the same place as
  the coordinate system of its LargeContainer. The PrimaryLocation of
  the LargeContainer should be relative to the LargeBoxWithKits.
  The KitDesign is an identifier for a KitDesign. The
  PrimaryLocation of a Kit in a LargeBoxWithKits should be given by a
  PoseLocationIn or RelativeLocationIn that is relative to
  the LargeContainer.
 
  The Capacity is an xs:positiveInteger giving the maximum number of
  kits of the given design that can be held in the box.
 
  The Kits in a LargeBoxWithKits are intended to all be of
  the given design, but there is currently no formal constraint
  requiring that.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_LargeContainer))
ObjectPropertyDomain(:hasLargeBoxWithKits_LargeContainer :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
  ObjectAllValuesFrom (:hasLargeBoxWithKits_LargeContainer :LargeContainer)))

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithKits))
InverseObjectProperties(:hasLargeBoxWithKits_LargeContainer
                        :hadByLargeContainer_LargeBoxWithKits)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithKits :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithKits :LargeBoxWithKits)

Declaration(ObjectProperty(:hasLargeBoxWithKits_Kit))
ObjectPropertyDomain(:hasLargeBoxWithKits_Kit :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_Kit :Kit)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_Kit)

Declaration(ObjectProperty(:hadByKit_LargeBoxWithKits))
InverseObjectProperties(:hasLargeBoxWithKits_Kit
                        :hadByKit_LargeBoxWithKits)
ObjectPropertyDomain(:hadByKit_LargeBoxWithKits :Kit)
ObjectPropertyRange(:hadByKit_LargeBoxWithKits :LargeBoxWithKits)


Declaration(ObjectProperty(:hasLargeBoxWithKits_KitDesign))
ObjectPropertyDomain(:hasLargeBoxWithKits_KitDesign :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_KitDesign :KitDesign)
FunctionalObjectProperty(:hasLargeBoxWithKits_KitDesign)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasLargeBoxWithKits_KitDesign :KitDesign)
  ObjectAllValuesFrom (:hasLargeBoxWithKits_KitDesign :KitDesign)))

Declaration(DataProperty(:hasLargeBoxWithKits_Capacity))
DataPropertyDomain(:hasLargeBoxWithKits_Capacity :LargeBoxWithKits)
DataPropertyRange(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
FunctionalDataProperty(:hasLargeBoxWithKits_Capacity)
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(
  DataSomeValuesFrom(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
  DataAllValuesFrom (:hasLargeBoxWithKits_Capacity xsd:positiveInteger)))



Declaration(Class(:LargeContainer))

AnnotationAssertion(rdfs:comment :LargeContainer
  "LargeContainer is derived from SkuObject.
  An instance of LargeContainer has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber.
 
  The Sku specifies the SKU of the LargeContainer. A
  LargeContainer can hold one or more instances of a single type
  of tray, bin, or kit.")

Declaration(DataProperty(:hasLargeContainer_SerialNumber))
DataPropertyDomain(:hasLargeContainer_SerialNumber :LargeContainer)
DataPropertyRange(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasLargeContainer_SerialNumber)
EquivalentClasses(:LargeContainer ObjectIntersectionOf(
  DataSomeValuesFrom(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasLargeContainer_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:MechanicalComponent))

AnnotationAssertion(rdfs:comment :MechanicalComponent
  "MechanicalComponent is derived from NoSkuObject.
  An instance of MechanicalComponent has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional).
 
  A MechanicalComponent is a component of kitting workstation
  device such as a robot or an end effector changing station.")



Declaration(Class(:NoSkuObject))

AnnotationAssertion(rdfs:comment :NoSkuObject
  "NoSkuObject is derived from SolidObject.
  An instance NoSkuObject has the following:
    PrimaryLocation (inherited)
    SecondaryLocations (inherited, optional, multiple)
    InternalShape (optional)
    ExternalShape (optional).
 
  A SkuObject is an abstract type from which more specific types
  of solid object are derived. The InternalShape and ExternalShape
  are not required to represent the same shape, but they should not
  be inconsistent. If a NoSkuObject consists of components it may
  also get its shape from the shape of the components and their
  relative positions.")

SubClassOf(:EndEffectorChangingStation :NoSkuObject)
SubClassOf(:EndEffectorHolder :NoSkuObject)
SubClassOf(:EndEffector :NoSkuObject)
SubClassOf(:Human :NoSkuObject)
SubClassOf(:Kit :NoSkuObject)
SubClassOf(:KittingWorkstation :NoSkuObject)
SubClassOf(:LargeBoxWithEmptyKitTrays :NoSkuObject)
SubClassOf(:LargeBoxWithKits :NoSkuObject)
SubClassOf(:MechanicalComponent :NoSkuObject)
SubClassOf(:Robot :NoSkuObject)
SubClassOf(:WorkTable :NoSkuObject)
DisjointUnion(:NoSkuObject
              :EndEffectorChangingStation
              :EndEffectorHolder
              :EndEffector
              :Human
              :Kit
              :KittingWorkstation
              :LargeBoxWithEmptyKitTrays
              :LargeBoxWithKits
              :MechanicalComponent
              :Robot
              :WorkTable)

Declaration(ObjectProperty(:hasNoSkuObject_InternalShape))
ObjectPropertyDomain(:hasNoSkuObject_InternalShape :NoSkuObject)
ObjectPropertyRange(:hasNoSkuObject_InternalShape :InternalShape)
InverseFunctionalObjectProperty(:hasNoSkuObject_InternalShape)
FunctionalObjectProperty(:hasNoSkuObject_InternalShape)

Declaration(ObjectProperty(:hadByInternalShape_NoSkuObject))
InverseObjectProperties(:hasNoSkuObject_InternalShape
                        :hadByInternalShape_NoSkuObject)
ObjectPropertyDomain(:hadByInternalShape_NoSkuObject :InternalShape)
ObjectPropertyRange(:hadByInternalShape_NoSkuObject :NoSkuObject)

Declaration(ObjectProperty(:hasNoSkuObject_ExternalShape))
ObjectPropertyDomain(:hasNoSkuObject_ExternalShape :NoSkuObject)
ObjectPropertyRange(:hasNoSkuObject_ExternalShape :ExternalShape)
InverseFunctionalObjectProperty(:hasNoSkuObject_ExternalShape)
FunctionalObjectProperty(:hasNoSkuObject_ExternalShape)

Declaration(ObjectProperty(:hadByExternalShape_NoSkuObject))
InverseObjectProperties(:hasNoSkuObject_ExternalShape
                        :hadByExternalShape_NoSkuObject)
ObjectPropertyDomain(:hadByExternalShape_NoSkuObject :ExternalShape)
ObjectPropertyRange(:hadByExternalShape_NoSkuObject :NoSkuObject)



Declaration(Class(:Part))

AnnotationAssertion(rdfs:comment :Part
  "Part is derived from SkuObject.
  An instance of Part has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber.
 
  The Part represents a part.
  The Sku specifies the SKU for the part.")

Declaration(DataProperty(:hasPart_SerialNumber))
DataPropertyDomain(:hasPart_SerialNumber :Part)
DataPropertyRange(:hasPart_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasPart_SerialNumber)
EquivalentClasses(:Part ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPart_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasPart_SerialNumber xsd:NMTOKEN)))



Declaration(Class(:PartRefAndPose))

AnnotationAssertion(rdfs:comment :PartRefAndPose
  "PartRefAndPose is derived from DataThing.
  An instance of PartRefAndPose has the following:
    Sku
    Point
    ZAxis
    XAxis.
 
  The Sku identifies a type of part. The Point specifies
  the location of the origin of the part in the coordinate system of
  the tray of the KitDesign to which the PartRefAndPose
  belongs. The ZAxis and XAxis specify the orientation of the part
  relative to that coordinate system.")


Declaration(ObjectProperty(:hasPartRefAndPose_Sku))
ObjectPropertyDomain(:hasPartRefAndPose_Sku :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartRefAndPose_Sku)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartRefAndPose_Sku :StockKeepingUnit)))

Declaration(ObjectProperty(:hasPartRefAndPose_Point))
ObjectPropertyDomain(:hasPartRefAndPose_Point :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Point :Point)
InverseFunctionalObjectProperty(:hasPartRefAndPose_Point)
FunctionalObjectProperty(:hasPartRefAndPose_Point)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_Point :Point)
  ObjectAllValuesFrom (:hasPartRefAndPose_Point :Point)))

Declaration(ObjectProperty(:hadByPoint_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_Point
                        :hadByPoint_PartRefAndPose)
ObjectPropertyDomain(:hadByPoint_PartRefAndPose :Point)
ObjectPropertyRange(:hadByPoint_PartRefAndPose :PartRefAndPose)

Declaration(ObjectProperty(:hasPartRefAndPose_XAxis))
ObjectPropertyDomain(:hasPartRefAndPose_XAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_XAxis :Vector)
InverseFunctionalObjectProperty(:hasPartRefAndPose_XAxis)
FunctionalObjectProperty(:hasPartRefAndPose_XAxis)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_XAxis :Vector)
  ObjectAllValuesFrom (:hasPartRefAndPose_XAxis :Vector)))

Declaration(ObjectProperty(:hadByXAxis_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_XAxis
                        :hadByXAxis_PartRefAndPose)
ObjectPropertyDomain(:hadByXAxis_PartRefAndPose :Vector)
ObjectPropertyRange(:hadByXAxis_PartRefAndPose :PartRefAndPose)

Declaration(ObjectProperty(:hasPartRefAndPose_ZAxis))
ObjectPropertyDomain(:hasPartRefAndPose_ZAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_ZAxis :Vector)
InverseFunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
FunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartRefAndPose_ZAxis :Vector)
  ObjectAllValuesFrom (:hasPartRefAndPose_ZAxis :Vector)))

Declaration(ObjectProperty(:hadByZAxis_PartRefAndPose))
InverseObjectProperties(:hasPartRefAndPose_ZAxis
                        :hadByZAxis_PartRefAndPose)
ObjectPropertyDomain(:hadByZAxis_PartRefAndPose :Vector)
ObjectPropertyRange(:hadByZAxis_PartRefAndPose :PartRefAndPose)



Declaration(Class(:PartsBin))

AnnotationAssertion(rdfs:comment :PartsBin
  "PartsBin is derived from PartsVessel.
  An instance of PartsBin has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber (inherited)
    PartSku (inherited)
    PartQuantity (inherited)
    Part (inherited, optional, multiple).
 
  The Sku specifies the SKU for the PartsBin. A
  PartsBin holds a number of Parts (PartQuantity) with the
  same SKU (PartSku)in unknown random positions. Each
  Part in the tray should be listed explictly and have a
  RelativeLocationIn with the bin as its RefObject.")



Declaration(Class(:PartsVessel))

AnnotationAssertion(rdfs:comment :PartsVessel
  "PartsVessel is derived from SkuObject.
  An instance of PartsVessel has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber
    PartSku
    PartQuantity
    Part (optional, multiple)
 
  PartsVessel is an abstract type from which more specific types
  of things that supply parts are derived. The Sku
  specifies the SKU for the PartsVessel. The shape of a
  PartsVessel is as specified in its Sku. The PartSku
  specifies the SKU for the Parts in the PartsVessel. The value
  of PartQuantity should be the number of instances of Part.")

SubClassOf(:PartsBin :PartsVessel)
SubClassOf(:PartsTray :PartsVessel)
DisjointUnion(:PartsVessel
              :PartsBin
              :PartsTray)

Declaration(DataProperty(:hasPartsVessel_SerialNumber))
DataPropertyDomain(:hasPartsVessel_SerialNumber :PartsVessel)
DataPropertyRange(:hasPartsVessel_SerialNumber xsd:NMTOKEN)
FunctionalDataProperty(:hasPartsVessel_SerialNumber)
EquivalentClasses(:PartsVessel ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsVessel_SerialNumber xsd:NMTOKEN)
  DataAllValuesFrom (:hasPartsVessel_SerialNumber xsd:NMTOKEN)))


Declaration(ObjectProperty(:hasPartsVessel_PartSku))
ObjectPropertyDomain(:hasPartsVessel_PartSku :PartsVessel)
ObjectPropertyRange(:hasPartsVessel_PartSku :StockKeepingUnit)
FunctionalObjectProperty(:hasPartsVessel_PartSku)
EquivalentClasses(:PartsVessel ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPartsVessel_PartSku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasPartsVessel_PartSku :StockKeepingUnit)))

Declaration(DataProperty(:hasPartsVessel_PartQuantity))
DataPropertyDomain(:hasPartsVessel_PartQuantity :PartsVessel)
DataPropertyRange(:hasPartsVessel_PartQuantity xsd:nonNegativeInteger)
FunctionalDataProperty(:hasPartsVessel_PartQuantity)
EquivalentClasses(:PartsVessel ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPartsVessel_PartQuantity xsd:nonNegativeInteger)
  DataAllValuesFrom (:hasPartsVessel_PartQuantity xsd:nonNegativeInteger)))

Declaration(ObjectProperty(:hasPartsVessel_Part))
ObjectPropertyDomain(:hasPartsVessel_Part :PartsVessel)
ObjectPropertyRange(:hasPartsVessel_Part :Part)
InverseFunctionalObjectProperty(:hasPartsVessel_Part)

Declaration(ObjectProperty(:hadByPart_PartsVessel))
InverseObjectProperties(:hasPartsVessel_Part
                        :hadByPart_PartsVessel)
ObjectPropertyDomain(:hadByPart_PartsVessel :Part)
ObjectPropertyRange(:hadByPart_PartsVessel :PartsVessel)



Declaration(Class(:PartsTray))

AnnotationAssertion(rdfs:comment :PartsTray
  "PartsTray is derived from PartsVessel.
  An instance of PartsTray has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    Sku (inherited)
    SerialNumber (inherited)
    PartSku (inherited)
    PartQuantity (inherited)
    Part (inherited, optional, multiple).
 
  The Sku specifies the SKU of the PartsTray. A
  PartsTray holds a number of Parts (PartQuantity) with the
  same SKU (PartSku) in known positions. Each Part in
  the tray should be listed explictly and have a PoseLocation with
  the parts tray as its RefObject.")



Declaration(Class(:PhysicalLocation))

AnnotationAssertion(rdfs:comment :PhysicalLocation
  "PhysicalLocation is derived from DataThing.
  An instance of PhysicalLocation has the following:
    RefObject
    Timestamp (optional).
 
  PhysicalLocation is an abstract type from which more specific
  types of physical location are derived. A PhysicalLocation says
  where a SolidObject is relative to its reference object.
  Timestamp represents the most recent date and time when the
  location was updated.")

SubClassOf(:PoseLocation :PhysicalLocation)
SubClassOf(:RelativeLocation :PhysicalLocation)
DisjointUnion(:PhysicalLocation
              :PoseLocation
              :RelativeLocation)


Declaration(ObjectProperty(:hasPhysicalLocation_RefObject))
ObjectPropertyDomain(:hasPhysicalLocation_RefObject :PhysicalLocation)
ObjectPropertyRange(:hasPhysicalLocation_RefObject :SolidObject)
FunctionalObjectProperty(:hasPhysicalLocation_RefObject)
EquivalentClasses(:PhysicalLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPhysicalLocation_RefObject :SolidObject)
  ObjectAllValuesFrom (:hasPhysicalLocation_RefObject :SolidObject)))

Declaration(DataProperty(:hasPhysicalLocation_Timestamp))
DataPropertyDomain(:hasPhysicalLocation_Timestamp :PhysicalLocation)
DataPropertyRange(:hasPhysicalLocation_Timestamp xsd:dateTime)
FunctionalDataProperty(:hasPhysicalLocation_Timestamp)



Declaration(Class(:Point))

AnnotationAssertion(rdfs:comment :Point
  "Point is derived from DataThing.
  An instance of Point has the following:
    X
    Y
    Z.
 
  X, Y, and Z are the Cartesian coordinates of the Point.")

Declaration(DataProperty(:hasPoint_X))
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyRange(:hasPoint_X xsd:decimal)
FunctionalDataProperty(:hasPoint_X)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_X xsd:decimal)
  DataAllValuesFrom (:hasPoint_X xsd:decimal)))

Declaration(DataProperty(:hasPoint_Y))
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyRange(:hasPoint_Y xsd:decimal)
FunctionalDataProperty(:hasPoint_Y)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Y xsd:decimal)
  DataAllValuesFrom (:hasPoint_Y xsd:decimal)))

Declaration(DataProperty(:hasPoint_Z))
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyRange(:hasPoint_Z xsd:decimal)
FunctionalDataProperty(:hasPoint_Z)
EquivalentClasses(:Point ObjectIntersectionOf(
  DataSomeValuesFrom(:hasPoint_Z xsd:decimal)
  DataAllValuesFrom (:hasPoint_Z xsd:decimal)))



Declaration(Class(:PoseLocation))

AnnotationAssertion(rdfs:comment :PoseLocation
  "PoseLocation is derived from PhysicalLocation.
  An instance of PoseLocation has the following:
    RefObject (inherited)
    Timestamp (inherited, optional).
    Point
    XAxis
    ZAxis 
    PositionStandardDeviation (optional)
    OrientationStandardDeviation (optional).
 
  PoseLocation is an abstract type from which more specific types
  of pose location are derived. The Point locates the origin of a
  coordinate system. The XAxis and ZAxis give the orientation of the
  coordinate system. The data for the Point, the ZAxis and the XAxis
  are expressed relative to the coordinate system of the reference
  object.
 
  The PositionStandardDeviation is based on a normal distribution of
  actual position about its given value. Thus, for example, the
  actual position is expected to be within the given
  PositionStandardDeviation amount 68% of the time and within twice
  the given amount 95% of the time. The PositionStandardDeviation is
  measured in the length units being used.
 
  The OrientationStandardDeviation is based on a normal distribution
  of orientation about its given value. The error is to be measured
  as the angle of rotation about a single axis needed to rotate a
  solid object from its stated orientation to its actual orientation.
  The OrientationStandardDeviation is measured in the angle units
  being used.")

SubClassOf(:PoseLocationIn :PoseLocation)
SubClassOf(:PoseLocationOn :PoseLocation)
SubClassOf(:PoseOnlyLocation :PoseLocation)
DisjointUnion(:PoseLocation
              :PoseLocationIn
              :PoseLocationOn
              :PoseOnlyLocation)

Declaration(ObjectProperty(:hasPoseLocation_Point))
ObjectPropertyDomain(:hasPoseLocation_Point :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_Point :Point)
InverseFunctionalObjectProperty(:hasPoseLocation_Point)
FunctionalObjectProperty(:hasPoseLocation_Point)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_Point :Point)
  ObjectAllValuesFrom (:hasPoseLocation_Point :Point)))

Declaration(ObjectProperty(:hadByPoint_PoseLocation))
InverseObjectProperties(:hasPoseLocation_Point
                        :hadByPoint_PoseLocation)
ObjectPropertyDomain(:hadByPoint_PoseLocation :Point)
ObjectPropertyRange(:hadByPoint_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_XAxis))
ObjectPropertyDomain(:hasPoseLocation_XAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_XAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_XAxis)
FunctionalObjectProperty(:hasPoseLocation_XAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_XAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_XAxis :Vector)))

Declaration(ObjectProperty(:hadByXAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_XAxis
                        :hadByXAxis_PoseLocation)
ObjectPropertyDomain(:hadByXAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByXAxis_PoseLocation :PoseLocation)

Declaration(ObjectProperty(:hasPoseLocation_ZAxis))
ObjectPropertyDomain(:hasPoseLocation_ZAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_ZAxis :Vector)
InverseFunctionalObjectProperty(:hasPoseLocation_ZAxis)
FunctionalObjectProperty(:hasPoseLocation_ZAxis)
EquivalentClasses(:PoseLocation ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasPoseLocation_ZAxis :Vector)
  ObjectAllValuesFrom (:hasPoseLocation_ZAxis :Vector)))

Declaration(ObjectProperty(:hadByZAxis_PoseLocation))
InverseObjectProperties(:hasPoseLocation_ZAxis
                        :hadByZAxis_PoseLocation)
ObjectPropertyDomain(:hadByZAxis_PoseLocation :Vector)
ObjectPropertyRange(:hadByZAxis_PoseLocation :PoseLocation)

Declaration(DataProperty(:hasPoseLocation_PositionStandardDeviation))
DataPropertyDomain(:hasPoseLocation_PositionStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_PositionStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_PositionStandardDeviation)

Declaration(DataProperty(:hasPoseLocation_OrientationStandardDeviation))
DataPropertyDomain(:hasPoseLocation_OrientationStandardDeviation :PoseLocation)
DataPropertyRange(:hasPoseLocation_OrientationStandardDeviation :positiveDecimal)
FunctionalDataProperty(:hasPoseLocation_OrientationStandardDeviation)



Declaration(Class(:PoseLocationIn))

AnnotationAssertion(rdfs:comment :PoseLocationIn
  "PoseLocationIn is derived from PoseLocation.
  An instance of PoseLocationIn has the following:
    RefObject (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  A PoseLocationIn indicates that the object is inside
  the location-parent. The notion of 'inside' is vague and might be
  made more precise.")



Declaration(Class(:PoseLocationOn))

AnnotationAssertion(rdfs:comment :PoseLocationOn
  "PoseLocationOn is derived from PoseLocation.
  An instance of PoseLocationOn has the following:
    RefObject (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  A PoseLocationOn indicates that the Object is on top of the
  location-parent. The notion of 'on top of' is vague and might be
  made more precise.")



Declaration(Class(:PoseOnlyLocation))

AnnotationAssertion(rdfs:comment :PoseOnlyLocation
  "PoseOnlyLocation is derived from PoseLocation.
  An instance of PoseOnlyLocation has the following:
    RefObject (inherited)
    Timestamp (inherited, optional).
    Point (inherited)
    XAxis (inherited)
    ZAxis  (inherited)
    PositionStandardDeviation (inherited, optional)
    OrientationStandardDeviation (inherited, optional).
 
  An object located by a PoseOnlyLocation may or may not be
  inside or on top of the reference object of the
  PoseOnlyLocation.")



Declaration(Class(:RelativeLocation))

AnnotationAssertion(rdfs:comment :RelativeLocation
  "RelativeLocation is derived from PhysicalLocation.
  An instance of RelativeLocation has a the following:
    RefObject (inherited)
    Timestamp (inherited, optional)
    Description.
 
  RelativeLocation is an abstract type from which more specific
  types of relative location are derived. A RelativeLocation
  indicates that the SolidObject that has the
  RelativeLocation is on or in the RefObject. The Description may
  be used to describe the relative positions of the object and its
  reference object.")

SubClassOf(:RelativeLocationIn :RelativeLocation)
SubClassOf(:RelativeLocationOn :RelativeLocation)
DisjointUnion(:RelativeLocation
              :RelativeLocationIn
              :RelativeLocationOn)

Declaration(DataProperty(:hasRelativeLocation_Description))
DataPropertyDomain(:hasRelativeLocation_Description :RelativeLocation)
DataPropertyRange(:hasRelativeLocation_Description xsd:string)
FunctionalDataProperty(:hasRelativeLocation_Description)
EquivalentClasses(:RelativeLocation ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRelativeLocation_Description xsd:string)
  DataAllValuesFrom (:hasRelativeLocation_Description xsd:string)))



Declaration(Class(:RelativeLocationIn))

AnnotationAssertion(rdfs:comment :RelativeLocationIn
  "RelativeLocationIn is derived from RelativeLocation.
  An instance of RelativeLocationIn has the following:
    RefObject (inherited)
    Timestamp (inherited, optional)
    Description (inherited).
 
  A RelativeLocationIn indicates that the SolidObject that
  has the RelativeLocation is in the RefObject. The notion of
  'in' is vague and might be made more precise.")



Declaration(Class(:RelativeLocationOn))

AnnotationAssertion(rdfs:comment :RelativeLocationOn
  "RelativeLocationOn is derived from RelativeLocation.
  An instance of RelativeLocationOn has the following:
    RefObject (inherited)
    Timestamp (inherited, optional)
    Description (inherited).
 
  A RelativeLocationOn indicates that the SolidObject that
  has the RelativeLocation is on top of the the RefObject. The
  notion of 'on top of' is vague and might be made more precise.")



Declaration(Class(:Robot))

AnnotationAssertion(rdfs:comment :Robot
  "Robot is derived from NoSkuObject.
  An instance of Robot has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description
    EndEffector (optional)
    MaximumLoadWeight
    WorkVolume (multiple).
 
  The Robot ontology given here might be expanded greatly to include,
  for example, its kinematic description, the values of joint angles,
  arm lengths of variable length arms, gripper actuation (open,
  closed, etc.), ranges, velocities, and accelerations of each joint,
  etc.")

Declaration(DataProperty(:hasRobot_Description))
DataPropertyDomain(:hasRobot_Description :Robot)
DataPropertyRange(:hasRobot_Description xsd:string)
FunctionalDataProperty(:hasRobot_Description)
EquivalentClasses(:Robot ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRobot_Description xsd:string)
  DataAllValuesFrom (:hasRobot_Description xsd:string)))

Declaration(ObjectProperty(:hasRobot_EndEffector))
ObjectPropertyDomain(:hasRobot_EndEffector :Robot)
ObjectPropertyRange(:hasRobot_EndEffector :EndEffector)
InverseFunctionalObjectProperty(:hasRobot_EndEffector)
FunctionalObjectProperty(:hasRobot_EndEffector)

Declaration(ObjectProperty(:hadByEndEffector_Robot))
InverseObjectProperties(:hasRobot_EndEffector
                        :hadByEndEffector_Robot)
ObjectPropertyDomain(:hadByEndEffector_Robot :EndEffector)
ObjectPropertyRange(:hadByEndEffector_Robot :Robot)

Declaration(DataProperty(:hasRobot_MaximumLoadWeight))
DataPropertyDomain(:hasRobot_MaximumLoadWeight :Robot)
DataPropertyRange(:hasRobot_MaximumLoadWeight :positiveDecimal)
FunctionalDataProperty(:hasRobot_MaximumLoadWeight)
EquivalentClasses(:Robot ObjectIntersectionOf(
  DataSomeValuesFrom(:hasRobot_MaximumLoadWeight :positiveDecimal)
  DataAllValuesFrom (:hasRobot_MaximumLoadWeight :positiveDecimal)))

Declaration(ObjectProperty(:hasRobot_WorkVolume))
ObjectPropertyDomain(:hasRobot_WorkVolume :Robot)
ObjectPropertyRange(:hasRobot_WorkVolume :BoxVolume)
InverseFunctionalObjectProperty(:hasRobot_WorkVolume)

Declaration(ObjectProperty(:hadByWorkVolume_Robot))
InverseObjectProperties(:hasRobot_WorkVolume
                        :hadByWorkVolume_Robot)
ObjectPropertyDomain(:hadByWorkVolume_Robot :BoxVolume)
ObjectPropertyRange(:hadByWorkVolume_Robot :Robot)



Declaration(Class(:ShapeDesign))

AnnotationAssertion(rdfs:comment :ShapeDesign
  "ShapeDesign is derived from DataThing.
  An instance of ShapeDesign has the following:
    Description (optional)
    GraspPose (optional).
 
  ShapeDesign is an abstract type from which more specific types
  of shape design are derived. Each ShapeDesign has a coordinate
  system that is expected to be specified explicitly or implicitly. A
  shape defined using coordinate values has an implicit coordinate
  system.
 
  The GraspPose is relative to the coordinate system of the
  ShapeDesign. The Point in the pose is the point at which a
  gripper should make contact with the shape. The ZAxis of the pose
  may be used to indicate a direction for aligning the ZAxis of the
  gripper (parallel or antiparallel) and is usually normal to the the
  object having the shape and pointing away from the object. The
  GraspPose should not use the optional Timestamp.")

SubClassOf(:ExternalShape :ShapeDesign)
SubClassOf(:InternalShape :ShapeDesign)
DisjointUnion(:ShapeDesign
              :ExternalShape
              :InternalShape)

Declaration(DataProperty(:hasShapeDesign_Description))
DataPropertyDomain(:hasShapeDesign_Description :ShapeDesign)
DataPropertyRange(:hasShapeDesign_Description xsd:string)
FunctionalDataProperty(:hasShapeDesign_Description)
EquivalentClasses(:ShapeDesign ObjectIntersectionOf(
  DataSomeValuesFrom(:hasShapeDesign_Description xsd:string)
  DataAllValuesFrom (:hasShapeDesign_Description xsd:string)))

Declaration(ObjectProperty(:hasShapeDesign_GraspPose))
ObjectPropertyDomain(:hasShapeDesign_GraspPose :ShapeDesign)
ObjectPropertyRange(:hasShapeDesign_GraspPose :PoseLocation)
InverseFunctionalObjectProperty(:hasShapeDesign_GraspPose)
FunctionalObjectProperty(:hasShapeDesign_GraspPose)

Declaration(ObjectProperty(:hadByGraspPose_ShapeDesign))
InverseObjectProperties(:hasShapeDesign_GraspPose
                        :hadByGraspPose_ShapeDesign)
ObjectPropertyDomain(:hadByGraspPose_ShapeDesign :PoseLocation)
ObjectPropertyRange(:hadByGraspPose_ShapeDesign :ShapeDesign)



Declaration(Class(:SkuObject))

AnnotationAssertion(rdfs:comment :SkuObject
  "SkuObject is derived from SolidObject.
  An instance of SkuObject has the following:
    PrimaryLocation (inherited)
    SecondaryLocations (inherited, optional, multiple)
    Sku
 
  A SkuObject is an abstract type from which more specific types
  of solid object are derived. A SkuObject is an instance of a
  stockkeeping unit. The shape of a SkuObject is specified by its
  stockkeeping unit.")

SubClassOf(:KitTray :SkuObject)
SubClassOf(:LargeContainer :SkuObject)
SubClassOf(:Part :SkuObject)
SubClassOf(:PartsVessel :SkuObject)
DisjointUnion(:SkuObject
              :KitTray
              :LargeContainer
              :Part
              :PartsVessel)


Declaration(ObjectProperty(:hasSkuObject_Sku))
ObjectPropertyDomain(:hasSkuObject_Sku :SkuObject)
ObjectPropertyRange(:hasSkuObject_Sku :StockKeepingUnit)
FunctionalObjectProperty(:hasSkuObject_Sku)
EquivalentClasses(:SkuObject ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasSkuObject_Sku :StockKeepingUnit)
  ObjectAllValuesFrom (:hasSkuObject_Sku :StockKeepingUnit)))



Declaration(Class(:Slot))

AnnotationAssertion(rdfs:comment :Slot
  "Slot is derived from DataThing.
  An instance of Slot has the following:
    PartRefAndPose
    Part (optional).
 
  A Slot identifies whether or not a particular PartRefAndPose from
  the design of a Kit is occupied in an instance of a Kit. The
  PartRefAndPose identifies a PartRefAndPose from the
  Design of the Kit. The Part identifies a Part that
  occupies the PartRefAndPose. The Sku of the PartRefAndPose should
  be the Sku of the Part, the PartRefAndPose should be in the Kit
  design, and the Part should be in the Kit. The location described
  by the Pose of the Part in the Kit may differ from the location
  described by the Pose in the PartRefAndPose, but will usually be
  very close to it. If the Part is not used for a slot,
  that means the slot is empty.")


Declaration(ObjectProperty(:hasSlot_PartRefAndPose))
ObjectPropertyDomain(:hasSlot_PartRefAndPose :Slot)
ObjectPropertyRange(:hasSlot_PartRefAndPose :PartRefAndPose)
FunctionalObjectProperty(:hasSlot_PartRefAndPose)
EquivalentClasses(:Slot ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasSlot_PartRefAndPose :PartRefAndPose)
  ObjectAllValuesFrom (:hasSlot_PartRefAndPose :PartRefAndPose)))


Declaration(ObjectProperty(:hasSlot_Part))
ObjectPropertyDomain(:hasSlot_Part :Slot)
ObjectPropertyRange(:hasSlot_Part :Part)
FunctionalObjectProperty(:hasSlot_Part)



Declaration(Class(:SolidObject))

AnnotationAssertion(rdfs:comment :SolidObject
  "An instance of SolidObject has the following:
    PrimaryLocation
    SecondaryLocations (optional, multiple)
 
  SolidObject is an abstract type from which more specific types
  of SolidObject are derived. The secondary locations are required to
  be logically and mathematically consistent with the value of the
  PrimaryLocation so that all locations of a SolidObject describe
  (or are consistent with) a single place in space. No
  SolidObject except the Workstation may be located with respect
  to itself, and all chains of primary location must end at the
  Workstation.")

SubClassOf(:NoSkuObject :SolidObject)
SubClassOf(:SkuObject :SolidObject)
DisjointUnion(:SolidObject
              :NoSkuObject
              :SkuObject)

Declaration(ObjectProperty(:hasSolidObject_PrimaryLocation))
ObjectPropertyDomain(:hasSolidObject_PrimaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_PrimaryLocation :PhysicalLocation)
InverseFunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
FunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
EquivalentClasses(:SolidObject ObjectIntersectionOf(
  ObjectSomeValuesFrom(:hasSolidObject_PrimaryLocation :PhysicalLocation)
  ObjectAllValuesFrom (:hasSolidObject_PrimaryLocation :PhysicalLocation)))

Declaration(ObjectProperty(:hadByPrimaryLocation_SolidObject))
InverseObjectProperties(:hasSolidObject_PrimaryLocation
                        :hadByPrimaryLocation_SolidObject)
ObjectPropertyDomain(:hadByPrimaryLocation_SolidObject :PhysicalLocation)
ObjectPropertyRange(:hadByPrimaryLocation_SolidObject :SolidObject)

Declaration(ObjectProperty(:hasSolidObject_SecondaryLocation))
ObjectPropertyDomain(:hasSolidObject_SecondaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_SecondaryLocation :PhysicalLocation)
InverseFunctionalObjectProperty(:hasSolidObject_SecondaryLocation)

Declaration(ObjectProperty(:hadBySecondaryLocation_SolidObject))
InverseObjectProperties(:hasSolidObject_SecondaryLocation
                        :hadBySecondaryLocation_SolidObject)
ObjectPropertyDomain(:hadBySecondaryLocation_SolidObject :PhysicalLocation)
ObjectPropertyRange(:hadBySecondaryLocation_SolidObject :SolidObject)



Declaration(Class(:StockKeepingUnit))

AnnotationAssertion(rdfs:comment :StockKeepingUnit
  "StockKeepingUnit is derived from DataThing.
  An instance of StockKeepingUnit has the following:
    Description
    InternalShape (optional)
    ExternalShape (optional)
    Weight
    EndEffector (optional, multiple).
 
  A StockKeepingUnit is a description of a type of object. SKU is
  an abbreviation for Stock Keeping Unit. Each EndEffectorName
  (IDREF) identifies an instance of EndEffector that can handle
  the SKU. One or both of InternalShape and ExternalShape must be
  given. The shapes are not required to represent the same shape, but
  they should not be inconsistent.")

Declaration(DataProperty(:hasStockKeepingUnit_Description))
DataPropertyDomain(:hasStockKeepingUnit_Description :StockKeepingUnit)
DataPropertyRange(:hasStockKeepingUnit_Description xsd:string)
FunctionalDataProperty(:hasStockKeepingUnit_Description)
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasStockKeepingUnit_Description xsd:string)
  DataAllValuesFrom (:hasStockKeepingUnit_Description xsd:string)))

Declaration(ObjectProperty(:hasStockKeepingUnit_InternalShape))
ObjectPropertyDomain(:hasStockKeepingUnit_InternalShape :StockKeepingUnit)
ObjectPropertyRange(:hasStockKeepingUnit_InternalShape :InternalShape)
InverseFunctionalObjectProperty(:hasStockKeepingUnit_InternalShape)
FunctionalObjectProperty(:hasStockKeepingUnit_InternalShape)

Declaration(ObjectProperty(:hadByInternalShape_StockKeepingUnit))
InverseObjectProperties(:hasStockKeepingUnit_InternalShape
                        :hadByInternalShape_StockKeepingUnit)
ObjectPropertyDomain(:hadByInternalShape_StockKeepingUnit :InternalShape)
ObjectPropertyRange(:hadByInternalShape_StockKeepingUnit :StockKeepingUnit)

Declaration(ObjectProperty(:hasStockKeepingUnit_ExternalShape))
ObjectPropertyDomain(:hasStockKeepingUnit_ExternalShape :StockKeepingUnit)
ObjectPropertyRange(:hasStockKeepingUnit_ExternalShape :ExternalShape)
InverseFunctionalObjectProperty(:hasStockKeepingUnit_ExternalShape)
FunctionalObjectProperty(:hasStockKeepingUnit_ExternalShape)

Declaration(ObjectProperty(:hadByExternalShape_StockKeepingUnit))
InverseObjectProperties(:hasStockKeepingUnit_ExternalShape
                        :hadByExternalShape_StockKeepingUnit)
ObjectPropertyDomain(:hadByExternalShape_StockKeepingUnit :ExternalShape)
ObjectPropertyRange(:hadByExternalShape_StockKeepingUnit :StockKeepingUnit)

Declaration(DataProperty(:hasStockKeepingUnit_Weight))
DataPropertyDomain(:hasStockKeepingUnit_Weight :StockKeepingUnit)
DataPropertyRange(:hasStockKeepingUnit_Weight :positiveDecimal)
FunctionalDataProperty(:hasStockKeepingUnit_Weight)
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(
  DataSomeValuesFrom(:hasStockKeepingUnit_Weight :positiveDecimal)
  DataAllValuesFrom (:hasStockKeepingUnit_Weight :positiveDecimal)))


Declaration(ObjectProperty(:hasStockKeepingUnit_EndEffector))
ObjectPropertyDomain(:hasStockKeepingUnit_EndEffector :StockKeepingUnit)
ObjectPropertyRange(:hasStockKeepingUnit_EndEffector :EndEffector)



Declaration(Class(:VacuumEffector))

AnnotationAssertion(rdfs:comment :VacuumEffector
  "VacuumEffector is derived from EndEffector.
  An instance of VacuumEffector has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description (inherited)
    Weight (inherited)
    MaximumLoadWeight (inherited)
    CupDiameter
    Length.
 
  VacuumEffector is an abstract type from which more specific
  types of VacuumEffector are derived. A VacuumEffector holds
  an object by putting a cup or cups against the object and applying
  a vacuum.")

SubClassOf(:VacuumEffectorMultiCup :VacuumEffector)
SubClassOf(:VacuumEffectorSingleCup :VacuumEffector)
DisjointUnion(:VacuumEffector
              :VacuumEffectorMultiCup
              :VacuumEffectorSingleCup)

Declaration(DataProperty(:hasVacuumEffector_CupDiameter))
DataPropertyDomain(:hasVacuumEffector_CupDiameter :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_CupDiameter :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffector_CupDiameter)
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffector_CupDiameter :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffector_CupDiameter :positiveDecimal)))

Declaration(DataProperty(:hasVacuumEffector_Length))
DataPropertyDomain(:hasVacuumEffector_Length :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_Length :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffector_Length)
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffector_Length :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffector_Length :positiveDecimal)))



Declaration(Class(:VacuumEffectorMultiCup))

AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "VacuumEffectorMultiCup is derived from VacuumEffector. An
  instance of VacuumEffectorMultiCup has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description (inherited)
    Weight (inherited)
    MaximumLoadWeight (inherited)
    CupDiameter
    Length
    ArrayNumber
    ArrayRadius.
 
  The ArrayNumber is the number of cups, which must be at least 2.
  The cups are arranged in a circular array spaced evenly apart. The
  center of the wide end of one cup is on the X-axis of the
  coordinate system of the VacuumEffectorMultiCup. The center of
  the circular array is at the origin of the coordinate system. The
  axis of the array circle is the Z axis of the coordinate system,
  and the length of the VacuumEffector is measured along that
  axis. The wide ends of the cups lie on the XY plane of the
  coordinate system.
 
  Note that a square array can be represented easily as circular
  array.")

Declaration(DataProperty(:hasVacuumEffectorMultiCup_ArrayNumber))
DataPropertyDomain(:hasVacuumEffectorMultiCup_ArrayNumber :VacuumEffectorMultiCup)
DataPropertyRange(:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)
FunctionalDataProperty(:hasVacuumEffectorMultiCup_ArrayNumber)
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)
  DataAllValuesFrom (:hasVacuumEffectorMultiCup_ArrayNumber xsd:positiveInteger)))

Declaration(DataProperty(:hasVacuumEffectorMultiCup_ArrayRadius))
DataPropertyDomain(:hasVacuumEffectorMultiCup_ArrayRadius :VacuumEffectorMultiCup)
DataPropertyRange(:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)
FunctionalDataProperty(:hasVacuumEffectorMultiCup_ArrayRadius)
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)
  DataAllValuesFrom (:hasVacuumEffectorMultiCup_ArrayRadius :positiveDecimal)))



Declaration(Class(:VacuumEffectorSingleCup))

AnnotationAssertion(rdfs:comment :VacuumEffectorSingleCup
  "VacuumEffectorSingleCup is derived from VacuumEffector.
  An instance of KitTray has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    Description (inherited)
    Weight (inherited)
    MaximumLoadWeight (inherited)
    CupDiameter (inherited)
    Length (inherited).
 
  A VacuumEffectorSingleCup has one cup. The center of the wide
  end of the cup (which is a circle) is at the origin of the
  coordinate system of the VacuumEffectorSingleCup. The Z axis of
  the coordinate system is the axis of that circle, and the length of
  the VacuumEffector is measured along that axis.")



Declaration(Class(:Vector))

AnnotationAssertion(rdfs:comment :Vector
  "Vector is derived from DataThing.
  An instance of Vector has the following:
    I
    J
    K.
 
  I, J, and K represent the usual i, j, and k components of a 3D
  vector.")

Declaration(DataProperty(:hasVector_I))
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyRange(:hasVector_I xsd:decimal)
FunctionalDataProperty(:hasVector_I)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_I xsd:decimal)
  DataAllValuesFrom (:hasVector_I xsd:decimal)))

Declaration(DataProperty(:hasVector_J))
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyRange(:hasVector_J xsd:decimal)
FunctionalDataProperty(:hasVector_J)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_J xsd:decimal)
  DataAllValuesFrom (:hasVector_J xsd:decimal)))

Declaration(DataProperty(:hasVector_K))
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyRange(:hasVector_K xsd:decimal)
FunctionalDataProperty(:hasVector_K)
EquivalentClasses(:Vector ObjectIntersectionOf(
  DataSomeValuesFrom(:hasVector_K xsd:decimal)
  DataAllValuesFrom (:hasVector_K xsd:decimal)))



Declaration(Class(:WorkTable))

AnnotationAssertion(rdfs:comment :WorkTable
  "WorkTable is derived from NoSkuObject.
  An instance of WorkTable has the following:
    PrimaryLocation (inherited)
    SecondaryLocation (inherited, optional, multiple)
    InternalShape (inherited, optional)
    ExternalShape (inherited, optional)
    ObjectOnTable (optional, multiple).
 
  Each ObjectOnTable is a SolidObject located with respect to the
  WorkTable. The reference object of each ObjectOnTable should be
  the WorkTable. Typically, those objects will be on top of the
  WorkTable. Typically, the shape of a WorkTable will be a
  BoxyShape, so that the table has Length, Width, and Height.")

Declaration(ObjectProperty(:hasWorkTable_ObjectOnTable))
ObjectPropertyDomain(:hasWorkTable_ObjectOnTable :WorkTable)
ObjectPropertyRange(:hasWorkTable_ObjectOnTable :SolidObject)
InverseFunctionalObjectProperty(:hasWorkTable_ObjectOnTable)

Declaration(ObjectProperty(:hadByObjectOnTable_WorkTable))
InverseObjectProperties(:hasWorkTable_ObjectOnTable
                        :hadByObjectOnTable_WorkTable)
ObjectPropertyDomain(:hadByObjectOnTable_WorkTable :SolidObject)
ObjectPropertyRange(:hadByObjectOnTable_WorkTable :WorkTable)

DisjointClasses(:DataThing
                :SolidObject)
)
