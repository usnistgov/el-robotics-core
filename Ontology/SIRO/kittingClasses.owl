Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingClasses.owl#>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)


Ontology(<http://www.nist.gov/el/ontologies/kittingClasses.owl>
Annotation(rdfs:comment "Since properties are global, most properties
have long names. In all cases, the first part of the name or a
property is 'has' or 'is'. If a name can be divided into three parts,
the second part indicates the sort of thing that has the property. The
last part of the name describes the meaning of the value of the
property. If a name has three parts there is an underscore between the
second and third parts.")
Annotation(rdfs:comment "This does not include plans or individuals.")
Annotation(rdfs:comment "A kitting ontology")

Declaration(Class(:BoxVolume))
AnnotationAssertion(rdfs:comment :BoxVolume "A BoxVolume is a DataThing. A BoxVolume has a maximum
   point (hasBoxVolume_MaximumPoint) and a minimum point
   (hasBoxVolume_MinimumPoint). These are diagonally opposite
   corner points of a box shaped volume whose edges are aligned with
   the coordinate system in which the BoxVolume is located. The
   minimum point has the minimum values of X, Y, and Z. The maximum
   point has the maximum values of X, Y, and Z.")
EquivalentClasses(:BoxVolume ObjectIntersectionOf(ObjectAllValuesFrom(:hasBoxVolume_MaximumPoint :Point) ObjectSomeValuesFrom(:hasBoxVolume_MaximumPoint :Point)))
EquivalentClasses(:BoxVolume ObjectIntersectionOf(ObjectAllValuesFrom(:hasBoxVolume_MinimumPoint :Point) ObjectSomeValuesFrom(:hasBoxVolume_MinimumPoint :Point)))
SubClassOf(:BoxVolume :DataThing)
Declaration(Class(:BoxyObject))
AnnotationAssertion(rdfs:comment :BoxyObject "A BoxyObject is a SolidObject. A BoxyObject is box shaped. It has a
   length, width, and height (hasBox_Length, hasBox_Width, hasBox_Height).
   It has a preferred partial orientation in which the edges along
   which the height is measured are vertical (parallel to the force of
   gravity).  The length is larger of the two dimensions that are not
   the height.  The width is smaller of the two dimensions that are
   not the height.  The coordinate system of a BoxyObject (i.e. the
   thing that is located and oriented by a pose) has its origin in the
   middle of the bottom, its Z-axis parallel to the height sides, and
   its X-axis parallel to to the length sides. Since this still allows
   two choices for orientation (four if the length and width are
   equal) which may or may not be distinguishable, some subtypes of
   BoxyObject will need one more piece of orientation information.")
EquivalentClasses(:BoxyObject ObjectIntersectionOf(DataAllValuesFrom(:hasBox_Height :positiveDecimal) DataSomeValuesFrom(:hasBox_Height :positiveDecimal)))
EquivalentClasses(:BoxyObject ObjectIntersectionOf(DataAllValuesFrom(:hasBox_Length :positiveDecimal) DataSomeValuesFrom(:hasBox_Length :positiveDecimal)))
EquivalentClasses(:BoxyObject ObjectIntersectionOf(DataAllValuesFrom(:hasBox_Width :positiveDecimal) DataSomeValuesFrom(:hasBox_Width :positiveDecimal)))
SubClassOf(:BoxyObject :SolidObject)
DisjointUnion(:BoxyObject :KitTray :LargeContainer :PartsBin :PartsTray :WorkTable)
Declaration(Class(:DataThing))
AnnotationAssertion(rdfs:comment :DataThing "A Data Thing is a Thing. A DataThing includes all complex data types
   such as Vector, PhysicalLocation, etc. Currently, it has no properties.")
DisjointClasses(:DataThing :SolidObject)
DisjointUnion(:DataThing :BoxVolume :KitDesign :PartRefAndPose :PhysicalLocation :Point :ShapeDesign :StockKeepingUnit :Vector)
Declaration(Class(:EndEffector))
AnnotationAssertion(rdfs:comment :EndEffector "An EndEffector is a SolidObject. It is an end effector for a robot.
   An EndEffector has a description (hasEndEffector_Description), a
   weight (hasEndEffector_Weight), and a maximum weight it can lift
   (hasEffector_MaximumLoadWeight).  Every EndEffector is either a
   GripperEffector or a VacuumEffector.  Every EndEffector in a
   KittingWorkstation is either attached to the end of a robot arm
   (hadByEndEffector_Robot) or sitting in an EndEffectorHolder
   (hadByEndEffector_EndEffectorHolder) at an EndEffectorChangingStation.
   An EndEffector must not be holding anything when it is placed in an
   EndEffectorHolder or when it is sitting in an EndEffectorHolder.")
AnnotationAssertion(rdfs:comment :EndEffector "It might be better if each EndEffector has an associated data set
   that holds data for a type of EndEffector. Currently, the data is
   is for a specific object, not for a type. The data set would
   be analogous to the SKU data for a Part (it might even be a SKU).")
EquivalentClasses(:EndEffector ObjectIntersectionOf(DataAllValuesFrom(:hasEffector_MaximumLoadWeight :positiveDecimal) DataSomeValuesFrom(:hasEffector_MaximumLoadWeight :positiveDecimal)))
EquivalentClasses(:EndEffector ObjectIntersectionOf(DataAllValuesFrom(:hasEndEffector_Description xsd:string) DataSomeValuesFrom(:hasEndEffector_Description xsd:string)))
EquivalentClasses(:EndEffector ObjectIntersectionOf(DataAllValuesFrom(:hasEndEffector_Weight :positiveDecimal) DataSomeValuesFrom(:hasEndEffector_Weight :positiveDecimal)))
SubClassOf(:EndEffector :SolidObject)
DisjointUnion(:EndEffector :VacuumEffector :GripperEffector)
Declaration(Class(:EndEffectorChangingStation))
AnnotationAssertion(rdfs:comment :EndEffectorChangingStation "An EndEffectorChangingStation is a SolidObject. It is a place where
   end effectors are stored and where the robot can change end effectors.
   It has EndEffectorHolders (hasChangingStation_EndEffectorHolders).
   An EndEffectorChangingStation belongs to a KittingWorkstation
   (hadByChangingStation_Workstation)")
SubClassOf(:EndEffectorChangingStation :SolidObject)
Declaration(Class(:EndEffectorHolder))
AnnotationAssertion(rdfs:comment :EndEffectorHolder "An EndEffectorHolder is a SolidObject. An EndEffectorHolder holds
   zero or one EndEffector (hasEndEffectorHolder_EndEffector). An
   EndEffectorHolder is part of an EndEffectorChangingStation
   (hadByEndEffectorHolder_ChangingStation).")
SubClassOf(:EndEffectorHolder :SolidObject)
Declaration(Class(:GripperEffector))
AnnotationAssertion(rdfs:comment :GripperEffector "A GripperEffector is an EndEffector. A GripperEffector holds an
   object by gripping it with fingers or claws.")
SubClassOf(:GripperEffector :EndEffector)
Declaration(Class(:Kit))
AnnotationAssertion(rdfs:comment :Kit "A Kit is a SolidObject. A Kit has a KitDesign
   (hasKit_Design), a KitTray (hasKit_Tray), a set of Parts
   (hasKit_Parts), and a boolean indicator of whether the Kit is
   finished (isKit_Finished). The coordinate system of a Kit is the
   same as the coordinate system of its KitTray. The PrimaryLocation
   of a Part in a Kit should be given by a PoseLocationIn that is
   relative to the KitTray. A Kit may belong to a LargeBoxWithKits
   (hadByKit_LargeBoxWithKits).")
EquivalentClasses(:Kit ObjectIntersectionOf(ObjectAllValuesFrom(:hasKit_Tray :KitTray) ObjectSomeValuesFrom(:hasKit_Tray :KitTray)))
EquivalentClasses(:Kit ObjectIntersectionOf(DataAllValuesFrom(:isKit_Finished xsd:boolean) DataSomeValuesFrom(:isKit_Finished xsd:boolean)))
SubClassOf(:Kit :SolidObject)
Declaration(Class(:KitDesign))
AnnotationAssertion(rdfs:comment :KitDesign "A KitDesign is a DataThing. A KitDesign identifies a type of tray
   (hasKitDesign_KitTraySku), and intended poses of parts in
   finished kits of this design (hasKitDesign_PartRefAndPoses).  The
   pose (Point, zAxis, and xAxis) in a PartRefAndPose specifies the
   location of the part relative to the coordinate system of the
   ShapeDesign of the tray.  Each KitDesign belongs to a
   KittingWorkstation (hadByKitDesign_Workstation).")
SubClassOf(:KitDesign :DataThing)
Declaration(Class(:KitTray))
AnnotationAssertion(rdfs:comment :KitTray "A KitTray is a BoxyObject. A KitTray is designed to hold Parts with
   various SKU ids in known positions. A KitTray has a SKU
   (hasKitTray_Sku) and a serial number (hasKitTray_SerialNumber).
   A KitTray may belong to a Kit (hadByKitTray_Kit) or to a
   LargeBoxWithEmptyKitTrays (hadByKitTray_LargeBoxWithEmptyKitTrays).")
SubClassOf(:KitTray :BoxyObject)
Declaration(Class(:KittingWorkstation))
AnnotationAssertion(rdfs:comment :KittingWorkstation "A KittingWorkstation is a SolidObject. A KittingWorkstation
   contains a work table (hasWorkstation_WorkTable), a robot
   (hasWorkstation_Robot), an EndEffectorChangingStation
   (hasWorkstation_ChangingStation), and other fixed obstacles
   (hasWorkstation_OtherObstacles) such as a computer. A
   KittingWorkstation has an angle unit (hasWorkstation_AngleUnit), a
   length unit (hasWorkstation_LengthUnit) and a weight unit
   (hasWorkstation_WeightUnit). All angle, length, and weight values
   related to the workstation must use those units. A
   KittingWorkstation has StockKeepingUnits it knows about
   (hasWorkstation_Skus).  A KittingWorkstation has
   KitDesigns it knows about (hasWorkstation_KitDesigns). In
   addition, containers of various sorts enter and leave the workstation.
   The robot builds kits of parts by executing kitting plans as directed
   by a kitting plan execution system. The location of each instance of
   KittingWorkstation should be given relative to itself in order to
   end the chain of relative locations.")
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(ObjectAllValuesFrom(:hasWorkstation_ChangingStation :EndEffectorChangingStation) ObjectSomeValuesFrom(:hasWorkstation_ChangingStation :EndEffectorChangingStation)))
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(ObjectAllValuesFrom(:hasWorkstation_Robot :Robot) ObjectSomeValuesFrom(:hasWorkstation_Robot :Robot)))
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(ObjectAllValuesFrom(:hasWorkstation_WorkTable :WorkTable) ObjectSomeValuesFrom(:hasWorkstation_WorkTable :WorkTable)))
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(DataAllValuesFrom(:hasWorkstation_AngleUnit :angleUnit) DataSomeValuesFrom(:hasWorkstation_AngleUnit :angleUnit)))
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(DataAllValuesFrom(:hasWorkstation_LengthUnit :lengthUnit) DataSomeValuesFrom(:hasWorkstation_LengthUnit :lengthUnit)))
EquivalentClasses(:KittingWorkstation ObjectIntersectionOf(DataAllValuesFrom(:hasWorkstation_WeightUnit :weightUnit) DataSomeValuesFrom(:hasWorkstation_WeightUnit :weightUnit)))
SubClassOf(:KittingWorkstation :SolidObject)
Declaration(Class(:LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :LargeBoxWithEmptyKitTrays "A LargeBoxWithEmptyKitTrays is a SolidObject. A
   LargeBoxWithEmptyKitTrays has a LargeContainer
   (hasLargeBoxWithEmptyKitTrays_LargeContainer) and a set of KitTrays
   which should be empty (hasLargeBoxWithEmptyKitTrays_KitTrays).  The
   coordinate system of a LargeBoxWithEmptyKitTrays is the same as the
   coordinate system of its LargeContainer. The PrimaryLocation of a
   KitTray in a LargeBoxWithEmptyKitTrays should be given by a
   PoseLocationIn or RelativeLocationIn that is relative to the
   LargeContainer. The KitTrays in a LargeBoxWithEmptyKitTrays are
   intended to all be of the same SKU, although there is currently no
   formal requirement for that.")
EquivalentClasses(:LargeBoxWithEmptyKitTrays ObjectIntersectionOf(ObjectAllValuesFrom(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer) ObjectSomeValuesFrom(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)))
SubClassOf(:LargeBoxWithEmptyKitTrays :SolidObject)
Declaration(Class(:LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :LargeBoxWithKits "A LargeBoxWithKits is a SolidObject. A LargeBoxWithKits has
   - a LargeContainer (hasLargeBoxWithKits_LargeContainer)
   - a set of Kits (hasLargeBoxWithKits_Kits)
   - a KitDesign (hasLargeBoxWithKits_KitDesign)
   - a positiveInteger giving the maximum number of kits of the given
     design that can be held in the box (hasLargeBoxWithKits_Capacity).
   The coordinate system of a LargeBoxWithKits is the same as the
   coordinate system of its LargeContainer. The PrimaryLocation of a
   Kit in a LargeBoxWithKits should be given by a PoseLocationIn or
   RelativeLocationIn that is relative to the LargeContainer. The Kits
   in a LargeBoxWithKits are intended to all be of the given design,
   but there is currently no formal constraint requiring that.")
EquivalentClasses(:LargeBoxWithKits ObjectIntersectionOf(ObjectAllValuesFrom(:hasLargeBoxWithKits_LargeContainer :LargeContainer) ObjectSomeValuesFrom(:hasLargeBoxWithKits_LargeContainer :LargeContainer)))
SubClassOf(:LargeBoxWithKits :SolidObject)
Declaration(Class(:LargeContainer))
AnnotationAssertion(rdfs:comment :LargeContainer "A LargeContainer is a BoxyObject. A LargeContainer can hold one or more
   instances of a single type of tray or bin. The single type may be 
   (1) KitTray
   (2) PartsBin
   (3) PartsTray
   (4) Kit
   A LargeContainer has a SKU (hasLargeContainer_Sku) and a serial
   number (hasLargeContainer_SerialNumber). A LargeContainer may
   belong to a LargeBoxWithEmptyKitTrays
   (hadByLargeContainer_LargeBoxWithEmptyKitTrays) or to a
   LargeBoxWithKits (hadByLargeContainer_LargeBoxWithKits).")
SubClassOf(:LargeContainer :BoxyObject)
Declaration(Class(:Part))
AnnotationAssertion(rdfs:comment :Part "A Part is a SolidObject. It has a StockKeepingUnit (hasPart_Sku)
   and a SerialNumber (hasPart_SerialNumber). A Part may belong to a Kit
   (hadByPart_Kit) or to a PartsTrayWithParts
   (hadByPart_PartsTrayWithParts).")
SubClassOf(:Part :SolidObject)
Declaration(Class(:PartRefAndPose))
AnnotationAssertion(rdfs:comment :PartRefAndPose "A PartRefAndPose is a DataThing.  A PartRefAndPose identifies a
   type of part by giving its SKU (hasPartRefAndPose_Sku), it
   specifies the location of the part (hasPartRefAndPose_Point), and
   the orientation of the Part (hasPartRefAndPose_XAxis and
   hasPartRefAndPose_ZAxis). The pose is relative to the coordinate
   system of the KitTray identified in the KitDesign. A PartRefAndPose
   belongs to a KitDesign (hadByPartRefAndPose_KitDesign).")
EquivalentClasses(:PartRefAndPose ObjectIntersectionOf(ObjectAllValuesFrom(:hasPartRefAndPose_Sku :StockKeepingUnit) ObjectSomeValuesFrom(:hasPartRefAndPose_Sku :StockKeepingUnit)))
SubClassOf(:PartRefAndPose :DataThing)
Declaration(Class(:PartsBin))
AnnotationAssertion(rdfs:comment :PartsBin "A PartsBin is a BoxyObject. A PartsBin holds a number of Parts
   (hasPartsBin_PartQuantity) with the same SKU (hasPartsBin_PartSku)
   in unknown random positions.")
EquivalentClasses(:PartsBin ObjectIntersectionOf(ObjectAllValuesFrom(:hasPartsBin_PartSku :StockKeepingUnit) ObjectSomeValuesFrom(:hasPartsBin_PartSku :StockKeepingUnit)))
EquivalentClasses(:PartsBin ObjectIntersectionOf(DataAllValuesFrom(:hasPartsBin_PartQuantity xsd:nonNegativeInteger) DataSomeValuesFrom(:hasPartsBin_PartQuantity xsd:nonNegativeInteger)))
SubClassOf(:PartsBin :BoxyObject)
Declaration(Class(:PartsTray))
AnnotationAssertion(rdfs:comment :PartsTray "A PartsTray is a BoxyObject used to hold Parts. A PartsTray has a SKU
   (hasPartsTray_Sku) and a serial number (hasPartsTray_SerialNumber).
   A PartsTray may belong to a PartsTrayWithParts
   (hadByPartsTray_PartsTrayWithParts).")
SubClassOf(:PartsTray :BoxyObject)
Declaration(Class(:PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :PartsTrayWithParts "A PartsTrayWithParts is a SolidObject. A PartsTrayWithParts has a
   PartsTray (hasPartsTrayWithParts_Tray) and a set of Parts
   (hasPartsTrayWithParts_Parts). The coordinate system of a
   PartsTrayWithParts is the same as the coordinate system of its
   PartsTray. The PrimaryLocation of a Part in a
   PartsTrayWithParts should be given by a PoseLocationIn that is
   relative to the PartsTray. The Parts in a PartsTrayWithParts are
   intended to all be of the same SKU, although there is currently no
   formal requirement for that.")
EquivalentClasses(:PartsTrayWithParts ObjectIntersectionOf(ObjectAllValuesFrom(:hasPartsTrayWithParts_Tray :PartsTray) ObjectSomeValuesFrom(:hasPartsTrayWithParts_Tray :PartsTray)))
SubClassOf(:PartsTrayWithParts :SolidObject)
Declaration(Class(:PhysicalLocation))
AnnotationAssertion(rdfs:comment :PhysicalLocation "A PhysicalLocation is a DataThing. A PhysicalLocation says where a
   SolidObject is. A PhysicalLocation has a reference object
   (hasPhysicalLocation_RefObject). A PhysicalLocation is either a
   RelativeLocation or a PoseLocation.")
EquivalentClasses(:PhysicalLocation ObjectIntersectionOf(ObjectAllValuesFrom(:hasPhysicalLocation_RefObject :SolidObject) ObjectSomeValuesFrom(:hasPhysicalLocation_RefObject :SolidObject)))
SubClassOf(:PhysicalLocation :DataThing)
DisjointUnion(:PhysicalLocation :RelativeLocation :PoseLocation)
Declaration(Class(:Point))
AnnotationAssertion(rdfs:comment :Point "A Point is a DataThing. A Point has X (hasPoint_X), Y (hasPoint_Y),
   and Z (hasPoint_Z) Cartesian coordinates.")
EquivalentClasses(:Point ObjectIntersectionOf(DataAllValuesFrom(:hasPoint_X xsd:decimal) DataSomeValuesFrom(:hasPoint_X xsd:decimal)))
EquivalentClasses(:Point ObjectIntersectionOf(DataAllValuesFrom(:hasPoint_Y xsd:decimal) DataSomeValuesFrom(:hasPoint_Y xsd:decimal)))
EquivalentClasses(:Point ObjectIntersectionOf(DataAllValuesFrom(:hasPoint_Z xsd:decimal) DataSomeValuesFrom(:hasPoint_Z xsd:decimal)))
SubClassOf(:Point :DataThing)
Declaration(Class(:PoseLocation))
AnnotationAssertion(rdfs:comment :PoseLocation "A PoseOnlyLocation is a PoseLocation. A PoseOnlyLocation consists
   of a Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. An object located by a PoseOnlyLocation may or may not be
   inside or on top of the reference object of the PoseOnlyLocation.")
AnnotationAssertion(rdfs:comment :PoseLocation "A PoseLocationIn is a PoseLocation. A PoseLocationIn consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. A PoseLocationIn indicates that a SolidObject that has the
   PoseLocationIn as the value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is inside the SolidObject
   that is the reference object of the PoseLocationIn.  The notion of
   'inside' is vague and might be made more precise.")
AnnotationAssertion(rdfs:comment :PoseLocation "A PoseLocationOn is a PoseLocation. A PoseLocationOn consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. A PoseLocationOn indicates that a SolidObject that has the
   PoseLocationOn as the value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is on top of the
   SolidObject that is the reference object of the PoseLocationOn.
   The notion of 'on top of' is vague and might be made more
   precise.")
AnnotationAssertion(rdfs:comment :PoseLocation "A PoseLocation is a PhysicalLocation. A PoseLocation consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object inherited from the
   PhysicalLocation class (hasPhysicalLocation_RefObject). The data
   for the Point, the ZAxis and the XAxis are expressed relative to the
   coordinate system of the reference object. A PoseLocation must be a
   PoseOnlyLocation, a PoseLocationIn, or a PoseLocationOn")
EquivalentClasses(:PoseLocation ObjectIntersectionOf(ObjectAllValuesFrom(:hasPoseLocation_Point :Point) ObjectSomeValuesFrom(:hasPoseLocation_Point :Point)))
EquivalentClasses(:PoseLocation ObjectIntersectionOf(ObjectAllValuesFrom(:hasPoseLocation_XAxis :Vector) ObjectSomeValuesFrom(:hasPoseLocation_XAxis :Vector)))
EquivalentClasses(:PoseLocation ObjectIntersectionOf(ObjectAllValuesFrom(:hasPoseLocation_ZAxis :Vector) ObjectSomeValuesFrom(:hasPoseLocation_ZAxis :Vector)))
SubClassOf(:PoseLocation :PhysicalLocation)
DisjointUnion(:PoseLocation :PoseLocationIn :PoseLocationOn :PoseOnlyLocation)
Declaration(Class(:PoseLocationIn))
SubClassOf(:PoseLocationIn :PoseLocation)
Declaration(Class(:PoseLocationOn))
SubClassOf(:PoseLocationOn :PoseLocation)
Declaration(Class(:PoseOnlyLocation))
SubClassOf(:PoseOnlyLocation :PoseLocation)
Declaration(Class(:RelativeLocation))
AnnotationAssertion(rdfs:comment :RelativeLocation "A RelativeLocation is a PhysicalLocation. A RelativeLocation
   indicates that one solid object is on or in another solid object.
   A RelativeLocation must be a RelativeLocationIn or a RelativeLocationOn.
   A RelativeLocation has a description (hasRelativeLocation_Description)
   that is a string.")
EquivalentClasses(:RelativeLocation ObjectIntersectionOf(DataAllValuesFrom(:hasRelativeLocation_Description xsd:string) DataSomeValuesFrom(:hasRelativeLocation_Description xsd:string)))
SubClassOf(:RelativeLocation :PhysicalLocation)
DisjointUnion(:RelativeLocation :RelativeLocationOn :RelativeLocationIn)
Declaration(Class(:RelativeLocationIn))
AnnotationAssertion(rdfs:comment :RelativeLocationIn "A RelativeLocationIn is a RelativeLocation. A RelativeLocationIn
   indicates that a SolidObject that has the RelativeLocationIn as the
   value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is inside the
   SolidObject that is the reference object of the RelativeLocationIn.
   The notion of 'inside' is vague and might be made more precise.
   A RelativeLocationIn has a description inherited from RelativeLocation
   (hasRelativeLocation_Description) that is a string.")
SubClassOf(:RelativeLocationIn :RelativeLocation)
Declaration(Class(:RelativeLocationOn))
AnnotationAssertion(rdfs:comment :RelativeLocationOn "A RelativeLocationOn is a RelativeLocation. A RelativeLocationOn
   indicates that a SolidObject that has the RelativeLocationOn as the
   value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is on top of the
   SolidObject that is the reference object of the RelativeLocationOn.
   The notion of 'on top of' is vague and might be made more precise.
   A RelativeLocationOn has a description inherited from RelativeLocation
   (hasRelativeLocation_Description) that is a string.")
SubClassOf(:RelativeLocationOn :RelativeLocation)
Declaration(Class(:Robot))
AnnotationAssertion(rdfs:comment :Robot "The Robot ontology given
   here might be expanded greatly to include, for example, its
   kinematic description, the values of joint angles, arm lengths of
   variable length arms, gripper actuation (open, closed, etc.),
   ranges, velocities, and accelerations of each joint, etc.")
AnnotationAssertion(rdfs:comment :Robot "A Robot is a SolidObject. A Robot currently has a description
   (hasRobot_Description), a work volume (hasRobot_WorkVolume), an end
   effector (hasRobot_EndEffector), and a maximum load weight
   (hasRobot_MaximumLoadWeight). A robot belongs to a
   KittingWorkstation (hadByRobot_Workstation).")
EquivalentClasses(:Robot ObjectIntersectionOf(DataAllValuesFrom(:hasRobot_Description xsd:string) DataSomeValuesFrom(:hasRobot_Description xsd:string)))
EquivalentClasses(:Robot ObjectIntersectionOf(DataAllValuesFrom(:hasRobot_MaximumLoadWeight :positiveDecimal) DataSomeValuesFrom(:hasRobot_MaximumLoadWeight :positiveDecimal)))
SubClassOf(:Robot :SolidObject)
Declaration(Class(:ShapeDesign))
AnnotationAssertion(rdfs:comment :ShapeDesign "A ShapeDesign is a DataThing. This is currently a stub that has
   only a description (hasShapeDesign_Description) that is an xsd:string.")
EquivalentClasses(:ShapeDesign ObjectIntersectionOf(DataAllValuesFrom(:hasShapeDesign_Description xsd:string) DataSomeValuesFrom(:hasShapeDesign_Description xsd:string)))
SubClassOf(:ShapeDesign :DataThing)
Declaration(Class(:SolidObject))
AnnotationAssertion(rdfs:comment :SolidObject "A SolidObject is a Thing. A SolidObject has a location
   (hasSolidObject_PrimaryLocation). This is a
   PhysicalLocation that relates the location of the object to the
   location of some other SolidObject. The location of a SolidObject
   may be on a WorkTable (hadBySolidObject_WorkTable). No SolidObject
   except the Workstation may be located with respect to itself, and
   all chains of primary location must end at the Workstation. The
   location of a SolidObject may be on the WorkTable
   (hadBySolidObject_WorkTable). A SolidObject may have zero to many
   secondary location descriptions
   (hasSolidObject_SecondaryLocation). These are also
   PhysicalLocations. The secondary locations are required to be
   logically and mathematically consistent with the value of
   hasSolidObject_PrimaryLocation so that all locations of a
   SolidObject describe (or are consistent with) a single place in
   space.")
EquivalentClasses(:SolidObject ObjectIntersectionOf(ObjectAllValuesFrom(:hasSolidObject_PrimaryLocation :PhysicalLocation) ObjectSomeValuesFrom(:hasSolidObject_PrimaryLocation :PhysicalLocation)))
DisjointClasses(:SolidObject :DataThing)
DisjointUnion(:SolidObject :BoxyObject :EndEffector :EndEffectorChangingStation :EndEffectorHolder :Kit :KittingWorkstation :LargeBoxWithEmptyKitTrays :LargeBoxWithKits :Part :PartsTrayWithParts :Robot)
Declaration(Class(:StockKeepingUnit))
AnnotationAssertion(rdfs:comment :StockKeepingUnit "A StockKeepingUnit is a DataThing. A StockKeepingUnit is a
   description of a type of object. Every StockKeepingUnit has a
   description (hasSku_Description), a shape (hasSku_Shape), that is a
   ShapeDesign, a weight (hasSku_Weight), and references to the
   ids of EndEffectors that can handle it (hasSku_EndEffectors).
   A StockKeepingUnit belongs to a KittingWorkstation
   (hadBySku_Workstation).")
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(ObjectAllValuesFrom(:hasSku_Shape :ShapeDesign) ObjectSomeValuesFrom(:hasSku_Shape :ShapeDesign)))
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(DataAllValuesFrom(:hasSku_Description xsd:string) DataSomeValuesFrom(:hasSku_Description xsd:string)))
EquivalentClasses(:StockKeepingUnit ObjectIntersectionOf(DataAllValuesFrom(:hasSku_Weight :positiveDecimal) DataSomeValuesFrom(:hasSku_Weight :positiveDecimal)))
SubClassOf(:StockKeepingUnit :DataThing)
Declaration(Class(:VacuumEffector))
AnnotationAssertion(rdfs:comment :VacuumEffector "A VacuumEffector is an EndEffector. A VacuumEffector holds an
   object by putting a cup against the object and applying a vacuum.
   A VacuumEffector is either a VacuumEffectorSingleCup or a
   VacuumEffectorMultiCup.  A VacuumEffector has a cup diameter
   (hasVacuumEffector_CupDiameter) and a length (hasVacuumEffector_Length).")
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(DataAllValuesFrom(:hasVacuumEffector_CupDiameter :positiveDecimal) DataSomeValuesFrom(:hasVacuumEffector_CupDiameter :positiveDecimal)))
EquivalentClasses(:VacuumEffector ObjectIntersectionOf(DataAllValuesFrom(:hasVacuumEffector_Length :positiveDecimal) DataSomeValuesFrom(:hasVacuumEffector_Length :positiveDecimal)))
SubClassOf(:VacuumEffector :EndEffector)
DisjointUnion(:VacuumEffector :VacuumEffectorSingleCup :VacuumEffectorMultiCup)
Declaration(Class(:VacuumEffectorMultiCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup "A VacuumEffectorMultiCup is a VacuumEffector with two or more
   identical cups (hasMultiCup_ArrayNumber).  A VacuumEffectorMultiCup
   has an array radius (hasMultiCup_ArrayRadius).  The cups are
   arranged in a circular array spaced evenly apart. The center of the
   wide end of one cup is on the X-axis of the coordinate system of
   the VacuumEffectorMultiCup. The center of the circular array is at
   the origin of the coordinate system. The axis of the array circle
   is the Z axis of the coordinate system, and the length of the
   VacuumEffector is measured along that axis. The wide ends of the
   cups lie on the XY plane of the coordinate system.")
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup "Note that a square array can be represented easily as circular array.")
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(DataAllValuesFrom(:hasMultiCup_ArrayNumber xsd:positiveInteger) DataSomeValuesFrom(:hasMultiCup_ArrayNumber xsd:positiveInteger)))
EquivalentClasses(:VacuumEffectorMultiCup ObjectIntersectionOf(DataAllValuesFrom(:hasMultiCup_ArrayRadius :positiveDecimal) DataSomeValuesFrom(:hasMultiCup_ArrayRadius :positiveDecimal)))
SubClassOf(:VacuumEffectorMultiCup :VacuumEffector)
Declaration(Class(:VacuumEffectorSingleCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorSingleCup "A VacuumEffectorSingleCup is a VacuumEffector with one cup.
   The center of the wide end of the cup (which is a circle) is at
   the origin of the coordinate system of the VacuumEffectorSingleCup.
   The Z axis of the coordinate system is the axis of that circle,
   and the length of the VacuumEffector is measured along that axis.")
SubClassOf(:VacuumEffectorSingleCup :VacuumEffector)
Declaration(Class(:Vector))
AnnotationAssertion(rdfs:comment :Vector "A Vector is a DataThing. It has I (hasVector_I), J (hasVector_J),
   and K (hasVector_K) components.")
EquivalentClasses(:Vector ObjectIntersectionOf(DataAllValuesFrom(:hasVector_I xsd:decimal) DataSomeValuesFrom(:hasVector_I xsd:decimal)))
EquivalentClasses(:Vector ObjectIntersectionOf(DataAllValuesFrom(:hasVector_J xsd:decimal) DataSomeValuesFrom(:hasVector_J xsd:decimal)))
EquivalentClasses(:Vector ObjectIntersectionOf(DataAllValuesFrom(:hasVector_K xsd:decimal) DataSomeValuesFrom(:hasVector_K xsd:decimal)))
SubClassOf(:Vector :DataThing)
Declaration(Class(:WorkTable))
AnnotationAssertion(rdfs:comment :WorkTable "A WorkTable is a BoxyObject. The top of a WorkTable is a flat,
   rectangular, horizontal surface. The length and width of the top
   are those of the BoxyObject. A WorkTable has solid
   objects that are located with respect to the WorkTable, i.e. the
   reference object of each of those solid objects is the WorkTable
   (hasWorkTable_SolidObjects). Typically, those objects will be on
   top of the WorkTable. This property may be deduced by finding all
   the objects located with respect to the WorkTable, so care will be
   required to keep the values of the hasWorkTable_SolidObjects and
   hasPhysicalLocation_RefObject properties consistent. A WorkTable
   belongs to a Workstation (hadByWorkTable_Workstation).")
SubClassOf(:WorkTable :BoxyObject)
Declaration(ObjectProperty(:hadByChangingStation_Workstation))
AnnotationAssertion(rdfs:comment :hadByChangingStation_Workstation "An EndEffectorChangingStation belongs to a KittingWorkstation.")
InverseObjectProperties(:hasWorkstation_ChangingStation :hadByChangingStation_Workstation)
FunctionalObjectProperty(:hadByChangingStation_Workstation)
InverseFunctionalObjectProperty(:hadByChangingStation_Workstation)
ObjectPropertyDomain(:hadByChangingStation_Workstation :EndEffectorChangingStation)
ObjectPropertyRange(:hadByChangingStation_Workstation :KittingWorkstation)
Declaration(ObjectProperty(:hadByEndEffectorHolder_ChangingStation))
AnnotationAssertion(rdfs:comment :hadByEndEffectorHolder_ChangingStation "An EndEffectorHolder belongs to an EndEffectorChangingStation.")
InverseObjectProperties(:hasChangingStation_EndEffectorHolders :hadByEndEffectorHolder_ChangingStation)
FunctionalObjectProperty(:hadByEndEffectorHolder_ChangingStation)
ObjectPropertyDomain(:hadByEndEffectorHolder_ChangingStation :EndEffectorHolder)
ObjectPropertyRange(:hadByEndEffectorHolder_ChangingStation :EndEffectorChangingStation)
Declaration(ObjectProperty(:hadByEndEffector_EndEffectorHolder))
AnnotationAssertion(rdfs:comment :hadByEndEffector_EndEffectorHolder "An EndEffector may be in an EndEffectorHolder.")
InverseObjectProperties(:hasEndEffectorHolder_EndEffector :hadByEndEffector_EndEffectorHolder)
FunctionalObjectProperty(:hadByEndEffector_EndEffectorHolder)
ObjectPropertyDomain(:hadByEndEffector_EndEffectorHolder :EndEffector)
ObjectPropertyRange(:hadByEndEffector_EndEffectorHolder :EndEffectorHolder)
Declaration(ObjectProperty(:hadByEndEffector_Robot))
AnnotationAssertion(rdfs:comment :hadByEndEffector_Robot "An EndEffector may belong to a Robot.")
InverseObjectProperties(:hasRobot_EndEffector :hadByEndEffector_Robot)
FunctionalObjectProperty(:hadByEndEffector_Robot)
ObjectPropertyDomain(:hadByEndEffector_Robot :EndEffector)
ObjectPropertyRange(:hadByEndEffector_Robot :Robot)
Declaration(ObjectProperty(:hadByKitDesign_Workstation))
AnnotationAssertion(rdfs:comment :hadByKitDesign_Workstation "A KitDesign belongs to a KittingWorkstation.")
InverseObjectProperties(:hasWorkstation_KitDesigns :hadByKitDesign_Workstation)
FunctionalObjectProperty(:hadByKitDesign_Workstation)
ObjectPropertyDomain(:hadByKitDesign_Workstation :KitDesign)
ObjectPropertyRange(:hadByKitDesign_Workstation :KittingWorkstation)
Declaration(ObjectProperty(:hadByKitTray_Kit))
AnnotationAssertion(rdfs:comment :hadByKitTray_Kit "A KitTray may belong to a Kit.")
InverseObjectProperties(:hasKit_Tray :hadByKitTray_Kit)
FunctionalObjectProperty(:hadByKitTray_Kit)
ObjectPropertyDomain(:hadByKitTray_Kit :KitTray)
ObjectPropertyRange(:hadByKitTray_Kit :Kit)
Declaration(ObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByKitTray_LargeBoxWithEmptyKitTrays "A KitTray may belong to a LargeBoxWithEmptyKitTrays.")
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_KitTrays :hadByKitTray_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByKitTray_LargeBoxWithEmptyKitTrays :KitTray)
ObjectPropertyRange(:hadByKitTray_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)
Declaration(ObjectProperty(:hadByKit_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByKit_LargeBoxWithKits "A Kit may belong to a LargeBoxWithKits.")
InverseObjectProperties(:hasLargeBoxWithKits_Kits :hadByKit_LargeBoxWithKits)
FunctionalObjectProperty(:hadByKit_LargeBoxWithKits)
ObjectPropertyDomain(:hadByKit_LargeBoxWithKits :Kit)
ObjectPropertyRange(:hadByKit_LargeBoxWithKits :LargeBoxWithKits)
Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithEmptyKitTrays "A LargeContainer may belong to a LargeBoxWithEmptyKitTrays.")
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_LargeContainer :hadByLargeContainer_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithEmptyKitTrays :LargeBoxWithEmptyKitTrays)
Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithKits "A LargeContainer may belong to a LargeBoxWithKits.")
InverseObjectProperties(:hasLargeBoxWithKits_LargeContainer :hadByLargeContainer_LargeBoxWithKits)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithKits)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithKits :LargeContainer)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithKits :LargeBoxWithKits)
Declaration(ObjectProperty(:hadByPartRefAndPose_KitDesign))
AnnotationAssertion(rdfs:comment :hadByPartRefAndPose_KitDesign "A PartRefAndPose belongs to a KitDesign.")
InverseObjectProperties(:hasKitDesign_PartRefAndPoses :hadByPartRefAndPose_KitDesign)
FunctionalObjectProperty(:hadByPartRefAndPose_KitDesign)
ObjectPropertyDomain(:hadByPartRefAndPose_KitDesign :PartRefAndPose)
ObjectPropertyRange(:hadByPartRefAndPose_KitDesign :KitDesign)
Declaration(ObjectProperty(:hadByPart_Kit))
AnnotationAssertion(rdfs:comment :hadByPart_Kit "A Part may belong to a Kit.")
InverseObjectProperties(:hasKit_Parts :hadByPart_Kit)
FunctionalObjectProperty(:hadByPart_Kit)
ObjectPropertyDomain(:hadByPart_Kit :Part)
ObjectPropertyRange(:hadByPart_Kit :Kit)
Declaration(ObjectProperty(:hadByPart_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPart_PartsTrayWithParts "A Part may belong to a PartsTrayWithParts.")
InverseObjectProperties(:hasPartsTrayWithParts_Parts :hadByPart_PartsTrayWithParts)
FunctionalObjectProperty(:hadByPart_PartsTrayWithParts)
ObjectPropertyDomain(:hadByPart_PartsTrayWithParts :Part)
ObjectPropertyRange(:hadByPart_PartsTrayWithParts :PartsTrayWithParts)
Declaration(ObjectProperty(:hadByPartsTray_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPartsTray_PartsTrayWithParts "A PartsTray may belong to a PartsTrayWithParts.")
InverseObjectProperties(:hasPartsTrayWithParts_Tray :hadByPartsTray_PartsTrayWithParts)
FunctionalObjectProperty(:hadByPartsTray_PartsTrayWithParts)
ObjectPropertyDomain(:hadByPartsTray_PartsTrayWithParts :PartsTray)
ObjectPropertyRange(:hadByPartsTray_PartsTrayWithParts :PartsTrayWithParts)
Declaration(ObjectProperty(:hadByRobot_Workstation))
AnnotationAssertion(rdfs:comment :hadByRobot_Workstation "A Robot belongs to a KittingWorkstation.")
InverseObjectProperties(:hasWorkstation_Robot :hadByRobot_Workstation)
FunctionalObjectProperty(:hadByRobot_Workstation)
InverseFunctionalObjectProperty(:hadByRobot_Workstation)
ObjectPropertyDomain(:hadByRobot_Workstation :Robot)
ObjectPropertyRange(:hadByRobot_Workstation :KittingWorkstation)
Declaration(ObjectProperty(:hadBySku_Workstation))
AnnotationAssertion(rdfs:comment :hadBySku_Workstation "A StockKeepingUnit belongs to a KittingWorkstation.")
InverseObjectProperties(:hasWorkstation_Skus :hadBySku_Workstation)
FunctionalObjectProperty(:hadBySku_Workstation)
ObjectPropertyDomain(:hadBySku_Workstation :StockKeepingUnit)
ObjectPropertyRange(:hadBySku_Workstation :KittingWorkstation)
Declaration(ObjectProperty(:hadBySolidObject_WorkTable))
AnnotationAssertion(rdfs:comment :hadBySolidObject_WorkTable "A SolidObject may belong to a WorkTable.")
InverseObjectProperties(:hasWorkTable_SolidObjects :hadBySolidObject_WorkTable)
FunctionalObjectProperty(:hadBySolidObject_WorkTable)
ObjectPropertyDomain(:hadBySolidObject_WorkTable :SolidObject)
ObjectPropertyRange(:hadBySolidObject_WorkTable :WorkTable)
Declaration(ObjectProperty(:hadByWorkTable_Workstation))
AnnotationAssertion(rdfs:comment :hadByWorkTable_Workstation "A WorkTable belongs to a KittingWorkstation.")
InverseObjectProperties(:hasWorkstation_WorkTable :hadByWorkTable_Workstation)
FunctionalObjectProperty(:hadByWorkTable_Workstation)
InverseFunctionalObjectProperty(:hadByWorkTable_Workstation)
ObjectPropertyDomain(:hadByWorkTable_Workstation :WorkTable)
ObjectPropertyRange(:hadByWorkTable_Workstation :KittingWorkstation)
Declaration(ObjectProperty(:hasBoxVolume_MaximumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MaximumPoint "A BoxVolume has a maximum Point.")
FunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
ObjectPropertyDomain(:hasBoxVolume_MaximumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MaximumPoint :Point)
Declaration(ObjectProperty(:hasBoxVolume_MinimumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MinimumPoint "A BoxVolume has a minimum Point.")
FunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
ObjectPropertyDomain(:hasBoxVolume_MinimumPoint :BoxVolume)
ObjectPropertyRange(:hasBoxVolume_MinimumPoint :Point)
Declaration(ObjectProperty(:hasChangingStation_EndEffectorHolders))
AnnotationAssertion(rdfs:comment :hasChangingStation_EndEffectorHolders "An EndEffectorChangingStation has EndEffectorHolders.")
InverseObjectProperties(:hasChangingStation_EndEffectorHolders :hadByEndEffectorHolder_ChangingStation)
InverseFunctionalObjectProperty(:hasChangingStation_EndEffectorHolders)
ObjectPropertyDomain(:hasChangingStation_EndEffectorHolders :EndEffectorChangingStation)
ObjectPropertyRange(:hasChangingStation_EndEffectorHolders :EndEffectorHolder)
Declaration(ObjectProperty(:hasEndEffectorHolder_EndEffector))
AnnotationAssertion(rdfs:comment :hasEndEffectorHolder_EndEffector "An EndEffectorHolder holds zero or one EndEffector.")
InverseObjectProperties(:hasEndEffectorHolder_EndEffector :hadByEndEffector_EndEffectorHolder)
FunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
InverseFunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
ObjectPropertyDomain(:hasEndEffectorHolder_EndEffector :EndEffectorHolder)
ObjectPropertyRange(:hasEndEffectorHolder_EndEffector :EndEffector)
Declaration(ObjectProperty(:hasKitDesign_KitTraySku))
AnnotationAssertion(rdfs:comment :hasKitDesign_KitTraySku "A KitDesign has a StockKeepingUnit for the Tray.")
FunctionalObjectProperty(:hasKitDesign_KitTraySku)
ObjectPropertyDomain(:hasKitDesign_KitTraySku :KitDesign)
ObjectPropertyRange(:hasKitDesign_KitTraySku :StockKeepingUnit)
Declaration(ObjectProperty(:hasKitDesign_PartRefAndPoses))
AnnotationAssertion(rdfs:comment :hasKitDesign_PartRefAndPoses "A KitDesign has PartRefAndPoses.")
InverseObjectProperties(:hasKitDesign_PartRefAndPoses :hadByPartRefAndPose_KitDesign)
InverseFunctionalObjectProperty(:hasKitDesign_PartRefAndPoses)
ObjectPropertyDomain(:hasKitDesign_PartRefAndPoses :KitDesign)
ObjectPropertyRange(:hasKitDesign_PartRefAndPoses :PartRefAndPose)
Declaration(ObjectProperty(:hasKitTray_Sku))
AnnotationAssertion(rdfs:comment :hasKitTray_Sku "A KitTray has a StockKeepingUnit that describes it.")
FunctionalObjectProperty(:hasKitTray_Sku)
ObjectPropertyDomain(:hasKitTray_Sku :KitTray)
ObjectPropertyRange(:hasKitTray_Sku :StockKeepingUnit)
Declaration(ObjectProperty(:hasKit_Design))
AnnotationAssertion(rdfs:comment :hasKit_Design "A Kit has a Design.")
FunctionalObjectProperty(:hasKit_Design)
ObjectPropertyDomain(:hasKit_Design :Kit)
ObjectPropertyRange(:hasKit_Design :KitDesign)
Declaration(ObjectProperty(:hasKit_Parts))
AnnotationAssertion(rdfs:comment :hasKit_Parts "A Kit has zero to many Parts.")
InverseObjectProperties(:hasKit_Parts :hadByPart_Kit)
InverseFunctionalObjectProperty(:hasKit_Parts)
ObjectPropertyDomain(:hasKit_Parts :Kit)
ObjectPropertyRange(:hasKit_Parts :Part)
Declaration(ObjectProperty(:hasKit_Tray))
AnnotationAssertion(rdfs:comment :hasKit_Tray "A Kit has a KitTray.")
InverseObjectProperties(:hasKit_Tray :hadByKitTray_Kit)
FunctionalObjectProperty(:hasKit_Tray)
InverseFunctionalObjectProperty(:hasKit_Tray)
ObjectPropertyDomain(:hasKit_Tray :Kit)
ObjectPropertyRange(:hasKit_Tray :KitTray)
Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_KitTrays "A LargeBoxWithEmptyKitTrays has zero to many KitTrays.")
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_KitTrays :hadByKitTray_LargeBoxWithEmptyKitTrays)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_KitTrays :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_KitTrays :KitTray)
Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_LargeContainer "A LargeBoxWithEmptyKitTrays has a LargeContainer.")
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_LargeContainer :hadByLargeContainer_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_LargeContainer :LargeContainer)
Declaration(ObjectProperty(:hasLargeBoxWithKits_KitDesign))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_KitDesign "A LargeBoxWithKits has a KitDesign for the Kits in the Box.")
FunctionalObjectProperty(:hasLargeBoxWithKits_KitDesign)
ObjectPropertyDomain(:hasLargeBoxWithKits_KitDesign :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_KitDesign :KitDesign)
Declaration(ObjectProperty(:hasLargeBoxWithKits_Kits))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_Kits "A LargeBoxWithKits has zero to many Kits.")
InverseObjectProperties(:hasLargeBoxWithKits_Kits :hadByKit_LargeBoxWithKits)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_Kits)
ObjectPropertyDomain(:hasLargeBoxWithKits_Kits :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_Kits :Kit)
Declaration(ObjectProperty(:hasLargeBoxWithKits_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_LargeContainer "A LargeBoxWithKits has a LargeContainer.")
InverseObjectProperties(:hasLargeBoxWithKits_LargeContainer :hadByLargeContainer_LargeBoxWithKits)
FunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
ObjectPropertyDomain(:hasLargeBoxWithKits_LargeContainer :LargeBoxWithKits)
ObjectPropertyRange(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
Declaration(ObjectProperty(:hasLargeContainer_Sku))
AnnotationAssertion(rdfs:comment :hasLargeContainer_Sku "A LargeContainer has a StockKeepingUnit that describes it.")
FunctionalObjectProperty(:hasLargeContainer_Sku)
ObjectPropertyDomain(:hasLargeContainer_Sku :LargeContainer)
ObjectPropertyRange(:hasLargeContainer_Sku :StockKeepingUnit)
Declaration(ObjectProperty(:hasPartRefAndPose_Point))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Point "A PartRefAndPose has a Point.")
FunctionalObjectProperty(:hasPartRefAndPose_Point)
ObjectPropertyDomain(:hasPartRefAndPose_Point :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Point :Point)
Declaration(ObjectProperty(:hasPartRefAndPose_Sku))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Sku "A PartRefAndPose has the StockKeepingUnit of a Part.")
FunctionalObjectProperty(:hasPartRefAndPose_Sku)
ObjectPropertyDomain(:hasPartRefAndPose_Sku :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_Sku :StockKeepingUnit)
Declaration(ObjectProperty(:hasPartRefAndPose_XAxis))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_XAxis "A PartRefAndPose has an X axis Vector.")
FunctionalObjectProperty(:hasPartRefAndPose_XAxis)
ObjectPropertyDomain(:hasPartRefAndPose_XAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_XAxis :Vector)
Declaration(ObjectProperty(:hasPartRefAndPose_ZAxis))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_ZAxis "A PartRefAndPose has a Z axis Vector.")
FunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
ObjectPropertyDomain(:hasPartRefAndPose_ZAxis :PartRefAndPose)
ObjectPropertyRange(:hasPartRefAndPose_ZAxis :Vector)
Declaration(ObjectProperty(:hasPart_Sku))
AnnotationAssertion(rdfs:comment :hasPart_Sku "A Part has a StockKeepingUnit that describes it.")
FunctionalObjectProperty(:hasPart_Sku)
ObjectPropertyDomain(:hasPart_Sku :Part)
ObjectPropertyRange(:hasPart_Sku :StockKeepingUnit)
Declaration(ObjectProperty(:hasPartsBin_PartSku))
AnnotationAssertion(rdfs:comment :hasPartsBin_PartSku "A PartsBin has a StockKeepingUnit for the type of Part it contains.")
FunctionalObjectProperty(:hasPartsBin_PartSku)
ObjectPropertyDomain(:hasPartsBin_PartSku :PartsBin)
ObjectPropertyRange(:hasPartsBin_PartSku :StockKeepingUnit)
Declaration(ObjectProperty(:hasPartsTrayWithParts_Parts))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_Parts "A PartsTrayWithParts has zero to many Parts.")
InverseObjectProperties(:hasPartsTrayWithParts_Parts :hadByPart_PartsTrayWithParts)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Parts)
ObjectPropertyDomain(:hasPartsTrayWithParts_Parts :PartsTrayWithParts)
ObjectPropertyRange(:hasPartsTrayWithParts_Parts :Part)
Declaration(ObjectProperty(:hasPartsTrayWithParts_Tray))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_Tray "A PartsTrayWithParts has a PartsTray.")
InverseObjectProperties(:hasPartsTrayWithParts_Tray :hadByPartsTray_PartsTrayWithParts)
FunctionalObjectProperty(:hasPartsTrayWithParts_Tray)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Tray)
ObjectPropertyDomain(:hasPartsTrayWithParts_Tray :PartsTrayWithParts)
ObjectPropertyRange(:hasPartsTrayWithParts_Tray :PartsTray)
Declaration(ObjectProperty(:hasPartsTray_Sku))
AnnotationAssertion(rdfs:comment :hasPartsTray_Sku "A PartsTray has a StockKeepingUnit that describes it.")
FunctionalObjectProperty(:hasPartsTray_Sku)
ObjectPropertyDomain(:hasPartsTray_Sku :PartsTray)
ObjectPropertyRange(:hasPartsTray_Sku :StockKeepingUnit)
Declaration(ObjectProperty(:hasPhysicalLocation_RefObject))
AnnotationAssertion(rdfs:comment :hasPhysicalLocation_RefObject "A PhysicalLocation L has a reference object O that is a
   SolidObject.  If L is a PoseLocation (i.e., a PoseOnlyLocation, a
   PoseLocationIn, or a PoseLocationOn), the coordinate system of O is
   the reference coordinate system for the PoseLocation, and the
   PoseLocation locates a referencing object R. If L is a
   PoseLocationIn, a PoseLocationOn, a RelativeLocationIn, or a
   RelativeLocationOn, O is the SolidObject that R is inside of or
   on. R is a SolidObject that hasSolidObject_PrimaryLocation
   L or hasSolidObject_SecondaryLocation L.")
FunctionalObjectProperty(:hasPhysicalLocation_RefObject)
ObjectPropertyDomain(:hasPhysicalLocation_RefObject :PhysicalLocation)
ObjectPropertyRange(:hasPhysicalLocation_RefObject :SolidObject)
Declaration(ObjectProperty(:hasPoseLocation_Point))
AnnotationAssertion(rdfs:comment :hasPoseLocation_Point "A PoseLocation has a pose point that is a Point. The origin of the
   coordinate system of the SolidObject that is located by the
   PoseLocation is placed at the pose point.")
FunctionalObjectProperty(:hasPoseLocation_Point)
ObjectPropertyDomain(:hasPoseLocation_Point :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_Point :Point)
Declaration(ObjectProperty(:hasPoseLocation_XAxis))
AnnotationAssertion(rdfs:comment :hasPoseLocation_XAxis "A PoseLocation has an X axis Vector. The positive X axis of the
   coordinate system of the SolidObject that is located by the
   PoseLocation points in the direction of this Vector.")
FunctionalObjectProperty(:hasPoseLocation_XAxis)
ObjectPropertyDomain(:hasPoseLocation_XAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_XAxis :Vector)
Declaration(ObjectProperty(:hasPoseLocation_ZAxis))
AnnotationAssertion(rdfs:comment :hasPoseLocation_ZAxis "A PoseLocation has a Z axis Vector. The positive Z axis of the
   coordinate system of the SolidObject that is located by the
   PoseLocation points in the direction of this Vector.")
FunctionalObjectProperty(:hasPoseLocation_ZAxis)
ObjectPropertyDomain(:hasPoseLocation_ZAxis :PoseLocation)
ObjectPropertyRange(:hasPoseLocation_ZAxis :Vector)
Declaration(ObjectProperty(:hasRobot_EndEffector))
AnnotationAssertion(rdfs:comment :hasRobot_EndEffector "A Robot has zero or one EndEffector.")
InverseObjectProperties(:hasRobot_EndEffector :hadByEndEffector_Robot)
FunctionalObjectProperty(:hasRobot_EndEffector)
InverseFunctionalObjectProperty(:hasRobot_EndEffector)
ObjectPropertyDomain(:hasRobot_EndEffector :Robot)
ObjectPropertyRange(:hasRobot_EndEffector :EndEffector)
Declaration(ObjectProperty(:hasRobot_WorkVolume))
AnnotationAssertion(rdfs:comment :hasRobot_WorkVolume "A Robot has a work volume that is the union of one to many BoxVolumes
   representing space into which the robot can move its end effector in
   the absence of other obstacles. The coordinate system of the BoxVolumes
   is the coordinate system of the robot.")
ObjectPropertyDomain(:hasRobot_WorkVolume :Robot)
ObjectPropertyRange(:hasRobot_WorkVolume :BoxVolume)
Declaration(ObjectProperty(:hasSku_EndEffectors))
AnnotationAssertion(rdfs:comment :hasSku_EndEffectors "A StockKeepingUnit has EndEffectors that can handle the StockKeepingUnit.")
ObjectPropertyDomain(:hasSku_EndEffectors :StockKeepingUnit)
ObjectPropertyRange(:hasSku_EndEffectors :EndEffector)
Declaration(ObjectProperty(:hasSku_Shape))
AnnotationAssertion(rdfs:comment :hasSku_Shape "A StockKeepingUnit has a ShapeDesign.")
FunctionalObjectProperty(:hasSku_Shape)
ObjectPropertyDomain(:hasSku_Shape :StockKeepingUnit)
ObjectPropertyRange(:hasSku_Shape :ShapeDesign)
Declaration(ObjectProperty(:hasSolidObject_PrimaryLocation))
AnnotationAssertion(rdfs:comment :hasSolidObject_PrimaryLocation "All SolidObjects have a primary PhysicalLocation, and (in this
   ontology, which does not deal with liquid or gas objects) only
   SolidObjects have one.")
FunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
ObjectPropertyDomain(:hasSolidObject_PrimaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_PrimaryLocation :PhysicalLocation)
Declaration(ObjectProperty(:hasSolidObject_SecondaryLocation))
AnnotationAssertion(rdfs:comment :hasSolidObject_SecondaryLocation "A SolidObject may have zero to many secondary PhysicalLocations.")
ObjectPropertyDomain(:hasSolidObject_SecondaryLocation :SolidObject)
ObjectPropertyRange(:hasSolidObject_SecondaryLocation :PhysicalLocation)
Declaration(ObjectProperty(:hasWorkTable_SolidObjects))
AnnotationAssertion(rdfs:comment :hasWorkTable_SolidObjects "A WorkTable has SolidObjects located with respect to itself.")
InverseObjectProperties(:hasWorkTable_SolidObjects :hadBySolidObject_WorkTable)
InverseFunctionalObjectProperty(:hasWorkTable_SolidObjects)
ObjectPropertyDomain(:hasWorkTable_SolidObjects :WorkTable)
ObjectPropertyRange(:hasWorkTable_SolidObjects :SolidObject)
Declaration(ObjectProperty(:hasWorkstation_ChangingStation))
AnnotationAssertion(rdfs:comment :hasWorkstation_ChangingStation "A KittingWorkstation has an EndEffectorChangingStation.")
InverseObjectProperties(:hasWorkstation_ChangingStation :hadByChangingStation_Workstation)
FunctionalObjectProperty(:hasWorkstation_ChangingStation)
InverseFunctionalObjectProperty(:hasWorkstation_ChangingStation)
ObjectPropertyDomain(:hasWorkstation_ChangingStation :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_ChangingStation :EndEffectorChangingStation)
Declaration(ObjectProperty(:hasWorkstation_KitDesigns))
AnnotationAssertion(rdfs:comment :hasWorkstation_KitDesigns "A KittingWorkstation has a library of KitDesigns which contains
   KitDesigns.")
InverseObjectProperties(:hasWorkstation_KitDesigns :hadByKitDesign_Workstation)
InverseFunctionalObjectProperty(:hasWorkstation_KitDesigns)
ObjectPropertyDomain(:hasWorkstation_KitDesigns :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_KitDesigns :KitDesign)
Declaration(ObjectProperty(:hasWorkstation_OtherObstacles))
AnnotationAssertion(rdfs:comment :hasWorkstation_OtherObstacles "A KittingWorkstation has other obstacles that are described by
   BoxVolumes representing occupied space through which the robot
   should not attempt to move The coordinate system of the BoxVolumes
   is the coordinate system of the KittingWorkstation.")
ObjectPropertyDomain(:hasWorkstation_OtherObstacles :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_OtherObstacles :BoxVolume)
Declaration(ObjectProperty(:hasWorkstation_Robot))
AnnotationAssertion(rdfs:comment :hasWorkstation_Robot "A KittingWorkstation has a Robot.")
InverseObjectProperties(:hasWorkstation_Robot :hadByRobot_Workstation)
FunctionalObjectProperty(:hasWorkstation_Robot)
InverseFunctionalObjectProperty(:hasWorkstation_Robot)
ObjectPropertyDomain(:hasWorkstation_Robot :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_Robot :Robot)
Declaration(ObjectProperty(:hasWorkstation_Skus))
AnnotationAssertion(rdfs:comment :hasWorkstation_Skus "A KittingWorkstation has a library of Skus, which contains
   StockKeepingUnits.")
InverseObjectProperties(:hasWorkstation_Skus :hadBySku_Workstation)
InverseFunctionalObjectProperty(:hasWorkstation_Skus)
ObjectPropertyDomain(:hasWorkstation_Skus :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_Skus :StockKeepingUnit)
Declaration(ObjectProperty(:hasWorkstation_WorkTable))
AnnotationAssertion(rdfs:comment :hasWorkstation_WorkTable "A KittingWorkstation has a WorkTable.")
InverseObjectProperties(:hasWorkstation_WorkTable :hadByWorkTable_Workstation)
FunctionalObjectProperty(:hasWorkstation_WorkTable)
InverseFunctionalObjectProperty(:hasWorkstation_WorkTable)
ObjectPropertyDomain(:hasWorkstation_WorkTable :KittingWorkstation)
ObjectPropertyRange(:hasWorkstation_WorkTable :WorkTable)
Declaration(DataProperty(:hasBox_Height))
FunctionalDataProperty(:hasBox_Height)
DataPropertyDomain(:hasBox_Height :BoxyObject)
DataPropertyRange(:hasBox_Height :positiveDecimal)
Declaration(DataProperty(:hasBox_Length))
FunctionalDataProperty(:hasBox_Length)
DataPropertyDomain(:hasBox_Length :BoxyObject)
DataPropertyRange(:hasBox_Length :positiveDecimal)
Declaration(DataProperty(:hasBox_Width))
FunctionalDataProperty(:hasBox_Width)
DataPropertyDomain(:hasBox_Width :BoxyObject)
DataPropertyRange(:hasBox_Width :positiveDecimal)
Declaration(DataProperty(:hasEffector_MaximumLoadWeight))
FunctionalDataProperty(:hasEffector_MaximumLoadWeight)
DataPropertyDomain(:hasEffector_MaximumLoadWeight :EndEffector)
DataPropertyRange(:hasEffector_MaximumLoadWeight :positiveDecimal)
Declaration(DataProperty(:hasEndEffector_Description))
FunctionalDataProperty(:hasEndEffector_Description)
DataPropertyDomain(:hasEndEffector_Description :EndEffector)
DataPropertyRange(:hasEndEffector_Description xsd:string)
Declaration(DataProperty(:hasEndEffector_Weight))
FunctionalDataProperty(:hasEndEffector_Weight)
DataPropertyDomain(:hasEndEffector_Weight :EndEffector)
DataPropertyRange(:hasEndEffector_Weight :positiveDecimal)
Declaration(DataProperty(:hasKitTray_SerialNumber))
FunctionalDataProperty(:hasKitTray_SerialNumber)
DataPropertyDomain(:hasKitTray_SerialNumber :KitTray)
DataPropertyRange(:hasKitTray_SerialNumber xsd:NMTOKEN)
Declaration(DataProperty(:hasLargeBoxWithKits_Capacity))
FunctionalDataProperty(:hasLargeBoxWithKits_Capacity)
DataPropertyDomain(:hasLargeBoxWithKits_Capacity :LargeBoxWithKits)
DataPropertyRange(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
Declaration(DataProperty(:hasLargeContainer_SerialNumber))
FunctionalDataProperty(:hasLargeContainer_SerialNumber)
DataPropertyDomain(:hasLargeContainer_SerialNumber :LargeContainer)
DataPropertyRange(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
Declaration(DataProperty(:hasMultiCup_ArrayNumber))
FunctionalDataProperty(:hasMultiCup_ArrayNumber)
DataPropertyDomain(:hasMultiCup_ArrayNumber :VacuumEffectorMultiCup)
DataPropertyRange(:hasMultiCup_ArrayNumber xsd:positiveInteger)
Declaration(DataProperty(:hasMultiCup_ArrayRadius))
FunctionalDataProperty(:hasMultiCup_ArrayRadius)
DataPropertyDomain(:hasMultiCup_ArrayRadius :VacuumEffectorMultiCup)
DataPropertyRange(:hasMultiCup_ArrayRadius :positiveDecimal)
Declaration(DataProperty(:hasPart_SerialNumber))
FunctionalDataProperty(:hasPart_SerialNumber)
DataPropertyDomain(:hasPart_SerialNumber :Part)
DataPropertyRange(:hasPart_SerialNumber xsd:NMTOKEN)
Declaration(DataProperty(:hasPartsBin_PartQuantity))
FunctionalDataProperty(:hasPartsBin_PartQuantity)
DataPropertyDomain(:hasPartsBin_PartQuantity :PartsBin)
DataPropertyRange(:hasPartsBin_PartQuantity xsd:nonNegativeInteger)
Declaration(DataProperty(:hasPartsTray_SerialNumber))
FunctionalDataProperty(:hasPartsTray_SerialNumber)
DataPropertyDomain(:hasPartsTray_SerialNumber :PartsTray)
DataPropertyRange(:hasPartsTray_SerialNumber xsd:NMTOKEN)
Declaration(DataProperty(:hasPoint_X))
FunctionalDataProperty(:hasPoint_X)
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyRange(:hasPoint_X xsd:decimal)
Declaration(DataProperty(:hasPoint_Y))
FunctionalDataProperty(:hasPoint_Y)
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyRange(:hasPoint_Y xsd:decimal)
Declaration(DataProperty(:hasPoint_Z))
FunctionalDataProperty(:hasPoint_Z)
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyRange(:hasPoint_Z xsd:decimal)
Declaration(DataProperty(:hasRelativeLocation_Description))
FunctionalDataProperty(:hasRelativeLocation_Description)
DataPropertyDomain(:hasRelativeLocation_Description :RelativeLocation)
DataPropertyRange(:hasRelativeLocation_Description xsd:string)
Declaration(DataProperty(:hasRobot_Description))
FunctionalDataProperty(:hasRobot_Description)
DataPropertyDomain(:hasRobot_Description :Robot)
DataPropertyRange(:hasRobot_Description xsd:string)
Declaration(DataProperty(:hasRobot_MaximumLoadWeight))
AnnotationAssertion(rdfs:comment :hasRobot_MaximumLoadWeight "The maximum load weight includes the weight of the end effector.")
FunctionalDataProperty(:hasRobot_MaximumLoadWeight)
DataPropertyDomain(:hasRobot_MaximumLoadWeight :Robot)
DataPropertyRange(:hasRobot_MaximumLoadWeight :positiveDecimal)
Declaration(DataProperty(:hasShapeDesign_Description))
FunctionalDataProperty(:hasShapeDesign_Description)
DataPropertyDomain(:hasShapeDesign_Description :ShapeDesign)
DataPropertyRange(:hasShapeDesign_Description xsd:string)
Declaration(DataProperty(:hasSku_Description))
FunctionalDataProperty(:hasSku_Description)
DataPropertyDomain(:hasSku_Description :StockKeepingUnit)
DataPropertyRange(:hasSku_Description xsd:string)
Declaration(DataProperty(:hasSku_Weight))
FunctionalDataProperty(:hasSku_Weight)
DataPropertyDomain(:hasSku_Weight :StockKeepingUnit)
DataPropertyRange(:hasSku_Weight :positiveDecimal)
Declaration(DataProperty(:hasVacuumEffector_CupDiameter))
FunctionalDataProperty(:hasVacuumEffector_CupDiameter)
DataPropertyDomain(:hasVacuumEffector_CupDiameter :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_CupDiameter :positiveDecimal)
Declaration(DataProperty(:hasVacuumEffector_Length))
FunctionalDataProperty(:hasVacuumEffector_Length)
DataPropertyDomain(:hasVacuumEffector_Length :VacuumEffector)
DataPropertyRange(:hasVacuumEffector_Length :positiveDecimal)
Declaration(DataProperty(:hasVector_I))
FunctionalDataProperty(:hasVector_I)
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyRange(:hasVector_I xsd:decimal)
Declaration(DataProperty(:hasVector_J))
FunctionalDataProperty(:hasVector_J)
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyRange(:hasVector_J xsd:decimal)
Declaration(DataProperty(:hasVector_K))
FunctionalDataProperty(:hasVector_K)
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyRange(:hasVector_K xsd:decimal)
Declaration(DataProperty(:hasWorkstation_AngleUnit))
FunctionalDataProperty(:hasWorkstation_AngleUnit)
DataPropertyDomain(:hasWorkstation_AngleUnit :KittingWorkstation)
DataPropertyRange(:hasWorkstation_AngleUnit :angleUnit)
Declaration(DataProperty(:hasWorkstation_LengthUnit))
FunctionalDataProperty(:hasWorkstation_LengthUnit)
DataPropertyDomain(:hasWorkstation_LengthUnit :KittingWorkstation)
DataPropertyRange(:hasWorkstation_LengthUnit :lengthUnit)
Declaration(DataProperty(:hasWorkstation_WeightUnit))
FunctionalDataProperty(:hasWorkstation_WeightUnit)
DataPropertyDomain(:hasWorkstation_WeightUnit :KittingWorkstation)
DataPropertyRange(:hasWorkstation_WeightUnit :weightUnit)
Declaration(DataProperty(:isKit_Finished))
FunctionalDataProperty(:isKit_Finished)
DataPropertyDomain(:isKit_Finished :Kit)
DataPropertyRange(:isKit_Finished xsd:boolean)
DatatypeDefinition(:angleUnit DataOneOf("radian" "degree"))
DatatypeDefinition(:lengthUnit DataOneOf("inch" "meter" "millimeter"))
DatatypeDefinition(:positiveDecimal DatatypeRestriction(xsd:decimal xsd:minExclusive "0"^^xsd:decimal))
DatatypeDefinition(:weightUnit DataOneOf("gram" "kilogram" "milligram" "ounce" "pound"))
HasKey(:LargeContainer (:hasLargeContainer_Sku) (:hasLargeContainer_SerialNumber))
HasKey(:KitTray (:hasKitTray_Sku) (:hasKitTray_SerialNumber))
HasKey(:PartsTray (:hasPartsTray_Sku) (:hasPartsTray_SerialNumber))
HasKey(:Part (:hasPart_Sku) (:hasPart_SerialNumber))
)
