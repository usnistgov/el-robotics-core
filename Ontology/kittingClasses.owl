Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingClasses.owl#>)

Ontology(<http://www.nist.gov/el/ontologies/kittingClasses.owl>
Annotation(rdfs:comment "A kitting ontology")

Annotation(rdfs:comment "This does not include plans or individuals.")

Annotation(rdfs:comment "The name of an identifier that is used by a
member of a class to identify itself always ends with 'Id'.  The name
of an identifier that identifies a member of some class other than the
one it is in always ends with 'Ref'.  Where a DataThing may be used by
several other things, it is given an xxxId and the other things use it
via an xxxRef.")

Annotation(rdfs:comment "Since properties are global, most properties
have long names. In all cases, the first part of the name or a
property is 'has' or 'is'. If a name can be divided into three parts,
the second part indicates the sort of thing that has the property. The
last part of the name describes the meaning of the value of the
property. If a name has three parts there is an underscore between the
second and third parts.")

DataPropertyDomain(:hasBin_PartQuantity :PartsBin)
DataPropertyDomain(:hasBin_PartSkuRef :PartsBin)
DataPropertyDomain(:hasBox_Height :BoxyObject)
DataPropertyDomain(:hasBox_Length :BoxyObject)
DataPropertyDomain(:hasBox_Width :BoxyObject)
DataPropertyDomain(:hasEffector_MaximumLoadWeight :EndEffector)
DataPropertyDomain(:hasEndEffector_Description :EndEffector)
DataPropertyDomain(:hasEndEffector_Id :EndEffector)
DataPropertyDomain(:hasEndEffector_Weight :EndEffector)
DataPropertyDomain(:hasKit_DesignRef :Kit)
DataPropertyDomain(:hasKitDesign_Id :KitDesign)
DataPropertyDomain(:hasKitDesign_KitTraySkuRef :KitDesign)
DataPropertyDomain(:hasKitTray_SerialNumber :KitTray)
DataPropertyDomain(:hasKitTray_SkuRef :KitTray)
DataPropertyDomain(:hasLargeBoxWithKits_Capacity :LargeBoxWithKits)
DataPropertyDomain(:hasLargeBoxWithKits_KitDesignRef :LargeBoxWithKits)
DataPropertyDomain(:hasLargeContainer_SerialNumber :LargeContainer)
DataPropertyDomain(:hasLargeContainer_SkuRef :LargeContainer)
DataPropertyDomain(:hasMultiCup_ArrayNumber :VacuumEffectorMultiCup)
DataPropertyDomain(:hasMultiCup_ArrayRadius :VacuumEffectorMultiCup)
DataPropertyDomain(:hasPartRefAndPose_Ref :PartRefAndPose)
DataPropertyDomain(:hasPartsTray_SerialNumber :PartsTray)
DataPropertyDomain(:hasPartsTray_SkuRef :PartsTray)
DataPropertyDomain(:hasPart_SerialNumber :Part)
DataPropertyDomain(:hasPart_SkuRef :Part)
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyDomain(:hasRelativeLocation_Description :RelativeLocation)
DataPropertyDomain(:hasRobot_Description :Robot)
DataPropertyDomain(:hasRobot_Id :Robot)
DataPropertyDomain(:hasRobot_MaximumLoadWeight :Robot)
DataPropertyDomain(:hasShapeDesign_Description :ShapeDesign)
DataPropertyDomain(:hasSku_Description :StockKeepingUnit)
DataPropertyDomain(:hasSku_EndEffectorRefs :StockKeepingUnit)
DataPropertyDomain(:hasSku_Id :StockKeepingUnit)
DataPropertyDomain(:hasSku_Weight :StockKeepingUnit)
DataPropertyDomain(:hasVacuumEffector_CupDiameter :VacuumEffector)
DataPropertyDomain(:hasVacuumEffector_Length :VacuumEffector)
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyDomain(:hasWorkstation_AngleUnit :KittingWorkstation)
DataPropertyDomain(:hasWorkstation_LengthUnit :KittingWorkstation)
DataPropertyDomain(:hasWorkstation_WeightUnit :KittingWorkstation)
DataPropertyDomain(:isKit_Finished :Kit)

DataPropertyRange(:hasBin_PartQuantity xsd:nonNegativeInteger)
DataPropertyRange(:hasBin_PartSkuRef xsd:NMTOKEN)
DataPropertyRange(:hasBox_Height :positiveDecimal)
DataPropertyRange(:hasBox_Length :positiveDecimal)
DataPropertyRange(:hasBox_Width :positiveDecimal)
DataPropertyRange(:hasEffector_MaximumLoadWeight :positiveDecimal)
DataPropertyRange(:hasEndEffector_Description xsd:string)
DataPropertyRange(:hasEndEffector_Id xsd:NMTOKEN)
DataPropertyRange(:hasEndEffector_Weight :positiveDecimal)
DataPropertyRange(:hasKit_DesignRef xsd:NMTOKEN)
DataPropertyRange(:hasKitDesign_Id xsd:NMTOKEN)
DataPropertyRange(:hasKitDesign_KitTraySkuRef xsd:NMTOKEN)
DataPropertyRange(:hasKitTray_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasKitTray_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
DataPropertyRange(:hasLargeBoxWithKits_KitDesignRef xsd:NMTOKEN)
DataPropertyRange(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasLargeContainer_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasMultiCup_ArrayNumber xsd:positiveInteger)
DataPropertyRange(:hasMultiCup_ArrayRadius :positiveDecimal)
DataPropertyRange(:hasPartRefAndPose_Ref xsd:NMTOKEN)
DataPropertyRange(:hasPartsTray_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasPartsTray_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasPart_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasPart_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasPoint_X xsd:decimal)
DataPropertyRange(:hasPoint_Y xsd:decimal)
DataPropertyRange(:hasPoint_Z xsd:decimal)
DataPropertyRange(:hasRelativeLocation_Description xsd:string)
DataPropertyRange(:hasRobot_Description xsd:string)
DataPropertyRange(:hasRobot_Id xsd:NMTOKEN)
DataPropertyRange(:hasRobot_MaximumLoadWeight :positiveDecimal)
DataPropertyRange(:hasShapeDesign_Description xsd:string)
DataPropertyRange(:hasSku_Description xsd:string)
DataPropertyRange(:hasSku_EndEffectorRefs xsd:NMTOKEN)
DataPropertyRange(:hasSku_Id xsd:NMTOKEN)
DataPropertyRange(:hasSku_Weight :positiveDecimal)
DataPropertyRange(:hasVacuumEffector_CupDiameter :positiveDecimal)
DataPropertyRange(:hasVacuumEffector_Length :positiveDecimal)
DataPropertyRange(:hasVector_I xsd:decimal)
DataPropertyRange(:hasVector_J xsd:decimal)
DataPropertyRange(:hasVector_K xsd:decimal)
DataPropertyRange(:hasWorkstation_AngleUnit :angleUnit)
DataPropertyRange(:hasWorkstation_LengthUnit :lengthUnit)
DataPropertyRange(:hasWorkstation_WeightUnit :weightUnit)
DataPropertyRange(:isKit_Finished xsd:boolean)

DatatypeDefinition(:angleUnit DataOneOf("degree" "radian"))
DatatypeDefinition(:lengthUnit DataOneOf("meter" "millimeter" "inch"))
DatatypeDefinition(:positiveDecimal
                   DatatypeRestriction(xsd:decimal xsd:minExclusive
                                       "0"^^xsd:decimal))
DatatypeDefinition(:weightUnit DataOneOf("kilogram" "gram" "milligram"
                                         "ounce" "pound"))

Declaration(Class(:BoxVolume))
AnnotationAssertion(rdfs:comment :BoxVolume
  "A BoxVolume is a DataThing. A BoxVolume has a maximum
   point (hasBoxVolume_MaximumPoint) and a minimum point
   (hasBoxVolume_MinimumPoint). These are diagonally opposite
   corner points of a box shaped volume whose edges are aligned with
   the coordinate system in which the BoxVolume is located. The
   minimum point has the minimum values of X, Y, and Z. The maximum
   point has the maximum values of X, Y, and Z.")

Declaration(Class(:BoxyObject))
AnnotationAssertion(rdfs:comment :BoxyObject
  "A BoxyObject is a SolidObject. A BoxyObject is box shaped. It has a
   length, width, and height (hasBox_Length, hasBox_Width, hasBox_Height).
   It has a preferred partial orientation in which the edges along
   which the height is measured are vertical (parallel to the force of
   gravity).  The length is larger of the two dimensions that are not
   the height.  The width is smaller of the two dimensions that are
   not the height.  The coordinate system of a BoxyObject (i.e. the
   thing that is located and oriented by a pose) has its origin in the
   middle of the bottom, its Z-axis parallel to the height sides, and
   its X-axis parallel to to the length sides. Since this still allows
   two choices for orientation (four if the length and width are
   equal) which may or may not be distinguishable, some subtypes of
   BoxyObject will need one more piece of orientation information.")

Declaration(Class(:DataThing))
AnnotationAssertion(rdfs:comment :DataThing
  "A Data Thing is a Thing. A DataThing includes all complex data types
   such as Vector, PhysicalLocation, etc. Currently, it has no properties.")

Declaration(Class(:EndEffector))
AnnotationAssertion(rdfs:comment :EndEffector
  "An EndEffector is a SolidObject. It is an end effector for a robot.
   An EndEffector has a description (hasEndEffector_Description),
   a weight (hasEndEffector_Weight), an identifier (hasEndEffector_Id),
   and a maximum weight it can lift (hasEffectorMaximimLoadWeight).
   Every EndEffector is either a GripperEffector or a VacuumEffector.
   Every EndEffector in a KittingWorkstation is either attached to the
   end of a robot arm (hadByEndEffector_Robot) or sitting in an
   EndEffectorHolder (hadByEndEffector_EndEffectorHolder) at an
   EndEffectorChangingStation. An EndEffector must not be holding anything
   when it is placed in an EndEffectorHolder or when it is sitting in an
   EndEffectorHolder.")
AnnotationAssertion(rdfs:comment :EndEffector
  "It might be better if each EndEffector has an associated data set
   that holds data for a type of EndEffector. Currently, the data is
   is for a specific object, not for a type. The data set would
   be analogous to the SKU data for a Part (it might even be a SKU).")

Declaration(Class(:EndEffectorChangingStation))
AnnotationAssertion(rdfs:comment :EndEffectorChangingStation
  "An EndEffectorChangingStation is a SolidObject. It is a place where
   end effectors are stored and where the robot can change end effectors.
   It has EndEffectorHolders (hasChangingStation_EndEffectorHolders).
   An EndEffectorChangingStation belongs to a KittingWorkstation
   (hadByChangingStation_Workstation)")

Declaration(Class(:EndEffectorHolder))
AnnotationAssertion(rdfs:comment :EndEffectorHolder
  "An EndEffectorHolder is a SolidObject. An EndEffectorHolder holds
   zero or one EndEffector (hasEndEffectorHolder_EndEffector). An
   EndEffectorHolder is part of an EndEffectorChangingStation
   (hadByEndEffectorHolder_ChangingStation).")

Declaration(Class(:GripperEffector))
AnnotationAssertion(rdfs:comment :GripperEffector
  "A GripperEffector is an EndEffector. A GripperEffector holds an
   object by gripping it with fingers or claws.")

Declaration(Class(:Kit))
AnnotationAssertion(rdfs:comment :Kit
  "A Kit is a SolidObject. A Kit has an identifier for a KitDesign
   (hasKit_DesignRef), a KitTray (hasKit_Tray), a set of Parts
   (hasKit_Parts), and a boolean indicator of whether the Kit is
   finished (isKit_Finished). The coordinate system of a Kit is the
   same as the coordinate system of its KitTray. The PrimaryLocation
   of a Part in a Kit should be given by a PoseLocationIn that is
   relative to the KitTray. A Kit may belong to a LargeBoxWithKits
   (hadByKit_LargeBoxWithKits).")

Declaration(Class(:KitDesign))
AnnotationAssertion(rdfs:comment :KitDesign

  "A KitDesign is a DataThing. A KitDesign identifies a type of tray
   (hasKitDesign_KitTraySkuRef), intended poses of parts in finished
   kits of this design (hasKitDesign_PartRefAndPoses), and an
   identifier (hasKitDesign_Id) that is unique among KitDesigns.  The
   pose (Point, zAxis, and xAxis) in a PartRefAndPose specifies the
   location of the part relative to the coordinate system of the
   ShapeDesign of the tray.  Each KitDesign belongs to a
   KittingWorkstation (hadByKitDesign_Workstation).")

Declaration(Class(:KittingWorkstation))
AnnotationAssertion(rdfs:comment :KittingWorkstation
  "A KittingWorkstation is a SolidObject. A KittingWorkstation
   contains a work table (hasWorkstation_WorkTable), a robot
   (hasWorkstation_Robot), an EndEffectorChangingStation
   (hasWorkstation_ChangingStation), and other fixed obstacles
   (hasWorkstation_OtherObstacles) such as a computer. A
   KittingWorkstation has an angle unit (hasWorkstation_AngleUnit), a
   length unit (hasWorkstation_LengthUnit) and a weight unit
   (hasWorkstation_WeightUnit). All angle, length, and weight values
   related to the workstation must use those units. A
   KittingWorkstation has StockKeepingUnits it knows about
   (hasWorkstation_Skus).  A KittingWorkstation has
   KitDesigns it knows about (hasWorkstation_KitDesigns). In
   addition, containers of various sorts enter and leave the workstation.
   The robot builds kits of parts by executing kitting plans as directed
   by a kitting plan execution system. The location of each instance of
   KittingWorkstation should be given relative to itself in order to
   end the chain of relative locations.")

Declaration(Class(:KitTray))
AnnotationAssertion(rdfs:comment :KitTray
  "A KitTray is a BoxyObject. A KitTray is designed to hold Parts with
   various SKU ids in known positions. A KitTray has an identifier for
   its SKU (hasKitTray_SkuRef) and a serial number
   (hasKitTray_SerialNumber). A KitTray may belong to a Kit
   (hadByKitTray_Kit) or to a LargeBoxWithEmptyKitTrays
   (hadByKitTray_LargeBoxWithEmptyKitTrays).")

Declaration(Class(:LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :LargeBoxWithEmptyKitTrays
  "A LargeBoxWithEmptyKitTrays is a SolidObject. A
   LargeBoxWithEmptyKitTrays has a LargeContainer
   (hasLargeBoxWithEmptyKitTrays_LargeContainer) and a set of KitTrays
   which should be empty (hasLargeBoxWithEmptyKitTrays_Trays).  The
   coordinate system of a LargeBoxWithEmptyKitTrays is the same as the
   coordinate system of its LargeContainer. The PrimaryLocation of a
   KitTray in a LargeBoxWithEmptyKitTrays should be given by a
   PoseLocationIn or RelativeLocationIn that is relative to the
   LargeContainer. The KitTrays in a LargeBoxWithEmptyKitTrays are
   intended to all be of the same SKU, although there is currently no
   formal requirement for that.")

Declaration(Class(:LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :LargeBoxWithKits
  "A LargeBoxWithKits is a SolidObject. A LargeBoxWithKits has
   - a LargeContainer (hasLargeBoxWithKits_LargeContainer)
   - a set of Kits (hasLargeBoxWithKits_Kits)
   - an identifier for a KitDesign (hasLargeBoxWithKits_KitDesignRef)
   - a positiveInteger giving the maximum number of kits of the given
     design that can be held in the box (hasLargeBoxWithKits_Capacity).
   The coordinate system of a LargeBoxWithKits is the same as the
   coordinate system of its LargeContainer. The PrimaryLocation of a
   Kit in a LargeBoxWithKits should be given by a PoseLocationIn or
   RelativeLocationIn that is relative to the LargeContainer. The Kits
   in a LargeBoxWithKits are intended to all be of the given design,
   but there is currently no formal constraint requiring that.")

Declaration(Class(:LargeContainer))
AnnotationAssertion(rdfs:comment :LargeContainer
  "A LargeContainer is a BoxyObject. A LargeContainer can hold one or more
   instances of a single type of tray or bin. The single type may be 
   (1) KitTray
   (2) PartsBin
   (3) PartsTray
   (4) Kit
   A LargeContainer has an identifier for its SKU (hasLargeContainer_SkuRef)
   and a serial number (hasLargeContainer_SerialNumber). A LargeContainer
   may belong to a LargeBoxWithEmptyKitTrays
   (hadByLargeContainer_LargeBoxWithEmptyKitTrays) or to a
   LargeBoxWithKits (hadByLargeContainer_LargeBoxWithKits).")

Declaration(Class(:Part))
AnnotationAssertion(rdfs:comment :Part
  "A Part is a SolidObject. It has a reference to the identifier of a
   StockKeepingUnit (hasPart_SkuRef) and a SerialNumber
   (hasPart_SerialNumber). A Part may belong to a Kit
   (hadByPart_Kit) or to a PartsTrayWithParts
   (hadByPart_PartsTrayWithParts).")

Declaration(Class(:PartRefAndPose))
AnnotationAssertion(rdfs:comment :PartRefAndPose
  "A PartRefAndPose is a DataThing.  A PartRefAndPose identifies a
   type of part by giving its SKU id (hasPartRefAndPose_Ref), it
   specifies the location of the part (hasPartRefAndPose_Point), and
   the orientation of the Part (hasPartRefAndPose_XAxis and
   hasPartRefAndPose_ZAxis). The pose is relative to the coordinate
   system of the KitTray identified in the KitDesign. A PartRefAndPose
   belongs to a KitDesign (hadByPartRefAndPose_KitDesign).")

Declaration(Class(:PartsBin))
AnnotationAssertion(rdfs:comment :PartsBin
  "A PartsBin is a BoxyObject. A PartsBin holds a number of Parts
   (hasBin_PartQuantity) with the same SKU id (hasBin_PartSkuRef) in unknown
   random positions.")

Declaration(Class(:PartsTray))
AnnotationAssertion(rdfs:comment :PartsTray
  "A PartsTray is a BoxyObject used to hold Parts. A PartsTray has an
   identifier for its SKU (hasPartsTray_SkuRef) and a serial number
   (hasPartsTray_SerialNumber). A PartsTray may belong to a
   PartsTrayWithParts (hadByPartsTray_PartsTrayWithParts).")

Declaration(Class(:PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :PartsTrayWithParts
  "A PartsTrayWithParts is a SolidObject. A PartsTrayWithParts has a
   PartsTray (hasPartsTrayWithParts_Tray) and a set of Parts
   (hasPartsTrayWithParts_Parts). The coordinate system of a
   PartsTrayWithParts is the same as the coordinate system of its
   PartsTray. The PrimaryLocation of a Part in a
   PartsTrayWithParts should be given by a PoseLocationIn that is
   relative to the PartsTray. The Parts in a PartsTrayWithParts are
   intended to all be of the same SKU, although there is currently no
   formal requirement for that.")

Declaration(Class(:PhysicalLocation))
AnnotationAssertion(rdfs:comment :PhysicalLocation
  "A PhysicalLocation is a DataThing. A PhysicalLocation says where a
   SolidObject is. A PhysicalLocation has a reference object
   (hasPhysicalLocation_RefObject). A PhysicalLocation is either a
   RelativeLocation or a PoseLocation.")

Declaration(Class(:Point))
AnnotationAssertion(rdfs:comment :Point
  "A Point is a DataThing. A Point has X (hasPoint_X), Y (hasPoint_Y),
   and Z (hasPoint_Z) Cartesian coordinates.")

Declaration(Class(:PoseLocation))
AnnotationAssertion(rdfs:comment :PoseLocation

  "A PoseLocation is a PhysicalLocation. A PoseLocation consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object inherited from the
   PhysicalLocation class (hasPhysicalLocation_RefObject). The data
   for the Point, the ZAxis and the XAxis are expressed relative to the
   coordinate system of the reference object. A PoseLocation must be a
   PoseOnlyLocation, a PoseLocationIn, or a PoseLocationOn")

Declaration(Class(:PoseLocationIn))
AnnotationAssertion(rdfs:comment :PoseLocation
  "A PoseLocationIn is a PoseLocation. A PoseLocationIn consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. A PoseLocationIn indicates that a SolidObject that has the
   PoseLocationIn as the value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is inside the SolidObject
   that is the reference object of the PoseLocationIn.  The notion of
   'inside' is vague and might be made more precise.")

Declaration(Class(:PoseLocationOn))
AnnotationAssertion(rdfs:comment :PoseLocation
  "A PoseLocationOn is a PoseLocation. A PoseLocationOn consists of a
   Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. A PoseLocationOn indicates that a SolidObject that has the
   PoseLocationOn as the value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is on top of the
   SolidObject that is the reference object of the PoseLocationOn.
   The notion of 'on top of' is vague and might be made more
   precise.")

Declaration(Class(:PoseOnlyLocation))
AnnotationAssertion(rdfs:comment :PoseLocation
  "A PoseOnlyLocation is a PoseLocation. A PoseOnlyLocation consists
   of a Point (hasPoseLocation_Point), a Vector for the Z axis
   (hasPoseLocation_ZAxis), a Vector for the X axis
   (hasPoseLocation_XAxis), and a reference object
   (hasPhysicalLocation_RefObject) all inherited from
   PoseLocation. The data for the Point, the ZAxis and the XAxis are
   expressed relative to the coordinate system of the reference
   object. An object located by a PoseOnlyLocation may or may not be
   inside or on top of the reference object of the PoseOnlyLocation.")

Declaration(Class(:RelativeLocation))
AnnotationAssertion(rdfs:comment :RelativeLocation
  "A RelativeLocation is a PhysicalLocation. A RelativeLocation
   indicates that one solid object is on or in another solid object.
   A RelativeLocation must be a RelativeLocationIn or a RelativeLocationOn.
   A RelativeLocation has a description (hasRelativeLocation_Description)
   that is a string.")

Declaration(Class(:RelativeLocationIn))
AnnotationAssertion(rdfs:comment :RelativeLocationIn
  "A RelativeLocationIn is a RelativeLocation. A RelativeLocationIn
   indicates that a SolidObject that has the RelativeLocationIn as the
   value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is inside the
   SolidObject that is the reference object of the RelativeLocationIn.
   The notion of 'inside' is vague and might be made more precise.
   A RelativeLocationIn has a description inherited from RelativeLocation
   (hasRelativeLocation_Description) that is a string.")

Declaration(Class(:RelativeLocationOn))
AnnotationAssertion(rdfs:comment :RelativeLocationOn
  "A RelativeLocationOn is a RelativeLocation. A RelativeLocationOn
   indicates that a SolidObject that has the RelativeLocationOn as the
   value of a hasSolidObject_PrimaryLocation or
   hasSolidObject_SecondaryLocation property is on top of the
   SolidObject that is the reference object of the RelativeLocationOn.
   The notion of 'on top of' is vague and might be made more precise.
   A RelativeLocationOn has a description inherited from RelativeLocation
   (hasRelativeLocation_Description) that is a string.")

Declaration(Class(:Robot))
AnnotationAssertion(rdfs:comment :Robot
  "A Robot is a SolidObject. A Robot currently has a description
   (hasRobot_Description), a robot id (hasRobot_Id), a work volume
   (hasRobot_WorkVolume), an end effector (hasRobot_EndEffector), and
   a maximum load weight (hasRobot_MaximumLoadWeight). A robot
   belongs to a KittingWorkstation (hadByRobot_Workstation).")
AnnotationAssertion(rdfs:comment :Robot "The Robot ontology given
   here might be expanded greatly to include, for example, its
   kinematic description, the values of joint angles, arm lengths of
   variable length arms, gripper actuation (open, closed, etc.),
   ranges, velocities, and accelerations of each joint, etc.")

Declaration(Class(:ShapeDesign))
AnnotationAssertion(rdfs:comment :ShapeDesign
  "A ShapeDesign is a DataThing. This is currently a stub that has
   only a description (hasShapeDesign_Description) that is an xsd:string.")

Declaration(Class(:SolidObject))
AnnotationAssertion(rdfs:comment :SolidObject
  "A SolidObject is a Thing. A SolidObject has a location
   (hasSolidObject_PrimaryLocation). This is a
   PhysicalLocation that relates the location of the object to the
   location of some other SolidObject. The location of a SolidObject
   may be on a WorkTable (hadBySolidObject_WorkTable). No SolidObject
   except the Workstation may be located with respect to itself, and
   all chains of primary location must end at the Workstation. The
   location of a SolidObject may be on the WorkTable
   (hadBySolidObject_WorkTable). A SolidObject may have zero to many
   secondary location descriptions
   (hasSolidObject_SecondaryLocation). These are also
   PhysicalLocations. The secondary locations are required to be
   logically and mathematically consistent with the value of
   hasSolidObject_PrimaryLocation so that all locations of a
   SolidObject describe (or are consistent with) a single place in
   space.")

Declaration(Class(:StockKeepingUnit))
AnnotationAssertion(rdfs:comment :StockKeepingUnit
  "A StockKeepingUnit is a DataThing. A StockKeepingUnit is a
   description of a type of object. Every StockKeepingUnit has a
   description (hasSku_Description), a shape (hasSku_Shape), that is a
   ShapeDesign, a weight (hasSku_Weight), references to the
   ids of EndEffectors that can handle it (hasSku_EndEffectorRefs),
   and a unique identifier (hasSku_Id). A StockKeepingUnit belongs to a
   KittingWorkstation (hadBySku_Workstation).")

Declaration(Class(:VacuumEffector))
AnnotationAssertion(rdfs:comment :VacuumEffector
  "A VacuumEffector is an EndEffector. A VacuumEffector holds an
   object by putting a cup against the object and applying a vacuum.
   A VacuumEffector is either a VacuumEffectorSingleCup or a
   VacuumEffectorMultiCup.  A VacuumEffector has a cup diameter
   (hasVacuumEffector_CupDiameter) and a length (hasVacuumEffector_Length).")

Declaration(Class(:VacuumEffectorMultiCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "A VacuumEffectorMultiCup is a VacuumEffector with two or more
   identical cups (hasMultiCup_ArrayNumber).  A VacuumEffectorMultiCup
   has an array radius (hasMultiCup_ArrayRadius).  The cups are
   arranged in a circular array spaced evenly apart. The center of the
   wide end of one cup is on the X-axis of the coordinate system of
   the VacuumEffectorMultiCup. The center of the circular array is at
   the origin of the coordinate system. The axis of the array circle
   is the Z axis of the coordinate system, and the length of the
   VacuumEffector is measured along that axis. The wide ends of the
   cups lie on the XY plane of the coordinate system.")
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "Note that a square array can be represented easily as circular array.")

Declaration(Class(:VacuumEffectorSingleCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorSingleCup
  "A VacuumEffectorSingleCup is a VacuumEffector with one cup.
   The center of the wide end of the cup (which is a circle) is at
   the origin of the coordinate system of the VacuumEffectorSingleCup.
   The Z axis of the coordinate system is the axis of that circle,
   and the length of the VacuumEffector is measured along that axis.")

Declaration(Class(:Vector))
AnnotationAssertion(rdfs:comment :Vector
  "A Vector is a DataThing. It has I (hasVector_I), J (hasVector_J),
   and K (hasVector_K) components.")

Declaration(Class(:WorkTable))
AnnotationAssertion(rdfs:comment :WorkTable
  "A WorkTable is a BoxyObject. The top of a WorkTable is a flat,
   rectangular, horizontal surface. The length and width of the top
   are those of the BoxyObject. A WorkTable has solid
   objects that are located with respect to the WorkTable, i.e. the
   reference object of each of those solid objects is the WorkTable
   (hasWorkTable_SolidObjects). Typically, those objects will be on
   top of the WorkTable. This property may be deduced by finding all
   the objects located with respect to the WorkTable, so care will be
   required to keep the values of the hasWorkTable_SolidObjects and
   hasPhysicalLocation_RefObject properties consistent. A WorkTable
   belongs to a Workstation (hadByWorkTable_Workstation).")

// In the following DataProperty Declarations, there is may be a more
// formal method of representing the AnnotationAssertions. There would be
// (probably) if the properties were ObjectProperty rather than DataProperty.

Declaration(DataProperty(:hasBin_PartQuantity))
Declaration(DataProperty(:hasBin_PartSkuRef))
Declaration(DataProperty(:hasBox_Height))
Declaration(DataProperty(:hasBox_Length))
Declaration(DataProperty(:hasBox_Width))
Declaration(DataProperty(:hasEndEffector_Description))
Declaration(DataProperty(:hasEndEffector_Id))
Declaration(DataProperty(:hasEndEffector_Weight))
Declaration(DataProperty(:hasEffector_MaximumLoadWeight))
Declaration(DataProperty(:hasKit_DesignRef))
Declaration(DataProperty(:hasKitDesign_Id))
Declaration(DataProperty(:hasKitDesign_KitTraySkuRef))
AnnotationAssertion(rdfs:comment :hasKitDesign_KitTraySkuRef
  "Each KitDesign has a NMTOKEN as the value of hasKitDesign_KitTraySkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasKitTray_SerialNumber))
Declaration(DataProperty(:hasKitTray_SkuRef))
AnnotationAssertion(rdfs:comment :hasKitTray_SkuRef
  "Each KitTray has a NMTOKEN as the value of hasKitTray_SkuRef. That NMTOKEN
   must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasLargeBoxWithKits_Capacity))
Declaration(DataProperty(:hasLargeBoxWithKits_KitDesignRef))
Declaration(DataProperty(:hasLargeContainer_SerialNumber))
Declaration(DataProperty(:hasLargeContainer_SkuRef))
AnnotationAssertion(rdfs:comment :hasLargeContainer_SkuRef
  "Each LargeContainer has a NMTOKEN as the value of hasLargeContainer_SkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasMultiCup_ArrayNumber))
Declaration(DataProperty(:hasMultiCup_ArrayRadius))
Declaration(DataProperty(:hasPartRefAndPose_Ref))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Ref
  "A PartRefAndPose has a reference to the id of SKU that is the
   SKU of a Part.")
Declaration(DataProperty(:hasPartsTray_SerialNumber))
Declaration(DataProperty(:hasPartsTray_SkuRef))
AnnotationAssertion(rdfs:comment :hasPartsTray_SkuRef
  "Each PartsTray has a NMTOKEN as the value of hasPartsTray_SkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasPart_SerialNumber))
Declaration(DataProperty(:hasPart_SkuRef))
AnnotationAssertion(rdfs:comment :hasPart_SkuRef
  "Each Part has a NMTOKEN as the value of hasPart_SkuRef. That NMTOKEN
   must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasPoint_X))
Declaration(DataProperty(:hasPoint_Y))
Declaration(DataProperty(:hasPoint_Z))
Declaration(DataProperty(:hasRelativeLocation_Description))
Declaration(DataProperty(:hasRobot_Description))
Declaration(DataProperty(:hasRobot_Id))
Declaration(DataProperty(:hasRobot_MaximumLoadWeight))
AnnotationAssertion(rdfs:comment :hasRobot_MaximumLoadWeight
  "The maximum load weight includes the weight of the end effector.")
Declaration(DataProperty(:hasShapeDesign_Description))
Declaration(DataProperty(:hasSku_EndEffectorRefs))
AnnotationAssertion(rdfs:comment :hasSku_EndEffectorRefs
  "A StockKeepingUnit has references to the ids of EndEffectors
   that can handle the StockKeepingUnit.")
Declaration(DataProperty(:hasSku_Description))
Declaration(DataProperty(:hasSku_Id))
Declaration(DataProperty(:hasSku_Weight))
Declaration(DataProperty(:hasVacuumEffector_CupDiameter))
Declaration(DataProperty(:hasVacuumEffector_Length))
Declaration(DataProperty(:hasVector_I))
Declaration(DataProperty(:hasVector_J))
Declaration(DataProperty(:hasVector_K))
Declaration(DataProperty(:hasWorkstation_AngleUnit))
Declaration(DataProperty(:hasWorkstation_LengthUnit))
Declaration(DataProperty(:hasWorkstation_WeightUnit))
Declaration(DataProperty(:isKit_Finished))

Declaration(ObjectProperty(:hadByChangingStation_Workstation))
AnnotationAssertion(rdfs:comment :hadByChangingStation_Workstation
  "An EndEffectorChangingStation belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadByEndEffector_EndEffectorHolder))
AnnotationAssertion(rdfs:comment :hadByEndEffector_EndEffectorHolder
  "An EndEffector may be in an EndEffectorHolder.")

Declaration(ObjectProperty(:hadByEndEffector_Robot))
AnnotationAssertion(rdfs:comment :hadByEndEffector_Robot
  "An EndEffector may belong to a Robot.")

Declaration(ObjectProperty(:hadByEndEffectorHolder_ChangingStation))
AnnotationAssertion(rdfs:comment :hadByEndEffectorHolder_ChangingStation
  "An EndEffectorHolder belongs to an EndEffectorChangingStation.")

Declaration(ObjectProperty(:hadByKit_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByKit_LargeBoxWithKits
  "A Kit may belong to a LargeBoxWithKits.")

Declaration(ObjectProperty(:hadByKitDesign_Workstation))
AnnotationAssertion(rdfs:comment :hadByKitDesign_Workstation
  "A KitDesign belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadByKitTray_Kit))
AnnotationAssertion(rdfs:comment :hadByKitTray_Kit
  "A KitTray may belong to a Kit.")

Declaration(ObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByKitTray_LargeBoxWithEmptyKitTrays
  "A KitTray may belong to a LargeBoxWithEmptyKitTrays.")

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithEmptyKitTrays
  "A LargeContainer may belong to a LargeBoxWithEmptyKitTrays.")

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithKits
  "A LargeContainer may belong to a LargeBoxWithKits.")

Declaration(ObjectProperty(:hadByPart_Kit))
AnnotationAssertion(rdfs:comment :hadByPart_Kit
  "A Part may belong to a Kit.")

Declaration(ObjectProperty(:hadByPart_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPart_PartsTrayWithParts
  "A Part may belong to a PartsTrayWithParts.")

Declaration(ObjectProperty(:hadByPartRefAndPose_KitDesign))
AnnotationAssertion(rdfs:comment :hadByPartRefAndPose_KitDesign
  "A PartRefAndPose belongs to a KitDesign.")

Declaration(ObjectProperty(:hadByPartsTray_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPartsTray_PartsTrayWithParts
  "A PartsTray may belong to a PartsTrayWithParts.")

Declaration(ObjectProperty(:hadByRobot_Workstation))
AnnotationAssertion(rdfs:comment :hadByRobot_Workstation
  "A Robot belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadBySku_Workstation))
AnnotationAssertion(rdfs:comment :hadBySku_Workstation
  "A StockKeepingUnit belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadBySolidObject_WorkTable))
AnnotationAssertion(rdfs:comment :hadBySolidObject_WorkTable
  "A SolidObject may belong to a WorkTable.")

Declaration(ObjectProperty(:hadByWorkTable_Workstation))
AnnotationAssertion(rdfs:comment :hadByWorkTable_Workstation
  "A WorkTable belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hasBoxVolume_MaximumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MaximumPoint
  "A BoxVolume has a maximum Point.")

Declaration(ObjectProperty(:hasBoxVolume_MinimumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MinimumPoint
  "A BoxVolume has a minimum Point.")

Declaration(ObjectProperty(:hasChangingStation_EndEffectorHolders))
AnnotationAssertion(rdfs:comment :hasChangingStation_EndEffectorHolders
  "An EndEffectorChangingStation has EndEffectorHolders.")

Declaration(ObjectProperty(:hasEndEffectorHolder_EndEffector))
AnnotationAssertion(rdfs:comment :hasEndEffectorHolder_EndEffector
  "An EndEffectorHolder holds zero or one EndEffector.")

Declaration(ObjectProperty(:hasKit_Parts))
AnnotationAssertion(rdfs:comment :hasKit_Parts
  "A Kit has zero to many Parts.")

Declaration(ObjectProperty(:hasKit_Tray))
AnnotationAssertion(rdfs:comment :hasKit_Tray
  "A Kit has a KitTray.")

Declaration(ObjectProperty(:hasKitDesign_PartRefAndPoses))
AnnotationAssertion(rdfs:comment :hasKitDesign_PartRefAndPoses
  "A KitDesign has PartRefAndPoses.")

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_KitTrays
  "A LargeBoxWithEmptyKitTrays has zero to many KitTrays.")

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_LargeContainer
  "A LargeBoxWithEmptyKitTrays has a LargeContainer.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_LargeContainer
  "A LargeBoxWithKits has a LargeContainer.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_Kits))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_Kits
  "A LargeBoxWithKits has zero to many Kits.")

Declaration(ObjectProperty(:hasPartRefAndPose_Point))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Point
  "A PartRefAndPose has a Point.")

Declaration(ObjectProperty(:hasPartRefAndPose_XAxis))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_XAxis
  "A PartRefAndPose has an X axis Vector.")

Declaration(ObjectProperty(:hasPartRefAndPose_ZAxis))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_ZAxis
  "A PartRefAndPose has a Z axis Vector.")

Declaration(ObjectProperty(:hasPartsTrayWithParts_Parts))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_Parts
  "A PartsTrayWithParts has zero to many Parts.")

Declaration(ObjectProperty(:hasPartsTrayWithParts_Tray))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_Tray
  "A PartsTrayWithParts has a PartsTray.")

Declaration(ObjectProperty(:hasPhysicalLocation_RefObject))
AnnotationAssertion(rdfs:comment :hasPhysicalLocation_RefObject
  "A PhysicalLocation L has a reference object O that is a
   SolidObject.  If L is a PoseLocation (i.e., a PoseOnlyLocation, a
   PoseLocationIn, or a PoseLocationOn), the coordinate system of O is
   the reference coordinate system for the PoseLocation, and the
   PoseLocation locates a referencing object R. If L is a
   PoseLocationIn, a PoseLocationOn, a RelativeLocationIn, or a
   RelativeLocationOn, O is the SolidObject that R is inside of or
   on. R is a SolidObject that hasSolidObject_PrimaryLocation
   L or hasSolidObject_SecondaryLocation L.")

Declaration(ObjectProperty(:hasPoseLocation_Point))
AnnotationAssertion(rdfs:comment :hasPoseLocation_Point
  "A PoseLocation has a pose point that is a Point. The origin of the
   coordinate system of the SolidObject that is located by the
   PoseLocation is placed at the pose point.")

Declaration(ObjectProperty(:hasPoseLocation_XAxis))
AnnotationAssertion(rdfs:comment :hasPoseLocation_XAxis
  "A PoseLocation has an X axis Vector. The positive X axis of the
   coordinate system of the SolidObject that is located by the
   PoseLocation points in the direction of this Vector.")

Declaration(ObjectProperty(:hasPoseLocation_ZAxis))
AnnotationAssertion(rdfs:comment :hasPoseLocation_ZAxis
  "A PoseLocation has a Z axis Vector. The positive Z axis of the
   coordinate system of the SolidObject that is located by the
   PoseLocation points in the direction of this Vector.")

Declaration(ObjectProperty(:hasRobot_EndEffector))
AnnotationAssertion(rdfs:comment :hasRobot_EndEffector
  "A Robot has zero or one EndEffector.")

Declaration(ObjectProperty(:hasRobot_WorkVolume))
AnnotationAssertion(rdfs:comment :hasRobot_WorkVolume
  "A Robot has a work volume that is the union of one to many BoxVolumes
   representing space into which the robot can move its end effector in
   the absence of other obstacles. The coordinate system of the BoxVolumes
   is the coordinate system of the robot.")

Declaration(ObjectProperty(:hasSku_Shape))
AnnotationAssertion(rdfs:comment :hasSku_Shape
  "A StockKeepingUnit has a ShapeDesign.")

Declaration(ObjectProperty(:hasSolidObject_PrimaryLocation))
AnnotationAssertion(rdfs:comment :hasSolidObject_PrimaryLocation
  "All SolidObjects have a primary PhysicalLocation, and (in this
   ontology, which does not deal with liquid or gas objects) only
   SolidObjects have one.")

Declaration(ObjectProperty(:hasSolidObject_SecondaryLocation))
AnnotationAssertion(rdfs:comment :hasSolidObject_SecondaryLocation
  "A SolidObject may have zero to many secondary PhysicalLocations.")

Declaration(ObjectProperty(:hasWorkstation_ChangingStation))
AnnotationAssertion(rdfs:comment :hasWorkstation_ChangingStation
  "A KittingWorkstation has an EndEffectorChangingStation.")

Declaration(ObjectProperty(:hasWorkstation_KitDesigns))
AnnotationAssertion(rdfs:comment :hasWorkstation_KitDesigns
  "A KittingWorkstation has a library of KitDesigns which contains
   KitDesigns.")

Declaration(ObjectProperty(:hasWorkstation_OtherObstacles))
AnnotationAssertion(rdfs:comment :hasWorkstation_OtherObstacles
  "A KittingWorkstation has other obstacles that are described by
   BoxVolumes representing occupied space through which the robot
   should not attempt to move The coordinate system of the BoxVolumes
   is the coordinate system of the KittingWorkstation.")

Declaration(ObjectProperty(:hasWorkstation_Robot))
AnnotationAssertion(rdfs:comment :hasWorkstation_Robot
  "A KittingWorkstation has a Robot.")

Declaration(ObjectProperty(:hasWorkstation_Skus))
AnnotationAssertion(rdfs:comment :hasWorkstation_Skus
  "A KittingWorkstation has a library of Skus, which contains
   StockKeepingUnits.")

Declaration(ObjectProperty(:hasWorkstation_WorkTable))
AnnotationAssertion(rdfs:comment :hasWorkstation_WorkTable
  "A KittingWorkstation has a WorkTable.")

Declaration(ObjectProperty(:hasWorkTable_SolidObjects))
AnnotationAssertion(rdfs:comment :hasWorkTable_SolidObjects
  "A WorkTable has SolidObjects located with respect to itself.")

// Protege apparently does not recognize the built-in class Thing if
// a direct reference is made to it. For example, the statement
// DisjointUnion(:Thing :DataThing :SolidObject) causes a new class
// called Thing to come into existence as a subclass of built-in Thing.
// Hence, only the following DisjointClasses statement is made for
// :DataThing and :SolidObject, which are the two top-level subclasses
// of Thing.

DisjointClasses(:DataThing
                :SolidObject)

DisjointUnion(:BoxyObject
              :KitTray
              :LargeContainer
              :PartsBin
              :PartsTray
              :WorkTable)

DisjointUnion(:DataThing
              :BoxVolume
              :KitDesign
              :PartRefAndPose
              :PhysicalLocation
              :Point
              :ShapeDesign
              :StockKeepingUnit
              :Vector)

DisjointUnion(:EndEffector
              :GripperEffector
              :VacuumEffector)

DisjointUnion(:PhysicalLocation
              :PoseLocation
              :RelativeLocation)

DisjointUnion(:PoseLocation
              :PoseLocationIn
              :PoseLocationOn
              :PoseOnlyLocation)

DisjointUnion(:RelativeLocation
              :RelativeLocationIn
              :RelativeLocationOn)

DisjointUnion(:SolidObject
              :BoxyObject
              :EndEffector
              :EndEffectorChangingStation
              :EndEffectorHolder
              :Kit
              :KittingWorkstation
              :LargeBoxWithEmptyKitTrays
              :LargeBoxWithKits
              :Part
              :PartsTrayWithParts
              :Robot)

DisjointUnion(:VacuumEffector
              :VacuumEffectorSingleCup
              :VacuumEffectorMultiCup)

// It is probably feasible to write several more EquivalentClass statements.

EquivalentClasses(:BoxVolume
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasBoxVolume_MaximumPoint
                                              :Point)
                         ObjectAllValuesFrom(:hasBoxVolume_MaximumPoint
                                             :Point)))

EquivalentClasses(:BoxVolume
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasBoxVolume_MinimumPoint
                                              :Point)
                         ObjectAllValuesFrom(:hasBoxVolume_MinimumPoint
                                             :Point)))

EquivalentClasses(:BoxyObject
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBox_Length :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Length :positiveDecimal)))

EquivalentClasses(:BoxyObject
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBox_Width :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Width :positiveDecimal)))

EquivalentClasses(:BoxyObject
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBox_Height :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Height :positiveDecimal)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEffector_MaximumLoadWeight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasEffector_MaximumLoadWeight
                                            :positiveDecimal)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasEndEffector_Description
                                            xsd:string)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasEndEffector_Id xsd:NMTOKEN)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Weight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasEndEffector_Weight
                                            :positiveDecimal)))

EquivalentClasses(:Kit
    ObjectIntersectionOf(DataSomeValuesFrom(:isKit_Finished xsd:boolean)
                         DataAllValuesFrom(:isKit_Finished xsd:boolean)))

EquivalentClasses(:Kit
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasKit_Tray :KitTray)
                         ObjectAllValuesFrom(:hasKit_Tray :KitTray)))

EquivalentClasses(:KitDesign
    ObjectIntersectionOf(DataSomeValuesFrom(:hasKitDesign_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasKitDesign_Id xsd:NMTOKEN)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_AngleUnit
                         :angleUnit)
                         DataAllValuesFrom(:hasWorkstation_AngleUnit
                         :angleUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_LengthUnit
                         :lengthUnit)
                         DataAllValuesFrom(:hasWorkstation_LengthUnit
                         :lengthUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_WeightUnit
                         :weightUnit)
                         DataAllValuesFrom(:hasWorkstation_WeightUnit
                         :weightUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_ChangingStation
                                              :EndEffectorChangingStation)
                         ObjectAllValuesFrom(:hasWorkstation_ChangingStation
                                             :EndEffectorChangingStation)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_Robot :Robot)
                         ObjectAllValuesFrom(:hasWorkstation_Robot :Robot)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_WorkTable
                                              :WorkTable)
                         ObjectAllValuesFrom(:hasWorkstation_WorkTable
                                             :WorkTable)))

EquivalentClasses(:LargeBoxWithEmptyKitTrays
    ObjectIntersectionOf(ObjectSomeValuesFrom(
                                 :hasLargeBoxWithEmptyKitTrays_LargeContainer
                                              :LargeContainer)
                         ObjectAllValuesFrom(
                                 :hasLargeBoxWithEmptyKitTrays_LargeContainer
                                             :LargeContainer)))

EquivalentClasses(:LargeBoxWithKits
    ObjectIntersectionOf(ObjectSomeValuesFrom(
                                          :hasLargeBoxWithKits_LargeContainer
                                              :LargeContainer)
                         ObjectAllValuesFrom(
                                          :hasLargeBoxWithKits_LargeContainer
                                             :LargeContainer)))

EquivalentClasses(:PartRefAndPose
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPartRefAndPose_Ref
                                            xsd:NMTOKEN)
                         DataAllValuesFrom(:hasPartRefAndPose_Ref
                                            xsd:NMTOKEN)))

EquivalentClasses(:PartsBin
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBin_PartQuantity
                                            xsd:nonNegativeInteger)
                         DataAllValuesFrom(:hasBin_PartQuantity
                                            xsd:nonNegativeInteger)))

EquivalentClasses(:PartsBin
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBin_PartSkuRef xsd:NMTOKEN)
                         DataAllValuesFrom(:hasBin_PartSkuRef xsd:NMTOKEN)))

EquivalentClasses(:PartsTrayWithParts
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPartsTrayWithParts_Tray
                                              :PartsTray)
                         ObjectAllValuesFrom(:hasPartsTrayWithParts_Tray
                                             :PartsTray)))

EquivalentClasses(:PhysicalLocation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPhysicalLocation_RefObject
                                              :SolidObject)
                         ObjectAllValuesFrom(:hasPhysicalLocation_RefObject
                                             :SolidObject)))

EquivalentClasses(:Point
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPoint_X xsd:decimal)
                         DataAllValuesFrom(:hasPoint_X xsd:decimal)))

EquivalentClasses(:Point
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPoint_Y xsd:decimal)
                         DataAllValuesFrom(:hasPoint_Y xsd:decimal)))

EquivalentClasses(:Point
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPoint_Z xsd:decimal)
                         DataAllValuesFrom(:hasPoint_Z xsd:decimal)))

EquivalentClasses(:PoseLocation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPoseLocation_ZAxis :Vector)
                         ObjectAllValuesFrom(:hasPoseLocation_ZAxis :Vector)))

EquivalentClasses(:PoseLocation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPoseLocation_XAxis :Vector)
                         ObjectAllValuesFrom(:hasPoseLocation_XAxis :Vector)))

EquivalentClasses(:PoseLocation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPoseLocation_Point :Point)
                         ObjectAllValuesFrom(:hasPoseLocation_Point :Point)))

EquivalentClasses(:RelativeLocation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRelativeLocation_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasRelativeLocation_Description
                                           xsd:string)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_Description xsd:string)
                         DataAllValuesFrom(:hasRobot_Description xsd:string)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasRobot_Id xsd:NMTOKEN)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_MaximumLoadWeight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasRobot_MaximumLoadWeight
                                            :positiveDecimal)))

EquivalentClasses(:ShapeDesign
    ObjectIntersectionOf(DataSomeValuesFrom(:hasShapeDesign_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasShapeDesign_Description
                                           xsd:string)))

EquivalentClasses(:SolidObject
    ObjectIntersectionOf(
       ObjectSomeValuesFrom(:hasSolidObject_PrimaryLocation
			    :PhysicalLocation)
       ObjectAllValuesFrom(:hasSolidObject_PrimaryLocation
			   :PhysicalLocation)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Description xsd:string)
                         DataAllValuesFrom(:hasSku_Description xsd:string)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasSku_Id xsd:NMTOKEN)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasSku_Shape
                                              :ShapeDesign)
                         ObjectAllValuesFrom(:hasSku_Shape
                                             :ShapeDesign)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Weight :positiveDecimal)
                         DataAllValuesFrom(:hasSku_Weight :positiveDecimal)))


EquivalentClasses(:VacuumEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVacuumEffector_CupDiameter
                         :positiveDecimal)
                         DataAllValuesFrom(:hasVacuumEffector_CupDiameter
                         :positiveDecimal)))

EquivalentClasses(:VacuumEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVacuumEffector_Length
                         :positiveDecimal)
                         DataAllValuesFrom(:hasVacuumEffector_Length
                         :positiveDecimal)))

EquivalentClasses(:VacuumEffectorMultiCup
    ObjectIntersectionOf(DataSomeValuesFrom(:hasMultiCup_ArrayNumber
                         xsd:positiveInteger)
                         DataAllValuesFrom(:hasMultiCup_ArrayNumber
                         xsd:positiveInteger)))

EquivalentClasses(:VacuumEffectorMultiCup
    ObjectIntersectionOf(DataSomeValuesFrom(:hasMultiCup_ArrayRadius
                         :positiveDecimal)
                         DataAllValuesFrom(:hasMultiCup_ArrayRadius
                         :positiveDecimal)))

EquivalentClasses(:Vector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVector_I xsd:decimal)
                         DataAllValuesFrom(:hasVector_I xsd:decimal)))

EquivalentClasses(:Vector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVector_J xsd:decimal)
                         DataAllValuesFrom(:hasVector_J xsd:decimal)))

EquivalentClasses(:Vector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVector_K xsd:decimal)
                         DataAllValuesFrom(:hasVector_K xsd:decimal)))

FunctionalDataProperty(:hasBin_PartQuantity)
FunctionalDataProperty(:hasBin_PartSkuRef)
FunctionalDataProperty(:hasBox_Height)
FunctionalDataProperty(:hasBox_Length)
FunctionalDataProperty(:hasBox_Width)
FunctionalDataProperty(:hasEffector_MaximumLoadWeight)
FunctionalDataProperty(:hasEndEffector_Description)
FunctionalDataProperty(:hasEndEffector_Id)
FunctionalDataProperty(:hasEndEffector_Weight)
FunctionalDataProperty(:hasKit_DesignRef)
FunctionalDataProperty(:hasKitDesign_Id)
FunctionalDataProperty(:hasKitDesign_KitTraySkuRef)
FunctionalDataProperty(:hasKitTray_SerialNumber)
FunctionalDataProperty(:hasKitTray_SkuRef)
FunctionalDataProperty(:hasLargeBoxWithKits_Capacity)
FunctionalDataProperty(:hasLargeBoxWithKits_KitDesignRef)
FunctionalDataProperty(:hasLargeContainer_SerialNumber)
FunctionalDataProperty(:hasLargeContainer_SkuRef)
FunctionalDataProperty(:hasMultiCup_ArrayNumber)
FunctionalDataProperty(:hasMultiCup_ArrayRadius)
FunctionalDataProperty(:hasPartRefAndPose_Ref)
FunctionalDataProperty(:hasPartsTray_SerialNumber)
FunctionalDataProperty(:hasPartsTray_SkuRef)
FunctionalDataProperty(:hasPart_SerialNumber)
FunctionalDataProperty(:hasPart_SkuRef)
FunctionalDataProperty(:hasPoint_X)
FunctionalDataProperty(:hasPoint_Y)
FunctionalDataProperty(:hasPoint_Z)
FunctionalDataProperty(:hasRelativeLocation_Description)
FunctionalDataProperty(:hasRobot_Description)
FunctionalDataProperty(:hasRobot_Id)
FunctionalDataProperty(:hasRobot_MaximumLoadWeight)
FunctionalDataProperty(:hasShapeDesign_Description)
FunctionalDataProperty(:hasSku_Description)
FunctionalDataProperty(:hasSku_Id)
FunctionalDataProperty(:hasSku_Weight)
FunctionalDataProperty(:hasVacuumEffector_CupDiameter)
FunctionalDataProperty(:hasVacuumEffector_Length)
FunctionalDataProperty(:hasVector_I)
FunctionalDataProperty(:hasVector_J)
FunctionalDataProperty(:hasVector_K)
FunctionalDataProperty(:hasWorkstation_AngleUnit)
FunctionalDataProperty(:hasWorkstation_LengthUnit)
FunctionalDataProperty(:hasWorkstation_WeightUnit)
FunctionalDataProperty(:isKit_Finished)

FunctionalObjectProperty(:hadByChangingStation_Workstation)
FunctionalObjectProperty(:hadByEndEffector_EndEffectorHolder)
FunctionalObjectProperty(:hadByEndEffector_Robot)
FunctionalObjectProperty(:hadByEndEffectorHolder_ChangingStation)
FunctionalObjectProperty(:hadByKit_LargeBoxWithKits)
FunctionalObjectProperty(:hadByKitDesign_Workstation)
FunctionalObjectProperty(:hadByKitTray_Kit)
FunctionalObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithKits)
FunctionalObjectProperty(:hadByPart_Kit)
FunctionalObjectProperty(:hadByPart_PartsTrayWithParts)
FunctionalObjectProperty(:hadByPartRefAndPose_KitDesign)
FunctionalObjectProperty(:hadByPartsTray_PartsTrayWithParts)
FunctionalObjectProperty(:hadByRobot_Workstation)
FunctionalObjectProperty(:hadBySku_Workstation)
FunctionalObjectProperty(:hadBySolidObject_WorkTable)
FunctionalObjectProperty(:hadByWorkTable_Workstation)

FunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
FunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
FunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
FunctionalObjectProperty(:hasKit_Tray)
FunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
FunctionalObjectProperty(:hasPartRefAndPose_Point)
FunctionalObjectProperty(:hasPartRefAndPose_XAxis)
FunctionalObjectProperty(:hasPartRefAndPose_ZAxis)
FunctionalObjectProperty(:hasPartsTrayWithParts_Tray)
FunctionalObjectProperty(:hasPhysicalLocation_RefObject)
FunctionalObjectProperty(:hasPoseLocation_Point)
FunctionalObjectProperty(:hasPoseLocation_XAxis)
FunctionalObjectProperty(:hasPoseLocation_ZAxis)
FunctionalObjectProperty(:hasRobot_EndEffector)
FunctionalObjectProperty(:hasSku_Shape)
FunctionalObjectProperty(:hasSolidObject_PrimaryLocation)
FunctionalObjectProperty(:hasWorkstation_ChangingStation)
FunctionalObjectProperty(:hasWorkstation_Robot)
FunctionalObjectProperty(:hasWorkstation_WorkTable)

HasKey(:EndEffector () (:hasEndEffector_Id))
HasKey(:KitDesign () (:hasKitDesign_Id))
HasKey(:KitTray () (:hasKitTray_SerialNumber :hasKitTray_SkuRef))
HasKey(:LargeContainer () (:hasLargeContainer_SerialNumber
                           :hasLargeContainer_SkuRef))
HasKey(:Part () (:hasPart_SerialNumber :hasPart_SkuRef))
HasKey(:PartsTray () (:hasPartsTray_SerialNumber :hasPartsTray_SkuRef))
HasKey(:Robot () (:hasRobot_Id))
HasKey(:StockKeepingUnit () (:hasSku_Id))

InverseFunctionalObjectProperty(:hadByChangingStation_Workstation)
InverseFunctionalObjectProperty(:hadByRobot_Workstation)
InverseFunctionalObjectProperty(:hadByWorkTable_Workstation)

InverseFunctionalObjectProperty(:hasChangingStation_EndEffectorHolders)
InverseFunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
InverseFunctionalObjectProperty(:hasKit_Parts)
InverseFunctionalObjectProperty(:hasKit_Tray)
InverseFunctionalObjectProperty(:hasKitDesign_PartRefAndPoses)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_Kits)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Parts)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Tray)
InverseFunctionalObjectProperty(:hasRobot_EndEffector)
InverseFunctionalObjectProperty(:hasWorkstation_ChangingStation)
InverseFunctionalObjectProperty(:hasWorkstation_KitDesigns)
InverseFunctionalObjectProperty(:hasWorkstation_Robot)
InverseFunctionalObjectProperty(:hasWorkstation_Skus)
InverseFunctionalObjectProperty(:hasWorkstation_WorkTable)
InverseFunctionalObjectProperty(:hasWorkTable_SolidObjects)

InverseObjectProperties(:hasChangingStation_EndEffectorHolders
                        :hadByEndEffectorHolder_ChangingStation)
InverseObjectProperties(:hasEndEffectorHolder_EndEffector
                        :hadByEndEffector_EndEffectorHolder)
InverseObjectProperties(:hasKit_Parts
                        :hadByPart_Kit)
InverseObjectProperties(:hasKit_Tray
                        :hadByKitTray_Kit)
InverseObjectProperties(:hasKitDesign_PartRefAndPoses
                        :hadByPartRefAndPose_KitDesign)
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_KitTrays
                        :hadByKitTray_LargeBoxWithEmptyKitTrays)
InverseObjectProperties(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                        :hadByLargeContainer_LargeBoxWithEmptyKitTrays)
InverseObjectProperties(:hasLargeBoxWithKits_Kits
                        :hadByKit_LargeBoxWithKits)
InverseObjectProperties(:hasLargeBoxWithKits_LargeContainer
                        :hadByLargeContainer_LargeBoxWithKits)
InverseObjectProperties(:hasPartsTrayWithParts_Parts
                        :hadByPart_PartsTrayWithParts)
InverseObjectProperties(:hasPartsTrayWithParts_Tray
                        :hadByPartsTray_PartsTrayWithParts)
InverseObjectProperties(:hasRobot_EndEffector
                        :hadByEndEffector_Robot)
InverseObjectProperties(:hasWorkTable_SolidObjects
                        :hadBySolidObject_WorkTable)
InverseObjectProperties(:hasWorkstation_ChangingStation
                        :hadByChangingStation_Workstation)
InverseObjectProperties(:hasWorkstation_KitDesigns
                        :hadByKitDesign_Workstation)
InverseObjectProperties(:hasWorkstation_Robot
                        :hadByRobot_Workstation)
InverseObjectProperties(:hasWorkstation_Skus
                        :hadBySku_Workstation)
InverseObjectProperties(:hasWorkstation_WorkTable
                        :hadByWorkTable_Workstation)

ObjectPropertyDomain(:hadByChangingStation_Workstation
                     :EndEffectorChangingStation)
ObjectPropertyDomain(:hadByEndEffector_EndEffectorHolder :EndEffector)
ObjectPropertyDomain(:hadByEndEffector_Robot :EndEffector)
ObjectPropertyDomain(:hadByEndEffectorHolder_ChangingStation
                     :EndEffectorHolder)
ObjectPropertyDomain(:hadByKit_LargeBoxWithKits :Kit)
ObjectPropertyDomain(:hadByKitDesign_Workstation :KitDesign)
ObjectPropertyDomain(:hadByKitTray_Kit :KitTray)
ObjectPropertyDomain(:hadByKitTray_LargeBoxWithEmptyKitTrays :KitTray)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithEmptyKitTrays
                     :LargeContainer)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithKits :LargeContainer)
ObjectPropertyDomain(:hadByPart_Kit :Part)
ObjectPropertyDomain(:hadByPart_PartsTrayWithParts :Part)
ObjectPropertyDomain(:hadByPartRefAndPose_KitDesign :PartRefAndPose)
ObjectPropertyDomain(:hadByPartsTray_PartsTrayWithParts :PartsTray)
ObjectPropertyDomain(:hadByRobot_Workstation :Robot)
ObjectPropertyDomain(:hadBySku_Workstation :StockKeepingUnit)
ObjectPropertyDomain(:hadBySolidObject_WorkTable :SolidObject)
ObjectPropertyDomain(:hadByWorkTable_Workstation :WorkTable)


ObjectPropertyDomain(:hasBoxVolume_MaximumPoint :BoxVolume)
ObjectPropertyDomain(:hasBoxVolume_MinimumPoint :BoxVolume)
ObjectPropertyDomain(:hasChangingStation_EndEffectorHolders
                     :EndEffectorChangingStation)
ObjectPropertyDomain(:hasEndEffectorHolder_EndEffector :EndEffectorHolder)
ObjectPropertyDomain(:hasKit_Parts :Kit)
ObjectPropertyDomain(:hasKit_Tray :Kit)
ObjectPropertyDomain(:hasKitDesign_PartRefAndPoses :KitDesign)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_KitTrays
                     :LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                     :LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hasLargeBoxWithKits_Kits :LargeBoxWithKits)
ObjectPropertyDomain(:hasLargeBoxWithKits_LargeContainer :LargeBoxWithKits)
ObjectPropertyDomain(:hasPartRefAndPose_Point :PartRefAndPose)
ObjectPropertyDomain(:hasPartRefAndPose_XAxis :PartRefAndPose)
ObjectPropertyDomain(:hasPartRefAndPose_ZAxis :PartRefAndPose)
ObjectPropertyDomain(:hasPartsTrayWithParts_Parts :PartsTrayWithParts)
ObjectPropertyDomain(:hasPartsTrayWithParts_Tray :PartsTrayWithParts)
ObjectPropertyDomain(:hasPhysicalLocation_RefObject :PhysicalLocation)
ObjectPropertyDomain(:hasPoseLocation_Point :PoseLocation)
ObjectPropertyDomain(:hasPoseLocation_XAxis :PoseLocation)
ObjectPropertyDomain(:hasPoseLocation_ZAxis :PoseLocation)
ObjectPropertyDomain(:hasRobot_EndEffector :Robot)
ObjectPropertyDomain(:hasRobot_WorkVolume :Robot)
ObjectPropertyDomain(:hasSku_Shape :StockKeepingUnit)
ObjectPropertyDomain(:hasSolidObject_PrimaryLocation :SolidObject)
ObjectPropertyDomain(:hasSolidObject_SecondaryLocation :SolidObject)
ObjectPropertyDomain(:hasWorkstation_ChangingStation :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_KitDesigns :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_OtherObstacles :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_Robot :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_Skus :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_WorkTable :KittingWorkstation)
ObjectPropertyDomain(:hasWorkTable_SolidObjects :WorkTable)

ObjectPropertyRange(:hadByChangingStation_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadByEndEffector_EndEffectorHolder :EndEffectorHolder)
ObjectPropertyRange(:hadByEndEffector_Robot :Robot)
ObjectPropertyRange(:hadByEndEffectorHolder_ChangingStation
                    :EndEffectorChangingStation)
ObjectPropertyRange(:hadByKit_LargeBoxWithKits :LargeBoxWithKits)
ObjectPropertyRange(:hadByKitDesign_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadByKitTray_Kit :Kit)
ObjectPropertyRange(:hadByKitTray_LargeBoxWithEmptyKitTrays
                    :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithEmptyKitTrays
                    :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithKits :LargeBoxWithKits)
ObjectPropertyRange(:hadByPart_Kit :Kit)
ObjectPropertyRange(:hadByPart_PartsTrayWithParts :PartsTrayWithParts)
ObjectPropertyRange(:hadByPartRefAndPose_KitDesign :KitDesign)
ObjectPropertyRange(:hadByPartsTray_PartsTrayWithParts :PartsTrayWithParts)
ObjectPropertyRange(:hadByRobot_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadBySku_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadBySolidObject_WorkTable :WorkTable)
ObjectPropertyRange(:hadByWorkTable_Workstation :KittingWorkstation)

ObjectPropertyRange(:hasBoxVolume_MaximumPoint :Point)
ObjectPropertyRange(:hasBoxVolume_MinimumPoint :Point)
ObjectPropertyRange(:hasChangingStation_EndEffectorHolders :EndEffectorHolder)
ObjectPropertyRange(:hasEndEffectorHolder_EndEffector :EndEffector)
ObjectPropertyRange(:hasKit_Parts :Part)
ObjectPropertyRange(:hasKit_Tray :KitTray)
ObjectPropertyRange(:hasKitDesign_PartRefAndPoses :PartRefAndPose)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_KitTrays :KitTray)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                    :LargeContainer)
ObjectPropertyRange(:hasLargeBoxWithKits_Kits :Kit)
ObjectPropertyRange(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
ObjectPropertyRange(:hasPartRefAndPose_Point :Point)
ObjectPropertyRange(:hasPartRefAndPose_XAxis :Vector)
ObjectPropertyRange(:hasPartRefAndPose_ZAxis :Vector)
ObjectPropertyRange(:hasPartsTrayWithParts_Parts :Part)
ObjectPropertyRange(:hasPartsTrayWithParts_Tray :PartsTray)
ObjectPropertyRange(:hasPhysicalLocation_RefObject :SolidObject)
ObjectPropertyRange(:hasPoseLocation_Point :Point)
ObjectPropertyRange(:hasPoseLocation_XAxis :Vector)
ObjectPropertyRange(:hasPoseLocation_ZAxis :Vector)
ObjectPropertyRange(:hasRobot_EndEffector :EndEffector)
ObjectPropertyRange(:hasRobot_WorkVolume :BoxVolume)
ObjectPropertyRange(:hasSolidObject_PrimaryLocation :PhysicalLocation)
ObjectPropertyRange(:hasSolidObject_SecondaryLocation :PhysicalLocation)
ObjectPropertyRange(:hasSku_Shape :ShapeDesign)
ObjectPropertyRange(:hasWorkstation_ChangingStation
                    :EndEffectorChangingStation)
ObjectPropertyRange(:hasWorkstation_KitDesigns :KitDesign)
ObjectPropertyRange(:hasWorkstation_OtherObstacles :BoxVolume)
ObjectPropertyRange(:hasWorkstation_Robot :Robot)
ObjectPropertyRange(:hasWorkstation_Skus :StockKeepingUnit)
ObjectPropertyRange(:hasWorkstation_WorkTable :WorkTable)
ObjectPropertyRange(:hasWorkTable_SolidObjects :SolidObject)

// The following SubClassOf statements are not essential because the
// DisjointUnion statements imply them. However, if they are omitted,
// the Protege asserted class hierarchy does not come out right in either
// the Classes view or the OWLViz view. The inferred hierarchy is
// correct if the SubClassOf statements are omitted, however.

SubClassOf(:BoxyObject :SolidObject)
SubClassOf(:BoxVolume :DataThing)
SubClassOf(:EndEffector :SolidObject)
SubClassOf(:EndEffectorChangingStation :SolidObject)
SubClassOf(:EndEffectorHolder :SolidObject)
SubClassOf(:GripperEffector :EndEffector)
SubClassOf(:Kit :SolidObject)
SubClassOf(:KitDesign :DataThing)
SubClassOf(:KittingWorkstation :SolidObject)
SubClassOf(:KitTray :BoxyObject)
SubClassOf(:LargeContainer :BoxyObject)
SubClassOf(:LargeBoxWithEmptyKitTrays :SolidObject)
SubClassOf(:LargeBoxWithKits :SolidObject)
SubClassOf(:Part :SolidObject)
SubClassOf(:PartRefAndPose :DataThing)
SubClassOf(:PartsBin :BoxyObject)
SubClassOf(:PartsTray :BoxyObject)
SubClassOf(:PartsTrayWithParts :SolidObject)
SubClassOf(:PhysicalLocation :DataThing)
SubClassOf(:Point :DataThing)
SubClassOf(:PoseLocation :PhysicalLocation)
SubClassOf(:PoseLocationIn :PoseLocation)
SubClassOf(:PoseLocationOn :PoseLocation)
SubClassOf(:PoseOnlyLocation :PoseLocation)
SubClassOf(:RelativeLocation :PhysicalLocation)
SubClassOf(:RelativeLocationIn :RelativeLocation)
SubClassOf(:RelativeLocationOn :RelativeLocation)
SubClassOf(:Robot :SolidObject)
SubClassOf(:ShapeDesign :DataThing)
SubClassOf(:StockKeepingUnit :DataThing)
SubClassOf(:VacuumEffector :EndEffector)
SubClassOf(:VacuumEffectorMultiCup :VacuumEffector)
SubClassOf(:VacuumEffectorSingleCup :VacuumEffector)
SubClassOf(:Vector :DataThing)
SubClassOf(:WorkTable :BoxyObject)

)
