Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(:=<http://www.nist.gov/el/ontologies/kittingClasses.owl#>)

Ontology(<http://www.nist.gov/el/ontologies/kittingClasses.owl>
Annotation(rdfs:comment "A kitting ontology")

Annotation(rdfs:comment "This does not include plans or individuals.")

Annotation(rdfs:comment "The name of an identifier that is used by a
member of a class to identify itself always ends with 'Id'.  The name
of an identifier that identifies a member of some class other than the
one it is in always ends with 'Ref'.  Where a DataThing may be used by
several other things, it is given an xxxId and the other things use it
via an xxxRef.")

Annotation(rdfs:comment "Since properties are global, most properties
have long names. In all cases, the first part of the name or a
property is 'has' or 'is'. If a name can be divided into three parts,
the second part indicates the sort of thing that has the property. The
last part of the name describes the meaning of the value of the
property. If a name has three parts there is an underscore between the
second and third parts.")

DataPropertyDomain(:hasBin_PartQuantity :PartsBin)
DataPropertyDomain(:hasBin_PartSkuRef :PartsBin)
DataPropertyDomain(:hasBox_Height :BoxyObject)
DataPropertyDomain(:hasBox_Length :BoxyObject)
DataPropertyDomain(:hasBox_Width :BoxyObject)
DataPropertyDomain(:hasEffector_MaximumLoadWeight :EndEffector)
DataPropertyDomain(:hasEndEffector_Description :EndEffector)
DataPropertyDomain(:hasEndEffector_Id :EndEffector)
DataPropertyDomain(:hasEndEffector_Weight :EndEffector)
DataPropertyDomain(:hasKitDesign_Id :KitDesign)
DataPropertyDomain(:hasKitDesign_KitTraySkuRef :KitDesign)
DataPropertyDomain(:hasKitInstance_DesignRef :KitInstance)
DataPropertyDomain(:hasKitTray_SerialNumber :KitTray)
DataPropertyDomain(:hasKitTray_SkuRef :KitTray)
DataPropertyDomain(:hasLargeBoxWithKits_Capacity :LargeBoxWithKits)
DataPropertyDomain(:hasLargeBoxWithKits_KitDesignRef :LargeBoxWithKits)
DataPropertyDomain(:hasLargeContainer_SerialNumber :LargeContainer)
DataPropertyDomain(:hasLargeContainer_SkuRef :LargeContainer)
DataPropertyDomain(:hasMultiCup_ArrayNumber :VacuumEffectorMultiCup)
DataPropertyDomain(:hasMultiCup_ArrayRadius :VacuumEffectorMultiCup)
DataPropertyDomain(:hasPartRefAndPose_Ref :PartRefAndPose)
DataPropertyDomain(:hasPartsTray_SerialNumber :PartsTray)
DataPropertyDomain(:hasPartsTray_SkuRef :PartsTray)
DataPropertyDomain(:hasPart_SerialNumber :Part)
DataPropertyDomain(:hasPart_SkuRef :Part)
DataPropertyDomain(:hasPoint_X :Point)
DataPropertyDomain(:hasPoint_Y :Point)
DataPropertyDomain(:hasPoint_Z :Point)
DataPropertyDomain(:hasRelativeLocationIn_Description :RelativeLocationIn)
DataPropertyDomain(:hasRelativeLocationOn_Description :RelativeLocationOn)
DataPropertyDomain(:hasRobot_Description :Robot)
DataPropertyDomain(:hasRobot_Id :Robot)
DataPropertyDomain(:hasRobot_MaximumLoadWeight :Robot)
DataPropertyDomain(:hasRpy_Pitch :RollPitchYaw)
DataPropertyDomain(:hasRpy_Roll :RollPitchYaw)
DataPropertyDomain(:hasRpy_Yaw :RollPitchYaw)
DataPropertyDomain(:hasShapeDesign_Description :ShapeDesign)
DataPropertyDomain(:hasSku_Description :StockKeepingUnit)
DataPropertyDomain(:hasSku_EndEffectorRefs :StockKeepingUnit)
DataPropertyDomain(:hasSku_Id :StockKeepingUnit)
DataPropertyDomain(:hasSku_Weight :StockKeepingUnit)
DataPropertyDomain(:hasVacuumEffector_CupDiameter :VacuumEffector)
DataPropertyDomain(:hasVacuumEffector_Length :VacuumEffector)
DataPropertyDomain(:hasVector_I :Vector)
DataPropertyDomain(:hasVector_J :Vector)
DataPropertyDomain(:hasVector_K :Vector)
DataPropertyDomain(:hasWorkstation_AngleUnit :KittingWorkstation)
DataPropertyDomain(:hasWorkstation_LengthUnit :KittingWorkstation)
DataPropertyDomain(:hasWorkstation_WeightUnit :KittingWorkstation)
DataPropertyDomain(:isKitInstance_Finished :KitInstance)

DataPropertyRange(:hasBin_PartQuantity xsd:nonNegativeInteger)
DataPropertyRange(:hasBin_PartSkuRef xsd:NMTOKEN)
DataPropertyRange(:hasBox_Height :positiveDecimal)
DataPropertyRange(:hasBox_Length :positiveDecimal)
DataPropertyRange(:hasBox_Width :positiveDecimal)
DataPropertyRange(:hasEffector_MaximumLoadWeight :positiveDecimal)
DataPropertyRange(:hasEndEffector_Description xsd:string)
DataPropertyRange(:hasEndEffector_Id xsd:NMTOKEN)
DataPropertyRange(:hasEndEffector_Weight :positiveDecimal)
DataPropertyRange(:hasKitDesign_Id xsd:NMTOKEN)
DataPropertyRange(:hasKitDesign_KitTraySkuRef xsd:NMTOKEN)
DataPropertyRange(:hasKitInstance_DesignRef xsd:NMTOKEN)
DataPropertyRange(:hasKitTray_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasKitTray_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasLargeBoxWithKits_Capacity xsd:positiveInteger)
DataPropertyRange(:hasLargeBoxWithKits_KitDesignRef xsd:NMTOKEN)
DataPropertyRange(:hasLargeContainer_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasLargeContainer_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasMultiCup_ArrayNumber xsd:positiveInteger)
DataPropertyRange(:hasMultiCup_ArrayRadius :positiveDecimal)
DataPropertyRange(:hasPartRefAndPose_Ref xsd:NMTOKEN)
DataPropertyRange(:hasPartsTray_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasPartsTray_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasPart_SerialNumber xsd:NMTOKEN)
DataPropertyRange(:hasPart_SkuRef xsd:NMTOKEN)
DataPropertyRange(:hasPoint_X xsd:decimal)
DataPropertyRange(:hasPoint_Y xsd:decimal)
DataPropertyRange(:hasPoint_Z xsd:decimal)
DataPropertyRange(:hasRelativeLocationIn_Description xsd:string)
DataPropertyRange(:hasRelativeLocationOn_Description xsd:string)
DataPropertyRange(:hasRobot_Description xsd:string)
DataPropertyRange(:hasRobot_Id xsd:NMTOKEN)
DataPropertyRange(:hasRobot_MaximumLoadWeight :positiveDecimal)
DataPropertyRange(:hasRpy_Pitch xsd:decimal)
DataPropertyRange(:hasRpy_Roll xsd:decimal)
DataPropertyRange(:hasRpy_Yaw xsd:decimal)
DataPropertyRange(:hasShapeDesign_Description xsd:string)
DataPropertyRange(:hasSku_Description xsd:string)
DataPropertyRange(:hasSku_EndEffectorRefs xsd:NMTOKEN)
DataPropertyRange(:hasSku_Id xsd:NMTOKEN)
DataPropertyRange(:hasSku_Weight :positiveDecimal)
DataPropertyRange(:hasVacuumEffector_CupDiameter :positiveDecimal)
DataPropertyRange(:hasVacuumEffector_Length :positiveDecimal)
DataPropertyRange(:hasVector_I xsd:decimal)
DataPropertyRange(:hasVector_J xsd:decimal)
DataPropertyRange(:hasVector_K xsd:decimal)
DataPropertyRange(:hasWorkstation_AngleUnit :angleUnit)
DataPropertyRange(:hasWorkstation_LengthUnit :lengthUnit)
DataPropertyRange(:hasWorkstation_WeightUnit :weightUnit)
DataPropertyRange(:isKitInstance_Finished xsd:boolean)

DatatypeDefinition(:angleUnit DataOneOf("degree" "radian"))
DatatypeDefinition(:lengthUnit DataOneOf("meter" "millimeter" "inch"))
DatatypeDefinition(:positiveDecimal
                   DatatypeRestriction(xsd:decimal xsd:minExclusive
                                       "0"^^xsd:decimal))
DatatypeDefinition(:weightUnit DataOneOf("kilogram" "gram" "milligram"
                                         "ounce" "pound"))

Declaration(Class(:BoxVolume))
AnnotationAssertion(rdfs:comment :BoxVolume
  "A BoxVolume is a DataThing. A BoxVolume has a maximum
   point (hasBoxVolume_MaximumPoint) and a minimum point
   (hasBoxVolume_MinimumPoint). These are diagonally opposite
   corner points of a box shaped volume whose edges are aligned with
   the coordinate system in which the BoxVolume is located. The
   minimum point has the minimum values of X, Y, and Z. The maximum
   point has the maximum values of X, Y, and Z.")

Declaration(Class(:BoxyObject))
AnnotationAssertion(rdfs:comment :BoxyObject
  "A BoxyObject is a SolidObject. A BoxyObject is box shaped. It has a
   length, width, and height (hasBox_Length, hasBox_Width, hasBox_Height).
   It has a preferred partial orientation in which the edges along
   which the height is measured are vertical (parallel to the force of
   gravity).  The length is larger of the two dimensions that are not
   the height.  The width is smaller of the two dimensions that are
   not the height.  The coordinate system of a BoxyObject (i.e. the
   thing that is located and oriented by a pose) has its origin in the
   middle of the bottom, its Z-axis parallel to the height sides, and
   its X-axis parallel to to the length sides. Since this still allows
   two choices for orientation (four if the length and width are
   equal) which may or may not be distinguishable, some subtypes of
   BoxyObject will need one more piece of orientation information.")

Declaration(Class(:DataThing))
AnnotationAssertion(rdfs:comment :DataThing
  "A Data Thing is a Thing. A DataThing includes all complex data types
   such as Vector, PhysicalLocation, etc. Currently, it has no properties.")

Declaration(Class(:EndEffector))
AnnotationAssertion(rdfs:comment :EndEffector
  "An EndEffector is a SolidObject. It is an end effector for a robot.
   An EndEffector has a description (hasEndEffector_Description),
   a weight (hasEndEffector_Weight), an identifier (hasEndEffector_Id),
   and a maximum weight it can lift (hasEffectorMaximimLoadWeight).
   Every EndEffector is either a GripperEffector or a VacuumEffector.
   Every EndEffector in a KittingWorkstation is either attached to the
   end of a robot arm (hadByEndEffector_Robot) or sitting in an
   EndEffectorHolder (hadByEndEffector_EndEffectorHolder) at an
   EndEffectorChangingStation.")
AnnotationAssertion(rdfs:comment :EndEffector
  "It might be better if each EndEffector has an associated data set
   that holds data for a type of EndEffector. Currently, the data is
   is for a specific object, not for a type. The data set would
   be analogous to the SKU data for a Part (it might even be a SKU).")

Declaration(Class(:EndEffectorChangingStation))
AnnotationAssertion(rdfs:comment :EndEffectorChangingStation
  "An EndEffectorChangingStation is a SolidObject. It is a place where
   end effectors are stored and where the robot can change end effectors.
   It has EndEffectorHolders (hasChangingStation_EndEffectorHolders).
   An EndEffectorChangingStation belongs to a KittingWorkstation
   (hadByChangingStation_Workstation)")

Declaration(Class(:EndEffectorHolder))
AnnotationAssertion(rdfs:comment :EndEffectorHolder
  "An EndEffectorHolder is a SolidObject. An EndEffectorHolder holds
   zero or one EndEffector (hasEndEffectorHolder_EndEffector). An
   EndEffectorHolder is part of an EndEffectorChangingStation
   (hadByEndEffectorHolder_ChangingStation).")

Declaration(Class(:GripperEffector))
AnnotationAssertion(rdfs:comment :GripperEffector
  "A GripperEffector is an EndEffector. A GripperEffector holds an
   object by gripping it with fingers or claws.")

Declaration(Class(:KitDesign))
AnnotationAssertion(rdfs:comment :KitDesign
  "A KitDesign is a DataThing. A KitDesign identifies a type of tray
   (hasKitDesign_KitTraySkuRef), intended poses of parts in finished
   kits of this design (hasKitDesign_PartRefAndPoses),
   and an identifier (hasKitDesign_Id) that is unique among KitDesigns.
   The Pose in a PartAndPose is the location of the part relative to
   the coordinate system of the ShapeDesign of the tray.
   Each KitDesign belongs to a KittingWorkstation
   (hadByKitDesign_Workstation).")

Declaration(Class(:KitInstance))
AnnotationAssertion(rdfs:comment :KitInstance
  "A KitInstance is a SolidObject. A KitInstance has an identifier for
   a KitDesign (hasKitInstance_DesignRef), a KitTray
   (hasKitInstance_Tray), a set of Parts (hasKitInstance_Parts), and a
   boolean indicator of whether the KitInstance is finished
   (isKitInstance_Finished). The coordinate system of a KitInstance is
   the same as the coordinate system of its KitTray. The
   PhysicalLocation of a Part in a KitInstance should be given by a
   Pose that is relative to the KitTray. A KitInstance may belong
   to a LargeBoxWithKits (hadByKitInstance_LargeBoxWithKits).")

Declaration(Class(:KittingWorkstation))
AnnotationAssertion(rdfs:comment :KittingWorkstation
  "A KittingWorkstation is a SolidObject. A KittingWorkstation
   contains a work table (hasWorkstation_WorkTable), a robot
   (hasWorkstation_Robot), an EndEffectorChangingStation
   (hasWorkstation_ChangingStation), and other fixed obstacles
   (hasWorkstation_OtherObstacles) such as a computer. A
   KittingWorkstation has an angle unit (hasWorkstation_AngleUnit), a
   length unit (hasWorkstation_LengthUnit) and a weight unit
   (hasWorkstation_WeightUnit). All angle, length, and weight values
   related to the workstation must use those units. A
   KittingWorkstation has StockKeepingUnits it knows about
   (hasWorkstation_Skus).  A KittingWorkstation has
   KitDesigns it knows about (hasWorkstation_KitDesigns). In
   addition, containers of various sorts enter and leave the workstation.
   The robot builds kits of parts by executing kitting plans as directed
   by a kitting plan execution system. The location of each instance of
   KittingWorkstation should be given relative to itself in order to
   end the chain of relative locations.")

Declaration(Class(:KitTray))
AnnotationAssertion(rdfs:comment :KitTray
  "A KitTray is a BoxyObject. A KitTray is designed to hold Parts with
   various SKU ids in known positions. A KitTray has an identifier for
   its SKU (hasKitTray_SkuRef) and a serial number
   (hasKitTray_SerialNumber). A KitTray may belong to a KitInstance
   (hadByKitTray_KitInstance) or to a LargeBoxWithEmptyKitTrays
   (hadByKitTray_LargeBoxWithEmptyKitTrays).")

Declaration(Class(:LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :LargeBoxWithEmptyKitTrays
  "A LargeBoxWithEmptyKitTrays is a SolidObject. A
   LargeBoxWithEmptyKitTrays has a LargeContainer
   (hasLargeBoxWithEmptyKitTrays_LargeContainer) and a set of KitTrays
   which should be empty (hasLargeBoxWithEmptyKitTrays_Trays).  The
   coordinate system of a LargeBoxWithEmptyKitTrays is the same as the
   coordinate system of its LargeContainer. The PhysicalLocation of a
   KitTray in a LargeBoxWithEmptyKitTrays should be given by a Pose
   that is relative to the LargeContainer. The KitTrays in a
   LargeBoxWithEmptyKitTrays are intended to all be of the same SKU,
   although there is currently no formal requirement for that.")

Declaration(Class(:LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :LargeBoxWithKits
  "A LargeBoxWithKits is a SolidObject. A LargeBoxWithKits has
   - a LargeContainer (hasLargeBoxWithKits_LargeContainer)
   - a set of KitInstances (hasLargeBoxWithKits_KitInstances)
   - an identifier for a KitDesign (hasLargeBoxWithKits_KitDesignRef)
   - a positiveInteger giving the maximum number of kits of the given
     design that can be held in the box (hasLargeBoxWithKits_Capacity).
   The coordinate system of a LargeBoxWithKits is the same as the coordinate
   system of its LargeContainer. The PhysicalLocation of a KitInstance in
   a LargeBoxWithKits should be given by a Pose that is relative to the
   LargeContainer. The KitInstances in a LargeBoxWithKits are intended to
   all be of the given design, but there is currently no formal constraint
   requiring that.")

Declaration(Class(:LargeContainer))
AnnotationAssertion(rdfs:comment :LargeContainer
  "A LargeContainer is a BoxyObject. A LargeContainer can hold one or more
   instances of a single type of tray or bin. The single type may be 
   (1) KitTray
   (2) PartsBin
   (3) PartsTray
   (4) KitInstance
   A LargeContainer has an identifier for its SKU (hasLargeContainer_SkuRef)
   and a serial number (hasLargeContainer_SerialNumber). A LargeContainer
   may belong to a LargeBoxWithEmptyKitTrays
   (hadByLargeContainer_LargeBoxWithEmptyKitTrays) or to a
   LargeBoxWithKits (hadByLargeContainer_LargeBoxWithKits).")

Declaration(Class(:Part))
AnnotationAssertion(rdfs:comment :Part
  "A Part is a SolidObject. It has a reference to the identifier of a
   StockKeepingUnit (hasPart_SkuRef) and a SerialNumber
   (hasPart_SerialNumber). A Part may belong to a KitInstance
   (hadByPart_KitInstance) or to a PartsTrayWithParts
   (hadByPart_PartsTrayWithParts).")

Declaration(Class(:PartRefAndPose))
AnnotationAssertion(rdfs:comment :PartRefAndPose
  "A PartRefAndPose is a DataThing.  A PartRefAndPose identifies a
   type of part by giving its SKU id (hasPartRefAndPose_Ref), it
   specifies the location of the part (hasPartRefAndPose_Point), and
   the orientation of the Part (hasPartRefAndPose_Rpy). The Pose is
   relative to the coordinate system of the KitTray identified in the
   KitDesign. A PartRefAndPose belongs to a KitDesign
   (hadByPartRefAndPose_KitDesign).")

Declaration(Class(:PartsBin))
AnnotationAssertion(rdfs:comment :PartsBin
  "A PartsBin is a BoxyObject. A PartsBin holds a number of Parts
   (hasBin_PartQuantity) with the same SKU id (hasBin_PartSkuRef) in unknown
   random positions.")

Declaration(Class(:PartsTray))
AnnotationAssertion(rdfs:comment :PartsTray
  "A PartsTray is a BoxyObject used to hold Parts. A PartsTray has an
   identifier for its SKU (hasPartsTray_SkuRef) and a serial number
   (hasPartsTray_SerialNumber). A PartsTray may belong to a
   PartsTrayWithParts (hadByPartsTray_PartsTrayWithParts).")

Declaration(Class(:PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :PartsTrayWithParts
  "A PartsTrayWithParts is a SolidObject. A PartsTrayWithParts has a
   PartsTray (hasPartsTrayWithParts_PartsTray) and a set of Parts
   (hasPartsTrayWithParts_Parts). The coordinate system of a
   PartsTrayWithParts is the same as the coordinate system of its
   PartsTray. The PhysicalLocation of a Part in a PartsTrayWithParts
   should be given by a Pose that is relative to the PartsTray. The
   Parts in a PartsTrayWithParts are intended to all be of the same
   SKU, although there is currently no formal requirement for that.")

Declaration(Class(:PhysicalLocation))
AnnotationAssertion(rdfs:comment :PhysicalLocation
  "A PhysicalLocation is a DataThing. A PhysicalLocation says where a
   SolidObject is. A PhysicalLocation has a reference object
   (hasPhysicalLocation_RefObject). A PhysicalLocation is either a
   RelativeLocation or a Pose.")

Declaration(Class(:Point))
AnnotationAssertion(rdfs:comment :Point
  "A Point is a DataThing. A Point has X (hasPoint_X), Y (hasPoint_Y),
   and Z (hasPoint_Z) Cartesian coordinates.")

Declaration(Class(:Pose))
AnnotationAssertion(rdfs:comment :Pose
  "A Pose is a PhysicalLocation. A Pose consists of a Point
   (hasPose_Point), a RollPitchYaw (hasPose_Rpy), and a reference
   object inherited from the PhysicalLocation class
   (hasPhysicalLocation_RefObject). The data for the Point and the
   RollPitchYaw are expressed relative to the coordinate system of the
   reference object.")
AnnotationAssertion(rdfs:comment :Pose "It
   might be useful to allow an axis placement (origin point, X-axis
   direction, and Z-axis direction) as an alternative to a Pose.")

Declaration(Class(:RelativeLocation))
AnnotationAssertion(rdfs:comment :RelativeLocation
  "A RelativeLocation is a PhysicalLocation. A RelativeLocation
   indicates that one solid object is on or in another solid object.
   A RelativeLocation is a RelativeLocationIn or a RelativeLocationOn.")

Declaration(Class(:RelativeLocationIn))
AnnotationAssertion(rdfs:comment :RelativeLocationIn
  "A RelativeLocationIn is a RelativeLocation. A RelativeLocationIn
   indicates that the SolidObject in the domain of a
   hasSolidObject_PhysicalLocation property is inside the SolidObject
   in the range. A RelativeLocationIn has a description
   (hasRelativeLocationIn_Description) that is a string. The notion of
   'in' is vague and might be made more precise.")

Declaration(Class(:RelativeLocationOn))
AnnotationAssertion(rdfs:comment :RelativeLocationOn
  "A RelativeLocationOn is a RelativeLocation. A RelativeLocationOn
   indicates that one solid object is on top of another solid object.
   A RelativeLocationOn has a description
   (hasRelativeLocationOn_Description) that is a string. The notion of
   'on top of' is vague and might be made more precise.")

Declaration(Class(:Robot))
AnnotationAssertion(rdfs:comment :Robot
  "A Robot is a SolidObject. A Robot currently has a description
   (hasRobot_Description), a robot id (hasRobot_Id), a work volume
   (hasRobot_WorkVolume), an end effector (hasRobot_EndEffector), and
   a maximum load weight (hasRobot_MaximumLoadWeight). A robot
   belongs to a KittingWorkstation (hadByRobot_Workstation).")
AnnotationAssertion(rdfs:comment :Robot "The Robot ontology given
   here might be expanded greatly to include, for example, its
   kinematic description, the values of joint angles, arm lengths of
   variable length arms, gripper actuation (open, closed, etc.),
   ranges, velocities, and accelerations of each joint, etc.")

Declaration(Class(:RollPitchYaw))
AnnotationAssertion(rdfs:comment :RollPitchYaw
  "A RollPitchYaw is a DataThing. A RollPitchYaw has Roll
   (hasRpy_Roll), Pitch (hasRpy_Pitch), and Yaw (hasRpy_Yaw) values in
   degrees. They are measured in the usual way relative to a right
   handed coordinate system whose position is the usual X-north,
   Y-east, Z-down.")

Declaration(Class(:ShapeDesign))
AnnotationAssertion(rdfs:comment :ShapeDesign
  "A ShapeDesign is a DataThing. This is currently a stub that has
   only a description (hasShapeDesign_Description) that is an xsd:string.")

Declaration(Class(:SolidObject))
AnnotationAssertion(rdfs:comment :SolidObject
  "A SolidObject is a Thing. A SolidObject has a location
   (hasSolidObject_PhysicalLocation) that relates the location of the
   object to the location of some other object. A SolidObject may
   be on a WorkTable (hadBySolidObject_WorkTable).")

Declaration(Class(:StockKeepingUnit))
AnnotationAssertion(rdfs:comment :StockKeepingUnit
  "A StockKeepingUnit is a DataThing. A StockKeepingUnit is a
   description of a type of object. Every StockKeepingUnit has a
   description (hasSku_Description), a shape (hasSku_Shape), that is a
   ShapeDesign, a weight (hasSku_Weight), references to the
   ids of EndEffectors that can handle it (hasSku_EndEffectorRefs),
   and a unique identifier (hasSku_Id). A StockKeepingUnit belongs to a
   KittingWorkstation (hadBySku_Workstation).")

Declaration(Class(:VacuumEffector))
AnnotationAssertion(rdfs:comment :VacuumEffector
  "A VacuumEffector is an EndEffector. A VacuumEffector holds an
   object by putting a cup against the object and applying a vacuum.
   A VacuumEffector is either a VacuumEffectorSingleCup or a
   VacuumEffectorMultiCup.  A VacuumEffector has a cup diameter
   (hasVacuumEffector_CupDiameter) and a length (hasVacuumEffector_Length).")

Declaration(Class(:VacuumEffectorMultiCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "A VacuumEffectorMultiCup is a VacuumEffector with two or more
   identical cups (hasMultiCup_ArrayNumber).  A VacuumEffectorMultiCup
   has an array radius (hasMultiCup_ArrayRadius).  The cups are
   arranged in a circular array spaced evenly apart. The center of the
   wide end of one cup is on the X-axis of the coordinate system of
   the VacuumEffectorMultiCup. The center of the circular array is at
   the origin of the coordinate system. The axis of the array circle
   is the Z axis of the coordinate system, and the length of the
   VacuumEffector is measured along that axis. The wide ends of the
   cups lie on the XY plane of the coordinate system.")
AnnotationAssertion(rdfs:comment :VacuumEffectorMultiCup
  "Note that a square array can be represented easily as circular array.")

Declaration(Class(:VacuumEffectorSingleCup))
AnnotationAssertion(rdfs:comment :VacuumEffectorSingleCup
  "A VacuumEffectorSingleCup is a VacuumEffector with one cup.
   The center of the wide end of the cup (which is a circle) is at
   the origin of the coordinate system of the VacuumEffectorSingleCup.
   The Z axis of the coordinate system is the axis of that circle,
   and the length of the VacuumEffector is measured along that axis.")

Declaration(Class(:Vector))
AnnotationAssertion(rdfs:comment :Vector
  "A Vector is a DataThing. It has I (hasVector_I), J (hasVector_J),
   and K (hasVector_K) components.")

Declaration(Class(:WorkTable))
AnnotationAssertion(rdfs:comment :WorkTable
  "A WorkTable is a BoxyObject. The top of a WorkTable is a flat,
   rectangular, horizontal surface. The length and width of the top
   are those of the BoxyObject. A WorkTable has solid
   objects that are located with respect to the WorkTable, i.e. the
   reference object of each of those solid objects is the WorkTable
   (hasWorkTable_SolidObjects). Typically, those objects will be on
   top of the WorkTable. This property may be deduced by finding all
   the objects located with respect to the WorkTable, so care will be
   required to keep the values of the hasWorkTable_SolidObjects and
   hasPhysicalLocation_RefObject properties consistent. A WorkTable
   belongs to a Workstation (hadByWorkTable_Workstation).")

// In the following DataProperty Declarations, there is may be a more
// formal method of representing the AnnotationAssertions. There would be
// (probably) if the properties were ObjectProperty rather than DataProperty.

Declaration(DataProperty(:hasBin_PartQuantity))
Declaration(DataProperty(:hasBin_PartSkuRef))
Declaration(DataProperty(:hasBox_Height))
Declaration(DataProperty(:hasBox_Length))
Declaration(DataProperty(:hasBox_Width))
Declaration(DataProperty(:hasEndEffector_Description))
Declaration(DataProperty(:hasEndEffector_Id))
Declaration(DataProperty(:hasEndEffector_Weight))
Declaration(DataProperty(:hasEffector_MaximumLoadWeight))
Declaration(DataProperty(:hasKitDesign_Id))
Declaration(DataProperty(:hasKitDesign_KitTraySkuRef))
AnnotationAssertion(rdfs:comment :hasKitDesign_KitTraySkuRef
  "Each KitDesign has a NMTOKEN as the value of hasKitDesign_KitTraySkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasKitInstance_DesignRef))
Declaration(DataProperty(:hasKitTray_SerialNumber))
Declaration(DataProperty(:hasKitTray_SkuRef))
AnnotationAssertion(rdfs:comment :hasKitTray_SkuRef
  "Each KitTray has a NMTOKEN as the value of hasKitTray_SkuRef. That NMTOKEN
   must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasLargeBoxWithKits_Capacity))
Declaration(DataProperty(:hasLargeBoxWithKits_KitDesignRef))
Declaration(DataProperty(:hasLargeContainer_SerialNumber))
Declaration(DataProperty(:hasLargeContainer_SkuRef))
AnnotationAssertion(rdfs:comment :hasLargeContainer_SkuRef
  "Each LargeContainer has a NMTOKEN as the value of hasLargeContainer_SkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasMultiCup_ArrayNumber))
Declaration(DataProperty(:hasMultiCup_ArrayRadius))
Declaration(DataProperty(:hasPartRefAndPose_Ref))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Ref
  "A PartRefAndPose has a reference to the id of SKU that is the
   SKU of a Part.")
Declaration(DataProperty(:hasPartsTray_SerialNumber))
Declaration(DataProperty(:hasPartsTray_SkuRef))
AnnotationAssertion(rdfs:comment :hasPartsTray_SkuRef
  "Each PartsTray has a NMTOKEN as the value of hasPartsTray_SkuRef.
   That NMTOKEN must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasPart_SerialNumber))
Declaration(DataProperty(:hasPart_SkuRef))
AnnotationAssertion(rdfs:comment :hasPart_SkuRef
  "Each Part has a NMTOKEN as the value of hasPart_SkuRef. That NMTOKEN
   must be the value of hasSku_Id of some StockKeepingUnit.")
Declaration(DataProperty(:hasPoint_X))
Declaration(DataProperty(:hasPoint_Y))
Declaration(DataProperty(:hasPoint_Z))
Declaration(DataProperty(:hasRelativeLocationIn_Description))
Declaration(DataProperty(:hasRelativeLocationOn_Description))
Declaration(DataProperty(:hasRobot_Description))
Declaration(DataProperty(:hasRobot_Id))
Declaration(DataProperty(:hasRobot_MaximumLoadWeight))
AnnotationAssertion(rdfs:comment :hasRobot_MaximumLoadWeight
  "The maximum load weight includes the weight of the end effector.")
Declaration(DataProperty(:hasRpy_Pitch))
Declaration(DataProperty(:hasRpy_Roll))
Declaration(DataProperty(:hasRpy_Yaw))
Declaration(DataProperty(:hasShapeDesign_Description))
Declaration(DataProperty(:hasSku_EndEffectorRefs))
AnnotationAssertion(rdfs:comment :hasSku_EndEffectorRefs
  "A StockKeepingUnit has references to the ids of EndEffectors
   that can handle the StockKeepingUnit.")
Declaration(DataProperty(:hasSku_Description))
Declaration(DataProperty(:hasSku_Id))
Declaration(DataProperty(:hasSku_Weight))
Declaration(DataProperty(:hasVacuumEffector_CupDiameter))
Declaration(DataProperty(:hasVacuumEffector_Length))
Declaration(DataProperty(:hasVector_I))
Declaration(DataProperty(:hasVector_J))
Declaration(DataProperty(:hasVector_K))
Declaration(DataProperty(:hasWorkstation_AngleUnit))
Declaration(DataProperty(:hasWorkstation_LengthUnit))
Declaration(DataProperty(:hasWorkstation_WeightUnit))
Declaration(DataProperty(:isKitInstance_Finished))

Declaration(ObjectProperty(:hadByChangingStation_Workstation))
AnnotationAssertion(rdfs:comment :hadByChangingStation_Workstation
  "An EndEffectorChangingStation belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadByEndEffector_EndEffectorHolder))
AnnotationAssertion(rdfs:comment :hadByEndEffector_EndEffectorHolder
  "An EndEffector may be in an EndEffectorHolder.")

Declaration(ObjectProperty(:hadByEndEffector_Robot))
AnnotationAssertion(rdfs:comment :hadByEndEffector_Robot
  "An EndEffector may belong to a Robot.")

Declaration(ObjectProperty(:hadByEndEffectorHolder_ChangingStation))
AnnotationAssertion(rdfs:comment :hadByEndEffectorHolder_ChangingStation
  "An EndEffectorHolder belongs to an EndEffectorChangingStation.")

Declaration(ObjectProperty(:hadByKitDesign_Workstation))
AnnotationAssertion(rdfs:comment :hadByKitDesign_Workstation
  "A KitDesign belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadByKitInstance_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByKitInstance_LargeBoxWithKits
  "A KitInstance may belong to a LargeBoxWithKits.")

Declaration(ObjectProperty(:hadByKitTray_KitInstance))
AnnotationAssertion(rdfs:comment :hadByKitTray_KitInstance
  "A KitTray may belong to a KitInstance.")

Declaration(ObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByKitTray_LargeBoxWithEmptyKitTrays
  "A KitTray may belong to a LargeBoxWithEmptyKitTrays.")

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithEmptyKitTrays
  "A LargeContainer may belong to a LargeBoxWithEmptyKitTrays.")

Declaration(ObjectProperty(:hadByLargeContainer_LargeBoxWithKits))
AnnotationAssertion(rdfs:comment :hadByLargeContainer_LargeBoxWithKits
  "A LargeContainer may belong to a LargeBoxWithKits.")

Declaration(ObjectProperty(:hadByPart_KitInstance))
AnnotationAssertion(rdfs:comment :hadByPart_KitInstance
  "A Part may belong to a KitInstance.")

Declaration(ObjectProperty(:hadByPart_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPart_PartsTrayWithParts
  "A Part may belong to a PartsTrayWithParts.")

Declaration(ObjectProperty(:hadByPartRefAndPose_KitDesign))
AnnotationAssertion(rdfs:comment :hadByPartRefAndPose_KitDesign
  "A PartRefAndPose belongs to a KitDesign.")

Declaration(ObjectProperty(:hadByPartsTray_PartsTrayWithParts))
AnnotationAssertion(rdfs:comment :hadByPartsTray_PartsTrayWithParts
  "A PartsTray may belong to a PartsTrayWithParts.")

Declaration(ObjectProperty(:hadByRobot_Workstation))
AnnotationAssertion(rdfs:comment :hadByRobot_Workstation
  "A Robot belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadBySku_Workstation))
AnnotationAssertion(rdfs:comment :hadBySku_Workstation
  "A StockKeepingUnit belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hadBySolidObject_WorkTable))
AnnotationAssertion(rdfs:comment :hadBySolidObject_WorkTable
  "A SolidObject may belong to a WorkTable.")

Declaration(ObjectProperty(:hadByWorkTable_Workstation))
AnnotationAssertion(rdfs:comment :hadByWorkTable_Workstation
  "A WorkTable belongs to a KittingWorkstation.")

Declaration(ObjectProperty(:hasBoxVolume_MaximumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MaximumPoint
  "A BoxVolume has a maximum Point.")

Declaration(ObjectProperty(:hasBoxVolume_MinimumPoint))
AnnotationAssertion(rdfs:comment :hasBoxVolume_MinimumPoint
  "A BoxVolume has a minimum Point.")

Declaration(ObjectProperty(:hasChangingStation_EndEffectorHolders))
AnnotationAssertion(rdfs:comment :hasChangingStation_EndEffectorHolders
  "An EndEffectorChangingStation has EndEffectorHolders.")

Declaration(ObjectProperty(:hasEndEffectorHolder_EndEffector))
AnnotationAssertion(rdfs:comment :hasEndEffectorHolder_EndEffector
  "An EndEffectorHolder holds zero or one EndEffector.")

Declaration(ObjectProperty(:hasKitDesign_PartRefAndPoses))
AnnotationAssertion(rdfs:comment :hasKitDesign_PartRefAndPoses
  "A KitDesign has PartRefAndPoses.")

Declaration(ObjectProperty(:hasKitInstance_Parts))
AnnotationAssertion(rdfs:comment :hasKitInstance_Parts
  "A KitInstance has zero to many Parts.")

Declaration(ObjectProperty(:hasKitInstance_Tray))
AnnotationAssertion(rdfs:comment :hasKitInstance_Tray
  "A KitInstance has a KitTray.")

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_KitTrays
  "A LargeBoxWithEmptyKitTrays has zero to many KitTrays.")

Declaration(ObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithEmptyKitTrays_LargeContainer
  "A LargeBoxWithEmptyKitTrays has a LargeContainer.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_LargeContainer))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_LargeContainer
  "A LargeBoxWithKits has a LargeContainer.")

Declaration(ObjectProperty(:hasLargeBoxWithKits_KitInstances))
AnnotationAssertion(rdfs:comment :hasLargeBoxWithKits_KitInstances
  "A LargeBoxWithKits has zero to many KitInstances.")

Declaration(ObjectProperty(:hasPartRefAndPose_Point))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Point
  "A PartRefAndPose has a Point.")

Declaration(ObjectProperty(:hasPartRefAndPose_Rpy))
AnnotationAssertion(rdfs:comment :hasPartRefAndPose_Rpy
  "A PartRefAndPose has a RollPitchYaw.")

Declaration(ObjectProperty(:hasPartsTrayWithParts_Parts))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_Parts
  "A PartsTrayWithParts has zero to many Parts.")

Declaration(ObjectProperty(:hasPartsTrayWithParts_PartsTray))
AnnotationAssertion(rdfs:comment :hasPartsTrayWithParts_PartsTray
  "A PartsTrayWithParts has a PartsTray.")

Declaration(ObjectProperty(:hasPhysicalLocation_RefObject))
AnnotationAssertion(rdfs:comment :hasPhysicalLocation_RefObject
  "The hasPhysicalLocation_RefObject property is used for a
   PhysicalLocation and only a PhysicalLocation. The referencing
   object (the one in the domain) and the referenced object (the one
   in the range) are both SolidObjects.  If the PhysicalLocation is a
   Pose, the coordinate system of the referenced object is the
   reference coordinate system for the Pose, and the Pose locates the
   referencing object. If the PhysicalLocation is a RelativeLocation,
   the referenced object is the SolidObject that the referring
   SolidObject is inside of or on.")

Declaration(ObjectProperty(:hasPose_Point))
AnnotationAssertion(rdfs:comment :hasPose_Point
  "A Pose has a pose point that is a Point. The origin of the coordinate
   system of the SolidObject that is located by the Pose is placed
   at the pose point.")

Declaration(ObjectProperty(:hasPose_Rpy))
AnnotationAssertion(rdfs:comment :hasPose_Rpy
  "A Pose has a RollPitchYaw.")

Declaration(ObjectProperty(:hasRobot_EndEffector))
AnnotationAssertion(rdfs:comment :hasRobot_EndEffector
  "A Robot has zero or one EndEffector.")

Declaration(ObjectProperty(:hasRobot_WorkVolume))
AnnotationAssertion(rdfs:comment :hasRobot_WorkVolume
  "A Robot has a work volume that is the union of one to many BoxVolumes
   representing space into which the robot can move its end effector in
   the absence of other obstacles. The coordinate system of the BoxVolumes
   is the coordinate system of the robot.")

Declaration(ObjectProperty(:hasSku_Shape))
AnnotationAssertion(rdfs:comment :hasSku_Shape
  "A StockKeepingUnit has a ShapeDesign.")

Declaration(ObjectProperty(:hasSolidObject_PhysicalLocation))
AnnotationAssertion(rdfs:comment :hasSolidObject_PhysicalLocation
  "All SolidObjects have a PhysicalLocation, and (in this ontology, which
   does not deal with liquid or gas objects) only SolidObjects have one.")
AnnotationAssertion(rdfs:comment :hasSolidObject_PhysicalLocation
  "Currently, a SolidObject cannot have both a RelativeLocation and a
   Pose. It might be useful to allow both.")

Declaration(ObjectProperty(:hasWorkstation_ChangingStation))
AnnotationAssertion(rdfs:comment :hasWorkstation_ChangingStation
  "A KittingWorkstation has an EndEffectorChangingStation.")

Declaration(ObjectProperty(:hasWorkstation_KitDesigns))
AnnotationAssertion(rdfs:comment :hasWorkstation_KitDesigns
  "A KittingWorkstation has a library of KitDesigns which contains
   KitDesigns.")

Declaration(ObjectProperty(:hasWorkstation_OtherObstacles))
AnnotationAssertion(rdfs:comment :hasWorkstation_OtherObstacles
  "A KittingWorkstation has other obstacles that are described by
   BoxVolumes representing occupied space through which the robot
   should not attempt to move The coordinate system of the BoxVolumes
   is the coordinate system of the KittingWorkstation.")

Declaration(ObjectProperty(:hasWorkstation_Robot))
AnnotationAssertion(rdfs:comment :hasWorkstation_Robot
  "A KittingWorkstation has a Robot.")

Declaration(ObjectProperty(:hasWorkstation_Skus))
AnnotationAssertion(rdfs:comment :hasWorkstation_Skus
  "A KittingWorkstation has a library of Skus, which contains
   StockKeepingUnits.")

Declaration(ObjectProperty(:hasWorkstation_WorkTable))
AnnotationAssertion(rdfs:comment :hasWorkstation_WorkTable
  "A KittingWorkstation has a WorkTable.")

Declaration(ObjectProperty(:hasWorkTable_SolidObjects))
AnnotationAssertion(rdfs:comment :hasWorkTable_SolidObjects
  "A WorkTable has SolidObjects located with respect to itself.")

// Protege apparently does not recognize the built-in class Thing if
// a direct reference is made to it. For example, the statement
// DisjointUnion(:Thing :DataThing :SolidObject) causes a new class
// called Thing to come into existence as a subclass of built-in Thing.
// Hence, only the following DisjointClasses statement is made for
// :DataThing and :SolidObject, which are the two top-level subclasses
// of Thing.

DisjointClasses(:DataThing
                :SolidObject)

DisjointUnion(:BoxyObject
              :KitTray
              :LargeContainer
              :PartsBin
              :PartsTray
              :WorkTable)

DisjointUnion(:DataThing
              :BoxVolume
              :KitDesign
              :PartRefAndPose
              :PhysicalLocation
              :Point
              :RollPitchYaw
              :ShapeDesign
              :StockKeepingUnit
              :Vector)

DisjointUnion(:EndEffector
              :GripperEffector
              :VacuumEffector)

DisjointUnion(:PhysicalLocation
              :Pose
              :RelativeLocation)

DisjointUnion(:RelativeLocation
              :RelativeLocationIn
              :RelativeLocationOn)

DisjointUnion(:SolidObject
              :BoxyObject
              :EndEffector
              :EndEffectorChangingStation
              :EndEffectorHolder
              :KitInstance
              :KittingWorkstation
              :LargeBoxWithEmptyKitTrays
              :LargeBoxWithKits
              :Part
              :PartsTrayWithParts
              :Robot)

DisjointUnion(:VacuumEffector
              :VacuumEffectorSingleCup
              :VacuumEffectorMultiCup)

// It is probably feasible to write several more EquivalentClass statements.

EquivalentClasses(:BoxVolume
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasBoxVolume_MaximumPoint
                                              :Point)
                         ObjectAllValuesFrom(:hasBoxVolume_MaximumPoint
                                             :Point)))

EquivalentClasses(:BoxVolume
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasBoxVolume_MinimumPoint
                                              :Point)
                         ObjectAllValuesFrom(:hasBoxVolume_MinimumPoint
                                             :Point)))

EquivalentClasses(:BoxyObject
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBox_Length :positiveDecimal)
                         DataSomeValuesFrom(:hasBox_Width :positiveDecimal)
                         DataSomeValuesFrom(:hasBox_Height :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Length :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Width :positiveDecimal)
                         DataAllValuesFrom(:hasBox_Height :positiveDecimal)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEffector_MaximumLoadWeight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasEffector_MaximumLoadWeight
                                            :positiveDecimal)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasEndEffector_Description
                                            xsd:string)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasEndEffector_Id xsd:NMTOKEN)))

EquivalentClasses(:EndEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasEndEffector_Weight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasEndEffector_Weight
                                            :positiveDecimal)))

EquivalentClasses(:KitDesign
    ObjectIntersectionOf(DataSomeValuesFrom(:hasKitDesign_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasKitDesign_Id xsd:NMTOKEN)))

EquivalentClasses(:KitInstance
    ObjectIntersectionOf(DataSomeValuesFrom(:isKitInstance_Finished
                                            xsd:boolean)
                         DataAllValuesFrom(:isKitInstance_Finished
                                           xsd:boolean)))

EquivalentClasses(:KitInstance
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasKitInstance_Tray :KitTray)
                         ObjectAllValuesFrom(:hasKitInstance_Tray :KitTray)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_AngleUnit
                         :angleUnit)
                         DataAllValuesFrom(:hasWorkstation_AngleUnit
                         :angleUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_LengthUnit
                         :lengthUnit)
                         DataAllValuesFrom(:hasWorkstation_LengthUnit
                         :lengthUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(DataSomeValuesFrom(:hasWorkstation_WeightUnit
                         :weightUnit)
                         DataAllValuesFrom(:hasWorkstation_WeightUnit
                         :weightUnit)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_ChangingStation
                                              :EndEffectorChangingStation)
                         ObjectAllValuesFrom(:hasWorkstation_ChangingStation
                                             :EndEffectorChangingStation)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_Robot :Robot)
                         ObjectAllValuesFrom(:hasWorkstation_Robot :Robot)))

EquivalentClasses(:KittingWorkstation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasWorkstation_WorkTable
                                              :WorkTable)
                         ObjectAllValuesFrom(:hasWorkstation_WorkTable
                                             :WorkTable)))

EquivalentClasses(:LargeBoxWithEmptyKitTrays
    ObjectIntersectionOf(ObjectSomeValuesFrom(
                                 :hasLargeBoxWithEmptyKitTrays_LargeContainer
                                              :LargeContainer)
                         ObjectAllValuesFrom(
                                 :hasLargeBoxWithEmptyKitTrays_LargeContainer
                                             :LargeContainer)))

EquivalentClasses(:LargeBoxWithKits
    ObjectIntersectionOf(ObjectSomeValuesFrom(
                                          :hasLargeBoxWithKits_LargeContainer
                                              :LargeContainer)
                         ObjectAllValuesFrom(
                                          :hasLargeBoxWithKits_LargeContainer
                                             :LargeContainer)))

EquivalentClasses(:PartRefAndPose
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPartRefAndPose_Ref
                                            xsd:NMTOKEN)
                         DataAllValuesFrom(:hasPartRefAndPose_Ref
                                            xsd:NMTOKEN)))

EquivalentClasses(:PartsBin
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBin_PartQuantity
                                            xsd:nonNegativeInteger)
                         DataAllValuesFrom(:hasBin_PartQuantity
                                            xsd:nonNegativeInteger)))

EquivalentClasses(:PartsBin
    ObjectIntersectionOf(DataSomeValuesFrom(:hasBin_PartSkuRef
                                            xsd:NMTOKEN)
                         DataAllValuesFrom(:hasBin_PartSkuRef
                                            xsd:NMTOKEN)))

EquivalentClasses(:PartsTrayWithParts
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPartsTrayWithParts_PartsTray
                                              :PartsTray)
                         ObjectAllValuesFrom(:hasPartsTrayWithParts_PartsTray
                                             :PartsTray)))

EquivalentClasses(:PhysicalLocation
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPhysicalLocation_RefObject
                                              :SolidObject)
                         ObjectAllValuesFrom(:hasPhysicalLocation_RefObject
                                             :SolidObject)))

EquivalentClasses(:Point
    ObjectIntersectionOf(DataSomeValuesFrom(:hasPoint_X xsd:decimal)
                         DataSomeValuesFrom(:hasPoint_Y xsd:decimal)
                         DataSomeValuesFrom(:hasPoint_Z xsd:decimal)
                         DataAllValuesFrom(:hasPoint_X xsd:decimal)
                         DataAllValuesFrom(:hasPoint_Y xsd:decimal)
                         DataAllValuesFrom(:hasPoint_Z xsd:decimal)))

EquivalentClasses(:Pose
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasPose_Rpy :RollPitchYaw)
                         ObjectAllValuesFrom(:hasPose_Rpy :RollPitchYaw)
                         ObjectSomeValuesFrom(:hasPose_Point :Point)
                         ObjectAllValuesFrom(:hasPose_Point :Point)))

EquivalentClasses(:RelativeLocationIn
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRelativeLocationIn_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasRelativeLocationIn_Description
                                           xsd:string)))

EquivalentClasses(:RelativeLocationOn
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRelativeLocationOn_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasRelativeLocationOn_Description
                                           xsd:string)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_Description xsd:string)
                         DataAllValuesFrom(:hasRobot_Description xsd:string)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasRobot_Id xsd:NMTOKEN)))

EquivalentClasses(:Robot
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRobot_MaximumLoadWeight
                                            :positiveDecimal)
                         DataAllValuesFrom(:hasRobot_MaximumLoadWeight
                                            :positiveDecimal)))

EquivalentClasses(:RollPitchYaw
    ObjectIntersectionOf(DataSomeValuesFrom(:hasRpy_Roll xsd:decimal)
                         DataSomeValuesFrom(:hasRpy_Pitch xsd:decimal)
                         DataSomeValuesFrom(:hasRpy_Yaw xsd:decimal)
                         DataAllValuesFrom(:hasRpy_Roll xsd:decimal)
                         DataAllValuesFrom(:hasRpy_Pitch xsd:decimal)
                         DataAllValuesFrom(:hasRpy_Yaw xsd:decimal)))

EquivalentClasses(:ShapeDesign
    ObjectIntersectionOf(DataSomeValuesFrom(:hasShapeDesign_Description
                                            xsd:string)
                         DataAllValuesFrom(:hasShapeDesign_Description
                                           xsd:string)))

EquivalentClasses(:SolidObject
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasSolidObject_PhysicalLocation
                                              :PhysicalLocation)
                         ObjectAllValuesFrom(:hasSolidObject_PhysicalLocation
                                             :PhysicalLocation)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Description xsd:string)
                         DataAllValuesFrom(:hasSku_Description xsd:string)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Id xsd:NMTOKEN)
                         DataAllValuesFrom(:hasSku_Id xsd:NMTOKEN)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(ObjectSomeValuesFrom(:hasSku_Shape
                                              :ShapeDesign)
                         ObjectAllValuesFrom(:hasSku_Shape
                                             :ShapeDesign)))

EquivalentClasses(:StockKeepingUnit
    ObjectIntersectionOf(DataSomeValuesFrom(:hasSku_Weight :positiveDecimal)
                         DataAllValuesFrom(:hasSku_Weight :positiveDecimal)))


EquivalentClasses(:VacuumEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVacuumEffector_CupDiameter
                         :positiveDecimal)
                         DataAllValuesFrom(:hasVacuumEffector_CupDiameter
                         :positiveDecimal)))

EquivalentClasses(:VacuumEffector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVacuumEffector_Length
                         :positiveDecimal)
                         DataAllValuesFrom(:hasVacuumEffector_Length
                         :positiveDecimal)))

EquivalentClasses(:VacuumEffectorMultiCup
    ObjectIntersectionOf(DataSomeValuesFrom(:hasMultiCup_ArrayNumber
                         xsd:positiveInteger)
                         DataAllValuesFrom(:hasMultiCup_ArrayNumber
                         xsd:positiveInteger)))

EquivalentClasses(:VacuumEffectorMultiCup
    ObjectIntersectionOf(DataSomeValuesFrom(:hasMultiCup_ArrayRadius
                         :positiveDecimal)
                         DataAllValuesFrom(:hasMultiCup_ArrayRadius
                         :positiveDecimal)))

EquivalentClasses(:Vector
    ObjectIntersectionOf(DataSomeValuesFrom(:hasVector_I xsd:decimal)
                         DataSomeValuesFrom(:hasVector_J xsd:decimal)
                         DataSomeValuesFrom(:hasVector_K xsd:decimal)
                         DataAllValuesFrom(:hasVector_I xsd:decimal)
                         DataAllValuesFrom(:hasVector_J xsd:decimal)
                         DataAllValuesFrom(:hasVector_K xsd:decimal)))

FunctionalDataProperty(:hasBin_PartQuantity)
FunctionalDataProperty(:hasBin_PartSkuRef)
FunctionalDataProperty(:hasBox_Height)
FunctionalDataProperty(:hasBox_Length)
FunctionalDataProperty(:hasBox_Width)
FunctionalDataProperty(:hasEffector_MaximumLoadWeight)
FunctionalDataProperty(:hasEndEffector_Description)
FunctionalDataProperty(:hasEndEffector_Id)
FunctionalDataProperty(:hasEndEffector_Weight)
FunctionalDataProperty(:hasKitDesign_Id)
FunctionalDataProperty(:hasKitDesign_KitTraySkuRef)
FunctionalDataProperty(:hasKitInstance_DesignRef)
FunctionalDataProperty(:hasKitTray_SerialNumber)
FunctionalDataProperty(:hasKitTray_SkuRef)
FunctionalDataProperty(:hasLargeBoxWithKits_Capacity)
FunctionalDataProperty(:hasLargeBoxWithKits_KitDesignRef)
FunctionalDataProperty(:hasLargeContainer_SerialNumber)
FunctionalDataProperty(:hasLargeContainer_SkuRef)
FunctionalDataProperty(:hasMultiCup_ArrayNumber)
FunctionalDataProperty(:hasMultiCup_ArrayRadius)
FunctionalDataProperty(:hasPartRefAndPose_Ref)
FunctionalDataProperty(:hasPartsTray_SerialNumber)
FunctionalDataProperty(:hasPartsTray_SkuRef)
FunctionalDataProperty(:hasPart_SerialNumber)
FunctionalDataProperty(:hasPart_SkuRef)
FunctionalDataProperty(:hasPoint_X)
FunctionalDataProperty(:hasPoint_Y)
FunctionalDataProperty(:hasPoint_Z)
FunctionalDataProperty(:hasRelativeLocationIn_Description)
FunctionalDataProperty(:hasRelativeLocationOn_Description)
FunctionalDataProperty(:hasRobot_Description)
FunctionalDataProperty(:hasRobot_Id)
FunctionalDataProperty(:hasRobot_MaximumLoadWeight)
FunctionalDataProperty(:hasRpy_Pitch)
FunctionalDataProperty(:hasRpy_Roll)
FunctionalDataProperty(:hasRpy_Yaw)
FunctionalDataProperty(:hasShapeDesign_Description)
FunctionalDataProperty(:hasSku_Description)
FunctionalDataProperty(:hasSku_Id)
FunctionalDataProperty(:hasSku_Weight)
FunctionalDataProperty(:hasVacuumEffector_CupDiameter)
FunctionalDataProperty(:hasVacuumEffector_Length)
FunctionalDataProperty(:hasVector_I)
FunctionalDataProperty(:hasVector_J)
FunctionalDataProperty(:hasVector_K)
FunctionalDataProperty(:hasWorkstation_AngleUnit)
FunctionalDataProperty(:hasWorkstation_LengthUnit)
FunctionalDataProperty(:hasWorkstation_WeightUnit)
FunctionalDataProperty(:isKitInstance_Finished)

FunctionalObjectProperty(:hadByChangingStation_Workstation)
FunctionalObjectProperty(:hadByEndEffector_EndEffectorHolder)
FunctionalObjectProperty(:hadByEndEffector_Robot)
FunctionalObjectProperty(:hadByEndEffectorHolder_ChangingStation)
FunctionalObjectProperty(:hadByKitDesign_Workstation)
FunctionalObjectProperty(:hadByKitInstance_LargeBoxWithKits)
FunctionalObjectProperty(:hadByKitTray_KitInstance)
FunctionalObjectProperty(:hadByKitTray_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithEmptyKitTrays)
FunctionalObjectProperty(:hadByLargeContainer_LargeBoxWithKits)
FunctionalObjectProperty(:hadByPart_KitInstance)
FunctionalObjectProperty(:hadByPart_PartsTrayWithParts)
FunctionalObjectProperty(:hadByPartRefAndPose_KitDesign)
FunctionalObjectProperty(:hadByPartsTray_PartsTrayWithParts)
FunctionalObjectProperty(:hadByRobot_Workstation)
FunctionalObjectProperty(:hadBySku_Workstation)
FunctionalObjectProperty(:hadBySolidObject_WorkTable)
FunctionalObjectProperty(:hadByWorkTable_Workstation)

FunctionalObjectProperty(:hasBoxVolume_MaximumPoint)
FunctionalObjectProperty(:hasBoxVolume_MinimumPoint)
FunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
FunctionalObjectProperty(:hasKitInstance_Tray)
FunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
FunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
FunctionalObjectProperty(:hasPartRefAndPose_Point)
FunctionalObjectProperty(:hasPartRefAndPose_Rpy)
FunctionalObjectProperty(:hasPartsTrayWithParts_PartsTray)
FunctionalObjectProperty(:hasPhysicalLocation_RefObject)
FunctionalObjectProperty(:hasPose_Point)
FunctionalObjectProperty(:hasPose_Rpy)
FunctionalObjectProperty(:hasRobot_EndEffector)
FunctionalObjectProperty(:hasSku_Shape)
FunctionalObjectProperty(:hasSolidObject_PhysicalLocation)
FunctionalObjectProperty(:hasWorkstation_ChangingStation)
FunctionalObjectProperty(:hasWorkstation_Robot)
FunctionalObjectProperty(:hasWorkstation_WorkTable)

HasKey(:EndEffector () (:hasEndEffector_Id))
HasKey(:KitDesign () (:hasKitDesign_Id))
HasKey(:KitTray () (:hasKitTray_SerialNumber :hasKitTray_SkuRef))
HasKey(:LargeContainer () (:hasLargeContainer_SerialNumber
                           :hasLargeContainer_SkuRef))
HasKey(:Part () (:hasPart_SerialNumber :hasPart_SkuRef))
HasKey(:PartsTray () (:hasPartsTray_SerialNumber :hasPartsTray_SkuRef))
HasKey(:Robot () (:hasRobot_Id))
HasKey(:StockKeepingUnit () (:hasSku_Id))

InverseFunctionalObjectProperty(:hadByChangingStation_Workstation)
InverseFunctionalObjectProperty(:hadByRobot_Workstation)
InverseFunctionalObjectProperty(:hadByWorkTable_Workstation)

InverseFunctionalObjectProperty(:hasChangingStation_EndEffectorHolders)
InverseFunctionalObjectProperty(:hasEndEffectorHolder_EndEffector)
InverseFunctionalObjectProperty(:hasKitDesign_PartRefAndPoses)
InverseFunctionalObjectProperty(:hasKitInstance_Parts)
InverseFunctionalObjectProperty(:hasKitInstance_Tray)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_KitTrays)
InverseFunctionalObjectProperty(:hasLargeBoxWithEmptyKitTrays_LargeContainer)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_KitInstances)
InverseFunctionalObjectProperty(:hasLargeBoxWithKits_LargeContainer)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_Parts)
InverseFunctionalObjectProperty(:hasPartsTrayWithParts_PartsTray)
InverseFunctionalObjectProperty(:hasRobot_EndEffector)
InverseFunctionalObjectProperty(:hasWorkstation_ChangingStation)
InverseFunctionalObjectProperty(:hasWorkstation_KitDesigns)
InverseFunctionalObjectProperty(:hasWorkstation_Robot)
InverseFunctionalObjectProperty(:hasWorkstation_Skus)
InverseFunctionalObjectProperty(:hasWorkstation_WorkTable)
InverseFunctionalObjectProperty(:hasWorkTable_SolidObjects)

InverseObjectProperties(:hasWorkstation_ChangingStation
                        :hadByChangingStation_Workstation)
InverseObjectProperties(:hasWorkstation_Robot :hadByRobot_Workstation)
InverseObjectProperties(:hasWorkstation_WorkTable :hadByWorkTable_Workstation)

ObjectPropertyDomain(:hadByChangingStation_Workstation
                     :EndEffectorChangingStation)
ObjectPropertyDomain(:hadByEndEffector_EndEffectorHolder :EndEffector)
ObjectPropertyDomain(:hadByEndEffector_Robot :EndEffector)
ObjectPropertyDomain(:hadByEndEffectorHolder_ChangingStation
                     :EndEffectorHolder)
ObjectPropertyDomain(:hadByKitDesign_Workstation :KitDesign)
ObjectPropertyDomain(:hadByKitInstance_LargeBoxWithKits :KitInstance)
ObjectPropertyDomain(:hadByKitTray_KitInstance :KitTray)
ObjectPropertyDomain(:hadByKitTray_LargeBoxWithEmptyKitTrays :KitTray)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithEmptyKitTrays
                     :LargeContainer)
ObjectPropertyDomain(:hadByLargeContainer_LargeBoxWithKits :LargeContainer)
ObjectPropertyDomain(:hadByPart_KitInstance :Part)
ObjectPropertyDomain(:hadByPart_PartsTrayWithParts :Part)
ObjectPropertyDomain(:hadByPartRefAndPose_KitDesign :PartRefAndPose)
ObjectPropertyDomain(:hadByPartsTray_PartsTrayWithParts :PartsTray)
ObjectPropertyDomain(:hadByRobot_Workstation :Robot)
ObjectPropertyDomain(:hadBySku_Workstation :StockKeepingUnit)
ObjectPropertyDomain(:hadBySolidObject_WorkTable :SolidObject)
ObjectPropertyDomain(:hadByWorkTable_Workstation :WorkTable)


ObjectPropertyDomain(:hasBoxVolume_MaximumPoint :BoxVolume)
ObjectPropertyDomain(:hasBoxVolume_MinimumPoint :BoxVolume)
ObjectPropertyDomain(:hasChangingStation_EndEffectorHolders
                     :EndEffectorChangingStation)
ObjectPropertyDomain(:hasEndEffectorHolder_EndEffector :EndEffectorHolder)
ObjectPropertyDomain(:hasKitDesign_PartRefAndPoses :KitDesign)
ObjectPropertyDomain(:hasKitInstance_Parts :KitInstance)
ObjectPropertyDomain(:hasKitInstance_Tray :KitInstance)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_KitTrays
                     :LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                     :LargeBoxWithEmptyKitTrays)
ObjectPropertyDomain(:hasLargeBoxWithKits_KitInstances :LargeBoxWithKits)
ObjectPropertyDomain(:hasLargeBoxWithKits_LargeContainer :LargeBoxWithKits)
ObjectPropertyDomain(:hasPartRefAndPose_Point :PartRefAndPose)
ObjectPropertyDomain(:hasPartRefAndPose_Rpy :PartRefAndPose)
ObjectPropertyDomain(:hasPartsTrayWithParts_Parts :PartsTrayWithParts)
ObjectPropertyDomain(:hasPartsTrayWithParts_PartsTray :PartsTrayWithParts)
ObjectPropertyDomain(:hasPhysicalLocation_RefObject :PhysicalLocation)
ObjectPropertyDomain(:hasPose_Point :Pose)
ObjectPropertyDomain(:hasPose_Rpy :Pose)
ObjectPropertyDomain(:hasRobot_EndEffector :Robot)
ObjectPropertyDomain(:hasRobot_WorkVolume :Robot)
ObjectPropertyDomain(:hasSku_Shape :StockKeepingUnit)
ObjectPropertyDomain(:hasSolidObject_PhysicalLocation :SolidObject)
ObjectPropertyDomain(:hasWorkstation_ChangingStation :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_KitDesigns :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_OtherObstacles :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_Robot :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_Skus :KittingWorkstation)
ObjectPropertyDomain(:hasWorkstation_WorkTable :KittingWorkstation)
ObjectPropertyDomain(:hasWorkTable_SolidObjects :WorkTable)

ObjectPropertyRange(:hadByChangingStation_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadByEndEffector_EndEffectorHolder :EndEffectorHolder)
ObjectPropertyRange(:hadByEndEffector_Robot :Robot)
ObjectPropertyRange(:hadByEndEffectorHolder_ChangingStation
                    :EndEffectorChangingStation)
ObjectPropertyRange(:hadByKitDesign_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadByKitInstance_LargeBoxWithKits :LargeBoxWithKits)
ObjectPropertyRange(:hadByKitTray_KitInstance :KitInstance)
ObjectPropertyRange(:hadByKitTray_LargeBoxWithEmptyKitTrays
                    :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithEmptyKitTrays
                    :LargeBoxWithEmptyKitTrays)
ObjectPropertyRange(:hadByLargeContainer_LargeBoxWithKits :LargeBoxWithKits)
ObjectPropertyRange(:hadByPart_KitInstance :KitInstance)
ObjectPropertyRange(:hadByPart_PartsTrayWithParts :PartsTrayWithParts)
ObjectPropertyRange(:hadByPartRefAndPose_KitDesign :KitDesign)
ObjectPropertyRange(:hadByPartsTray_PartsTrayWithParts :PartsTrayWithParts)
ObjectPropertyRange(:hadByRobot_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadBySku_Workstation :KittingWorkstation)
ObjectPropertyRange(:hadBySolidObject_WorkTable :WorkTable)
ObjectPropertyRange(:hadByWorkTable_Workstation :KittingWorkstation)

ObjectPropertyRange(:hasBoxVolume_MaximumPoint :Point)
ObjectPropertyRange(:hasBoxVolume_MinimumPoint :Point)
ObjectPropertyRange(:hasChangingStation_EndEffectorHolders :EndEffectorHolder)
ObjectPropertyRange(:hasEndEffectorHolder_EndEffector :EndEffector)
ObjectPropertyRange(:hasKitDesign_PartRefAndPoses :PartRefAndPose)
ObjectPropertyRange(:hasKitInstance_Parts :Part)
ObjectPropertyRange(:hasKitInstance_Tray :KitTray)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_KitTrays :KitTray)
ObjectPropertyRange(:hasLargeBoxWithEmptyKitTrays_LargeContainer
                    :LargeContainer)
ObjectPropertyRange(:hasLargeBoxWithKits_KitInstances :KitInstance)
ObjectPropertyRange(:hasLargeBoxWithKits_LargeContainer :LargeContainer)
ObjectPropertyRange(:hasPartRefAndPose_Point :Point)
ObjectPropertyRange(:hasPartRefAndPose_Rpy :RollPitchYaw)
ObjectPropertyRange(:hasPartsTrayWithParts_Parts :Part)
ObjectPropertyRange(:hasPartsTrayWithParts_PartsTray :PartsTray)
ObjectPropertyRange(:hasPhysicalLocation_RefObject :SolidObject)
ObjectPropertyRange(:hasPose_Point :Point)
ObjectPropertyRange(:hasPose_Rpy :RollPitchYaw)
ObjectPropertyRange(:hasRobot_EndEffector :EndEffector)
ObjectPropertyRange(:hasRobot_WorkVolume :BoxVolume)
ObjectPropertyRange(:hasSolidObject_PhysicalLocation :PhysicalLocation)
ObjectPropertyRange(:hasSku_Shape :ShapeDesign)
ObjectPropertyRange(:hasWorkstation_ChangingStation
                    :EndEffectorChangingStation)
ObjectPropertyRange(:hasWorkstation_KitDesigns :KitDesign)
ObjectPropertyRange(:hasWorkstation_OtherObstacles :BoxVolume)
ObjectPropertyRange(:hasWorkstation_Robot :Robot)
ObjectPropertyRange(:hasWorkstation_Skus :StockKeepingUnit)
ObjectPropertyRange(:hasWorkstation_WorkTable :WorkTable)
ObjectPropertyRange(:hasWorkTable_SolidObjects :SolidObject)

// The following SubClassOf statements are not essential because the
// DisjointUnion statements imply them. However, if they are omitted,
// the Protege asserted class hierarchy does not come out right in either
// the Classes view or the OWLViz view. The inferred hierarchy is
// correct if the SubClassOf statements are omitted, however.

SubClassOf(:BoxyObject :SolidObject)
SubClassOf(:BoxVolume :DataThing)
SubClassOf(:EndEffector :SolidObject)
SubClassOf(:EndEffectorChangingStation :SolidObject)
SubClassOf(:EndEffectorHolder :SolidObject)
SubClassOf(:GripperEffector :EndEffector)
SubClassOf(:KitDesign :DataThing)
SubClassOf(:KitInstance :SolidObject)
SubClassOf(:KittingWorkstation :SolidObject)
SubClassOf(:KitTray :BoxyObject)
SubClassOf(:LargeContainer :BoxyObject)
SubClassOf(:LargeBoxWithEmptyKitTrays :SolidObject)
SubClassOf(:LargeBoxWithKits :SolidObject)
SubClassOf(:Part :SolidObject)
SubClassOf(:PartRefAndPose :DataThing)
SubClassOf(:PartsBin :BoxyObject)
SubClassOf(:PartsTray :BoxyObject)
SubClassOf(:PartsTrayWithParts :SolidObject)
SubClassOf(:PhysicalLocation :DataThing)
SubClassOf(:Point :DataThing)
SubClassOf(:Pose :PhysicalLocation)
SubClassOf(:RelativeLocation :PhysicalLocation)
SubClassOf(:RelativeLocationIn :RelativeLocation)
SubClassOf(:RelativeLocationOn :RelativeLocation)
SubClassOf(:Robot :SolidObject)
SubClassOf(:RollPitchYaw :DataThing)
SubClassOf(:ShapeDesign :DataThing)
SubClassOf(:StockKeepingUnit :DataThing)
SubClassOf(:VacuumEffector :EndEffector)
SubClassOf(:VacuumEffectorMultiCup :VacuumEffector)
SubClassOf(:VacuumEffectorSingleCup :VacuumEffector)
SubClassOf(:Vector :DataThing)
SubClassOf(:WorkTable :BoxyObject)

)
