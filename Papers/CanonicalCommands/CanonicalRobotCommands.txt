
Canonical Robot Commands
Draft May 24, 2012
T. Kramer


I. Language Name

Call the language "canonical robot command" language.


II. Purpose

The purpose of the canonical robot command language is to assist in 
executing robot plans by providing generic commands that implement the
functionality of typical industrial robots without being specific either
to the language of the plan that is being executed or to the language
used by a robot controller that executes robot command language commands.

The canonical robot command language must have commands equivalent to
robot commands written in PDDL plans using the suite of PDDL actions
being used in IPMAS.

III. System Assumptions

There will be at least the following three components in a system that
deals with canonical robot commands.

1. A plan interpreter that reads an entire PDDL file with IPMAS actions
and can interpret each action into one or more canonical robot commands.

2. A robot controller that can execute canonical robot commands.

3. A database that maintains the state of the environment in which the
robot controller is working.

The plan interpreter is subordinate to the robot controller in the
sense that it does only what the robot controller tells it to do.

Each PDDL plan is expected to contain symbolic poses (location and
orientation) corresponding to poses in 3D space. The 3D space pose
corresponding to each symbolic pose is available from the database.

Either the plan interpreter or the robot controller may read from the
database.  Only the robot controller may write to the database.


IV. Canonical Robot Command View of a Robot

A robot has one arm and can position and orient the end of the arm
anywhere in some work volume within some tolerance. At each point in
the work volume, the range of orientations that can be attained may be
limited.

The speed and acceleration of the end of the arm may be controlled.

A robot can attach one end effector at a time to the end of the arm
from an end effector changing station and can detach the end effector
at the changing station. The changing station itself is passive.

All end effectors available to the robot are stored in the end effector
changing station.

Initially, all end effectors will be assumed to be grippers.

All grippers have two states, open and closed. A gripper can hold an
object in the closed state and cannot hold an object in the open
state. [Additional states may be added later, such as open a certain
distance or closed with a certain force.]

Opening or closing any gripper mounted at the end of a robot arm is
exercised by giving a command to the robot.

The robot cannot simultaneously move and open or close the gripper.

There is always a controlled point. When no end effector is on the arm,
the controlled point is at the end of the arm. When an end effector
is mounted on the end of the arm, the controlled point is the tool
centre point.

The robot can move the controlled point smoothly through a series of
poses from a start pose at which it is not moving to an end pose at
which it is not moving, provided that all poses are given before
motion starts. The acceleration and steady state speed of the
controlled point may be specified. The robot will do its best to
maintain the requested steady state speed but may reduce (but not
increase) speed or acceleration as necessary to allow for the dynamics
of arm motion.

A tolerance for the intermediate points of a smooth motion may be set.
The controlled point must pass the intermediate points within the
given tolerance (without coming back to a point after missing it by
more than the tolerance).

The robot cannot be commanded by canonical robot commands in terms of
its joint angles (or distances).

The coordinate system for poses used in the canonical robot commands is
the workstation coordinate system.


V. General Description of the Canonical Robot Command Language

The canonical robot command language includes commands for the robot
controller. In normal system operation, these commands will be
generated by the plan interpreter as it works its way through a plan.

The robot controller may put canonical robot commands on a queue and
execute them (in order) when it wishes. The plan interpreter must
execute each command it is given immediately.

If the robot controller is unable to execute a particular instance of a
canonical robot command, subsequent behavior is up to the robot
controller. The safest course of action to to abort execution of the
plan.

The pose at the end of a command is called the current pose.

While a plan is being executed, the robot should not move except as
directed by a canonical robot command.

Status of command execution is not returned by the robot controller to
the plan interpreter (or any other command generator).

The syntax of commands is given here using C++ syntax. The command
name is given followed by the command arguments (if any) in parentheses.


VI. Commands From the Plan Interpreter to the Robot Controller

CloseGripper ()
Close the gripper

Dwell (double time)
Stay motionless for the given amount of time in seconds.

EndCanon (int reason) 
Do whatever is necessary to stop executing canonical robot
commands. No specific action is required. The robot controller should
not execute any canonical robot command except InitCanon after
executing EndCanon and should signal an error if it is given one.
This command will normally be given when execution of a plan is complete.
It may also be given if the plan interpreter detects an error in the
plan or is unable to proceed for any other reason. A value of 0 for
reason indicates that execution of a plan has completed successfully.
A positive value of reason indicates not.

InitCanon ()
Do whatever is necessary to get ready to move. Length and angle units
are set to the default units. This command will normally be given when
the plan interpreter opens a plan to be executed.

Message (string message)
Display the given message on the operator console.

MoveSmoothlyTo (Pose ** poses, int numPoses)
Move the controlled point along a smooth trajectory passing near all but
the last of the given poses, and stop at the last of the given poses.
The numPoses gives the number of poses.

MoveStraightTo (Pose * pose)
Move the controlled point in a straight line from the current pose to
the given pose, and stop there.

MoveTo (Pose * pose)
Move the controlled point along any convenient trajectory from the
current pose to the given pose, and stop there.

OpenGripper ()
Open the gripper.

SetAbsoluteAcceleration (acceleration)
Set the acceleration for the controlled point to the given value in
length units per second per second.

SetAbsoluteSpeed
Set the speed for the controlled point to the given value in length units
per second.

SetAngleUnits  (string UnitName)
Set angle units to the unit named by the UnitName.
The unit name must be one of "degree" or "radian". All commands that
use angle units (for orientation or orientation tolerance) are
in terms of those angle units. Existing values for orientation are
converted automatically to the equivalent value in new angle units.
The default angle unit is "degree".

SetEndAngleTolerance (double tolerance)
Set the tolerance for the orientation of the end of the arm (whenever there
is no gripper there) or of the gripper (whenever a gripper is on the end of
the arm) to the given value in current angle units.

SetEndPointTolerance (double tolerance)
Set the tolerance for the orientation of the end of the arm (whenever there
is no gripper there) or of the tool centre point (whenever a gripper is on
the end of the arm) to the given value in current length units.

SetIntermediatePointTolerance (double tolerance)
Set the tolerance for smooth motion near intermediate points to the given
value in current length units.

SetLengthUnits (string UnitName)
Set length units to the unit named by the UnitName.
The unit name must be one of "inch", "mm" or "meter". All commands that
use length units (for location, tolerance, speed, and acceleration) are
in terms of those length units. Existing values for speed, position,
acceleration, etc. are converted automatically to the equivalent value
in new length units. The default length unit is millimeters, "mm".

SetRelativeAcceleration (double percent)
Set the acceleration for the controlled point to the given percentage of
the robot's maximum acceleration.

SetRelativeSpeed (double percent)
Set the speed for the controlled point to the given percentage of the
robot's maximum speed.


VII. Commands to the plan interpreter

These commands are not part of the canonical robot commands but are
suggested for use in the IPMAS system as function calls to be made by
the robot controller. The syntax here is also C++ syntax. 

int InterpOpenPlan (string fileName, string planType)
PlanType will be required to be "PDDL" in the first version of the 
interpreter. The return value will be 0 if the plan is opened
successfully and positive if there is an error. 

int InterpClosePlan ()
The currently open plan will be closed. The return value will be 0 if the
plan is closed successfully and positive if there is an error. An error
value will be returned if no plan is open.

int InterpInit()
The interpreter gets ready to run.

int InterpExit()
The interpreter stops running.

int InterpExecute ()
The interpreter interprets the next step of the plan and makes zero to
many calls to canonical robot commands. A positive value is returned if there
are no more steps in the plan or if there is an error in interpreting the
next step. Otherwise, zero is returned.
