PDDL is an attempt to standardize planning domain and problem description languages. A state-variable representation (SVR)~\cite{NAU.2004} is used to define the planning domain and problem that will be translated into PDDL format. In a SVR, each state is represented by a tuple of values of $n$ state variables $\lbrace x_1,\dots,x_n\rbrace$, and each action is represented by a partial function that maps this tuple into some other tuple of values of the $n$ state variables.
%\subsection{Planning Domain for Kitting}

\subsection{Constant Symbols for the Kitting Domain}
In the SVR, constant symbols are partitioned into disjoint classes corresponding to the objects of the domain. For the kitting domain, these classes are derived from the concepts represented in the ontology (see Section~\ref{sect:OWL_Layer}). The finite set of all constant symbols in the kitting domain is partitioned into the following sets of constant symbols:
\begin{small}
\begin{itemize}
\item A set of $\mathrm{Robots\ \lbrace r_1, r_2,\dots \rbrace}$: A $\mathrm{Robot}$ in the kitting workstation is a robotic arm that can move objects in order to build $\mathrm{KitInstances}$.

\item A set of $\mathrm{KitTrays\ \lbrace kt_1, kt_2,\dots \rbrace}$: A $\mathrm{KitTray}$ is a tray with which a $\mathrm{KitInstance}$ may be built. A $\mathrm{KitTray}$ can hold parts in known positions.
    
\item A set of $\mathrm{KitInstances\ \lbrace kins_1, kins_2,\dots \rbrace}$: A $\mathrm{KitInstance}$ is built when $\mathrm{Parts}$ are placed in a $\mathrm{KitTray}$. A $\mathrm{KitInstance}$ consists of a $\mathrm{KitTray}$ and, possibly, some $\mathrm{Parts}$. A $\mathrm{KitInstance}$ is empty when it does not contain any $\mathrm{Part}$ and finished when it contains all the $\mathrm{Parts}$ that constitute a kit.

\item A set of $\mathrm{PartTrays\ \lbrace pt_1, pt_2,\dots \rbrace}$: $\mathrm{Parts}$ arrive at the workstation in $\mathrm{PartTrays}$. Each part is at a known position in the $\mathrm{PartTray}$. Each $\mathrm{PartTray}$ contains one type of $\mathrm{Part}$.

\item A set of $\mathrm{Parts\ \lbrace p_1, p_2,\dots \rbrace}$: $\mathrm{Parts}$ are delivered to the workstation in $\mathrm{PartTrays}$ and are placed in $\mathrm{KitTrays}$ to make $\mathrm{KitInstances}$.
    
\item A set of $\mathrm{EndEffectors\ \lbrace eeff_1, eeff_2,\dots \rbrace}$: $\mathrm{EndEffectors}$ are used in a kitting workstation to manipulate $\mathrm{Parts}$, $\mathrm{PartTrays}$, $\mathrm{KitTrays}$, and $\mathrm{KitInstances}$.

\item A set of $\mathrm{EndEffectorHolders\ \lbrace eeffholder_1, eeffholder_2,\dots \rbrace}$: An $\mathrm{EndEffectorHolder}$ holds one type of $\mathrm{EndEffector}$.

\item A symbol $\mathrm{EndEffectorChangingStation}$ -- $\mathrm{chstation}$: An $\mathrm{EndEffectorChangingStation}$ is made up of $\mathrm{EndEffectorHolders}$.

\item A set of $\mathrm{LargeBoxWithKits\ \lbrace lbwk_1, lbwk_2,\dots \rbrace}$: A $\mathrm{LargeBoxWithKits}$ contains only finished $\mathrm{KitInstances}$.

\item A set of $\mathrm{LargeBoxWithEmptyKitTrays\ \lbrace lbwekt_1, lbwekt_2,\dots \rbrace}$: A $\mathrm{LargeBoxWithEmptyKitTrays}$ is a box that contains only empty $\mathrm{KitTrays}$.

\item A symbol $\mathrm{WorkTable}$ -- $\mathrm{wtable}$: A $\mathrm{WorkTable}$ is an area in the kitting workstation where $\mathrm{KitTrays}$ are placed to build $\mathrm{KitInstances}$.
\end{itemize}
\end {small}
\subsection{State Variable Symbols for the Kitting Domain}
{\it the next sentence is confusing...}

State variable symbols are functions from the set of states and zero or more sets of constant variables into a set of constant variables~\cite{NAU.2004}. Using state variable symbols reduces the possibility of inconsistent states and generates a smaller state space. The following state variable symbols are used in the kitting domain:

\begin{small}
\begin{itemize}
\item \emph{geffloc}: $\mathrm{EndEffectors}\times S\rightarrow\mathrm{Robots}$ $\cup$ $\mathrm{EndEffectorHolders}$: designates the location of an $\mathrm{EndEffector}$ in the workstation. The $\mathrm{EndEffector}$ can be placed in a $\mathrm{EndEffectorHolder}$ or attached to the $\mathrm{Robots}$.

\item \emph{rgrip}: $\mathrm{Robots}\times S\rightarrow\mathrm{EndEffectors}$ $\cup$ $\lbrace nil\rbrace$: designates the $\mathrm{EndEffector}$ that is attached to a $\mathrm{Robots}$ or $nil$ if no $\mathrm{EndEffector}$ is attached.

\item \emph{topworktable}: $\mathrm{WorkTable}\times S\rightarrow\mathrm{KitInstancess}$ $\cup$ $\lbrace nil\rbrace$: designates the object placed on the $\mathrm{WorkTable}$, it can be either a $\mathrm{KitInstnce}$ or nothing ($nil$).

\item \emph{kinsloc}: $\mathrm{KitInstances}\times S\rightarrow\mathrm{LargeBoxWithKits}$ $\cup$ $\mathrm{WorkTable}$ $\cup$ $\mathrm{Robots}$: designates the different possible locations of a $\mathrm{KitInstance}$ in the workstation. The $\mathrm{KitInstance}$ can be in a $\mathrm{LargeBoxWithKits}$, on the $\mathrm{WorkTable}$, or being held by the $\mathrm{Robot}$.
    
\item \emph{ktloc}: $\mathrm{KitTrays}\times S\rightarrow\mathrm{LargeBoxWithEmptyKitTrays}$ $\cup$ $\mathrm{Robots}$: designates the different possible locations of a $\mathrm{KitTray}$ in the workstation. The $\mathrm{KitTray}$ can either be in a $\mathrm{LargeBoxWithEmptyKitTrays}$ or being held by the $\mathrm{Robot}$.

\item \emph{ploc}: $\mathrm{Parts}\times S\rightarrow\mathrm{PartTrays}$ $\cup$ $\mathrm{KitInstances}$ $\cup$ $\mathrm{Robots}$: designates the different possible locations of a $\mathrm{Part}$ in the workstation. The $\mathrm{Part}$ can be in a $\mathrm{PartTray}$, in a $\mathrm{KitInstance}$, or being held by the $\mathrm{Robot}$.

\item \emph{rhold}: $\mathrm{Robots}\times S\rightarrow\mathrm{KitTrays}$ $\cup$ $\mathrm{KitInstances}$ $\cup$ $\mathrm{Parts}$ $\cup \lbrace nil\rbrace$: designates the object being held by the $\mathrm{Robots}$. It can be a $\mathrm{KitTray}$, a $\mathrm{KitInstance}$, $\mathrm{Part}$, or nothing ($nil$). It is assumed that the robot is already equipped with the appropriate $\mathrm{EndEffector}$.

\item \emph{islbwkfull}: $\mathrm{LargeBoxWithKits}\times S\rightarrow \lbrace 0\rbrace \cup \lbrace 1\rbrace$: designates if a $\mathrm{LargeBoxWithKits}$ is full (1) or not (0).

\item \emph{isblbwektempty}: $\mathrm{LargeBoxWithEmptyKitTrays}\times S\rightarrow \lbrace 0\rbrace \cup \lbrace 1\rbrace$: designates if a $\mathrm{LargeBoxWithEmptyKitTrays}$ is empty (1) or not (0).

\item \emph{isparttrayempty}: $\mathrm{PartTrays}\times S\rightarrow \lbrace 0\rbrace \cup \lbrace 1\rbrace$: designates if a $\mathrm{PartTray}$ is empty (1) or not (0).

\item \emph{eefftype}: $\mathrm{EndEffectors}\times S \rightarrow\mathrm{KitTrays}$ $\cup$ $\mathrm{Parts}$: designates the type of object the $\mathrm{EndEffector}$ can hold. For the kitting domain used in this paper, an $\mathrm{EndEffector}$ can hold two types of object: $\mathrm{KitTrays}$ and $\mathrm{Parts}$.
\end{itemize}
\end{small}

%\subsection{Planning Problem for Kitting}

\subsection{Planning Operators for the Kitting Domain}
A planning operator~\cite{NAU.2004} is a triple \textit{o=(name(o), precond(o), effects(o))}
where:
\begin{itemize}
\item name(o) is a syntactic expression of the form $n(u_1,\dots,u_k)$, where $n$ is a symbol
called an operator symbol, $u_1,\dots,u_k$ are all of the object variable symbols that
appear anywhere in \textit{o}, and $n$ is unique (i.e., no two operators can have the
same operator symbol).
\item precond(o) is a set of expressions on state variables and relations.
\item effects(o) is a set of assignments of values to state variables of the form
$x(t_1,\dots,t_k)\leftarrow t_{k+1}$, where each $t_i$ is a term in the appropriate range.
\end{itemize}

The kitting domain is constituted of the eight following operators:
\begin{small}
\begin{enumerate}
\item \textsl{take-kt} ($\mathrm{r}$, $\mathrm{kt}$, $\mathrm{lbwekt}$, $\mathrm{eeff}$)
\begin{itemize}
\item ;;The robot $\mathrm{r}$ is equipped with the end effector $\mathrm{eeff}$ to pick up the kit tray $\mathrm{kt}$ from the large box with empty kit trays $\mathrm{lbwekt}$.
\item precond:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)=lbwekt}$
\item[]\emph{rhold}$\mathrm{(r)=nil}$
\item[]\emph{rgrip}$\mathrm{(r)=eeff}$
\item[]\emph{isblbwektempty}$\mathrm{(kt)=0}$
\item[]\emph{geffloc}$\mathrm{(eeff)=r}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)\leftarrow r}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow kt}$
\end{itemize}
\end{itemize}

\item \textsl{put-kt} ($\mathrm{r}$, $\mathrm{kt}$, $\mathrm{wtable}$)
\begin{itemize}
\item ;;The robot $\mathrm{r}$ puts down the kit tray $\mathrm{kt}$ on the work table $\mathrm{wtable}$.
\item precond:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)=r}$
\item[]\emph{rhold}$\mathrm{(r)=kt}$
\item[]\emph{topworktable}$\mathrm{(wtable)=nil}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)\leftarrow wtable}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow nil}$
\item[]\emph{topworktable}$\mathrm{(r)\leftarrow kt}$
\end{itemize}
\end{itemize}

\item \textsl{take-kins} ($\mathrm{r}$, $\mathrm{kins}$, $\mathrm{wtable}$, $\mathrm{eeff}$)
\begin{itemize}
\item ;;The robot $\mathrm{r}$ picks up the kit instance $\mathrm{kins}$ from the work table $\mathrm{wtable}$.
\item precond:
\begin{itemize}
\item[]\emph{kinsloc}$\mathrm{(kins)=wtable}$
\item[]\emph{rhold}$\mathrm{(r)=nil}$
\item[]\emph{topworktable}$\mathrm{(wtable)=kins}$
\item[]\emph{rgrip}$\mathrm{(r)=eeff}$
\item[]\emph{eeffloc}$\mathrm{(eeff)=r}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{kinsloc}$\mathrm{(kins)\leftarrow nil}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow kins}$
\item[]\emph{topworktable}$\mathrm{(r)\leftarrow nil}$
\end{itemize}
\end{itemize}

\item \textsl{put-kins} ($\mathrm{r}$, $\mathrm{kins}$, $\mathrm{lbwk}$)
\begin{itemize}
\item ;;The robot $\mathrm{r}$ puts down the kit instance $\mathrm{kins}$ in the large box with kits $\mathrm{lbwk}$.
\item precond:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kins}$
\item[]\emph{rhold}$\mathrm{(r)=kins}$
\item[]\emph{islbwkfull}$\mathrm{(lbwk)=0}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kins)\leftarrow lbwk}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow nil}$
\end{itemize}
\end{itemize}

\item \textsl{take-p} ($\mathrm{r}$, $\mathrm{p}$, $\mathrm{pt}$, $\mathrm{eeff}$)
\begin{itemize}
\item ;;Robot $\mathrm{r}$ uses end effector $\mathrm{eeff}$ to pick up part $\mathrm{p}$ from part tray $\mathrm{pt}$.
\item precond:
\begin{itemize}
\item[]\emph{ploc}$\mathrm{(p)=pt}$
\item[]\emph{rhold}$\mathrm{(r)=nil}$
\item[]\emph{rgrip}$\mathrm{(r)=eeff}$
\item[]\emph{isparttrayempty}$\mathrm{(pt)=0}$
\item[]\emph{eeffloc}$\mathrm{(eeff)=r}$

\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{ploc}$\mathrm{(p)=r}$
\item[]\emph{rhold}$\mathrm{(r)=p}$
\end{itemize}
\end{itemize}

\item \textsl{put-p} ($\mathrm{r}$, $\mathrm{p}$, $\mathrm{kins}$)
\begin{itemize}
\item ;;Robot $\mathrm{r}$ puts down part $\mathrm{p}$ in kit instance $\mathrm{kins}$.
\item precond:
\begin{itemize}
\item[]\emph{ploc}$\mathrm{(p)=r}$
\item[]\emph{rhold}$\mathrm{(r)=p}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{ploc}$\mathrm{(p)=kins}$
\item[]\emph{rhold}$\mathrm{(r)=nil}$
\end{itemize}
\end{itemize}

\item \textsl{attach-eeff} ($\mathrm{r}$, $\mathrm{eeff}$, $\mathrm{eeffholder}$)
\begin{itemize}
\item ;;Robot $\mathrm{r}$ attaches end effector $\mathrm{eeff}$ from end effector holder $\mathrm{eeffholder}$.
\item precond:
\begin{itemize}
\item[]\emph{eeffloc}$\mathrm{(eeff)=eeffholder}$
\item[]\emph{rgrip}$\mathrm{(r)=nil}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{eeffloc}$\mathrm{(eeff)=r}$
\item[]\emph{rgrip}$\mathrm{(r)=eeff}$
\end{itemize}
\end{itemize}

\item \textsl{remove-eeff} ($\mathrm{r}$, $\mathrm{eeff}$, $\mathrm{eeffholder}$)
\begin{itemize}
\item ;;Robot $\mathrm{r}$ removes gripper effector $\mathrm{eeff}$ and put it in end effector holder $\mathrm{eeffholder}$.
\item precond:
\begin{itemize}
\item[]\emph{eeffloc}$\mathrm{(eeff)=r}$
\item[]\emph{rgrip}$\mathrm{(r)=eeff}$
\end{itemize}
\item effects:
\begin{itemize}
\item[]\emph{eeffloc}$\mathrm{(eeff)=eeffholder}$
\item[]\emph{rgrip}$\mathrm{(r)=nil}$
\end{itemize}
\end{itemize}
\end{enumerate}
\end{small}


\begin{comment}
\begin{tabular}{p{3.5cm}p{3.5cm}}
\begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)\leftarrow nil}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow kt}$
\item[]\emph{topworktable}$\mathrm{(r)\leftarrow nil}$
\end{itemize} & \begin{itemize}
\item[]\emph{ktloc}$\mathrm{(kt)\leftarrow nil}$
\item[]\emph{rhold}$\mathrm{(r)\leftarrow kt}$
\item[]\emph{topworktable}$\mathrm{(r)\leftarrow nil}$
\end{itemize}
\end{tabular}

\begin{table}[ht]
\centering
\begin{tabular}{|c|p{6cm}|} \hline
\multirow{4}{*}{\begin{sideways}{\small \textsl{take-kt-bekt}}\end{sideways}} & \rule[-1ex]{0pt}{3.5ex} {\small $\mathrm{r}$, $\mathrm{kt}$, $\mathrm{boxekt}$, $\mathrm{geff}$}  \T\\ \cline{2-2}
&\rule[-1ex]{0pt}{3.5ex}{\small The robot $\mathrm{r}$ is equipped with the gripper effector $\mathrm{geff}$ to pick up the kit tray $\mathrm{kt}$ from the box of empty kit trays $\mathrm{boxekt}$.}\T \\ \cline{2-2}
& {\small \emph{ktloc}($\mathrm{kt}$)$\mathrm{= boxekt}$, \emph{rhold}($\mathrm{r}$)$\mathrm{= nil}$, \emph{rgrip}($\mathrm{r}$)$\mathrm{= geff}$, \emph{isboxektempty}($\mathrm{kt}$)$=0$} \\
& Max-Min \\ \hline
\end{tabular}
\end{table}


The operators on the kitting domain are defined as follows:

\begin{itemize}
\item \textbf{take\_kt\_bekt} (\emph{r}, \emph{kt}, \emph{boxekt})
\begin{itemize}
\item ;;The robot \emph{r} takes the kit tray \emph{kt} from the box of empty kit trays \emph{boxekt}.
\item \textit{precond}: \textit{ktloc}(\ekt)=\boxekt, \textit{rhold}(\robot)=\nil
\item \textit{effects}: \textit{ektloc}(ekt)=\robot, \textit{rhold}(\robot)=\ekt
\end{itemize}

\item \textit{putEkt} (\robot, \ekt, \wtable)
\begin{itemize}
\item ;;The robot \robot puts the empty kit tray \ekt on the work table \wtable.
\item \textit{precond}: \textit{ektloc}(\ekt)=\robot, \textit{rhold}(\robot)=\ekt
\item \textit{effects}: \textit{ektloc}(\ekt)=\wtable, \textit{rhold}(\robot)=\nil
\end{itemize}

\item \textit{takeFkt} (\robot, \fkt, \wtable)
\begin{itemize}
\item ;;The robot \robot takes the full kit tray \fkt from the work table \wtable.
\item \textit{precond}: \textit{fktloc}(\fkt)=\wtable, \textit{rhold}(\robot)=\nil
\item \textit{effects}: \textit{fktloc}(\fkt)=\robot, \textit{rhold}(\robot)=\fkt
\end{itemize}

\item \textit{putFkt} (\robot, \fkt, \boxekt)
\begin{itemize}
\item ;;The robot \robot puts the full kit tray \fkt in the box of full kit trays \boxfkt.
\item \textit{precond}: \textit{ektloc}(\fkt)=\robot, \textit{rhold}(\robot)=\fkt
\item \textit{effects}: \textit{ektloc}(\fkt)=\boxfkt, \textit{rhold}(\robot)=\nil
\end{itemize}

\item \textit{takeP} (\robot, \parts, \partsup)
\begin{itemize}
\item ;;The robot \robot takes the part \parts from the part supply tray \partsup.
\item \textit{precond}: \textit{ploc}(\parts)=\partsup, \textit{rhold}(\robot)=\nil
\item \textit{effects}: \textit{ploc}(\parts)=\robot, \textit{rhold}(\robot)=\parts
\end{itemize}

\item \textit{putP} (\robot, \parts, \kt)
\begin{itemize}
\item ;;The robot \robot puts the part \parts in the kit tray \kt.
\item \textit{precond}: \textit{ploc}(\parts)=\robot, \textit{rhold}(\robot)=\parts
\item \textit{effects}: \textit{ploc}(\parts)=\kt, \textit{rhold}(\robot)=\nil
\end{itemize}

\item \textit{aboveP} (\parts, {\constant{pos1}}, {\constant{pos2}})
\begin{itemize}
\item ;;The robot r stations over the part \parts at the position pos2. The previous position of the robot is pos1.
\item \textit{precond}: \textit{rpos}(\robot)={\constant{pos1}}
\item \textit{effects}: \textit{rpos}(\robot)={\constant{pos2}}
\end{itemize}

\item \textit{aboveKit} (\kt, {\constant{pos1}}, {\constant{pos2}})
\begin{itemize}
\item ;;The robot \robot stations over the kit tray \kt at the position pos2. The previous position of the robot is pos1.
\item \textit{precond}: \textit{rpos}(\robot)={\constant{pos1}}
\item \textit{effects}: \textit{rpos}(\robot)={\constant{pos2}}
\end{itemize}

\item \textit{aboveBekt} (\boxekt, {\constant{pos1}}, {\constant{pos2}})
\begin{itemize}
\item ;;The robot \robot stations over the box of empty kit trays at the position pos2. The previous position of the robot is pos1.
\item \textit{precond}: \textit{rpos}(\robot)={\constant{pos1}}
\item \textit{effects}: \textit{rpos}(\robot)={\constant{pos2}}
\end{itemize}

\item \textit{aboveBfkt} (\boxfkt, {\constant{pos1}}, {\constant{pos2}})
\begin{itemize}
\item ;;The robot \robot stations over the box of full kit trays at the position {\constant{pos2}}. The previous position of the robot is {\constant{pos1}}, the final position is {\constant{pos2}}.
\item \textit{precond}: \textit{rpos}(\robot)={\constant{pos1}}
\item \textit{effects}: \textit{rpos}(\robot)={\constant{pos2}}
\end{itemize}

\item \textit{attach} (\robot, \grip, \chstation)
\begin{itemize}
\item ;;The robot \robot attaches the gripper \grip.
\item \textit{precond}: \textit{gloc}(\grip)=chstation,
\item \textit{effects}: \textit{gloc}(\grip)=\robot
\end{itemize}

\item \textit{remove} (\robot, \grip, chstation)
\begin{itemize}
\item ;;The robot \robot removes the gripper \grip.
\item \textit{precond}: \textit{gloc}(\grip)=\robot,
\item \textit{effects}: \textit{gloc}(\grip)=\chstation
\end{itemize}
\end{itemize}
\end{comment}

%\subsubsection{Definition of the Initial State}

%\subsubsection{Definition of the Goal State}
