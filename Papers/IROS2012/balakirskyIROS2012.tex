\input{header}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

The IEEE RAS Ontologies for Robotics and Automation Working Group is dedicated to developing a methodology for knowledge representation and reasoning in robotics and automation. As part of this working group, the Industrial Robots sub-group is tasked with studying industrial applications of the ontology. One of the first areas of interest for this subgroup is the area of kit building or kitting. This is a process that brings parts that will be used in assembly operations together in a kit and then moves the kit to the assembly area where the parts are used in the final assembly. This paper examines the knowledge representations that have been developed and implemented for the kitting problem.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}
Kitting is the process in which several different, but related items are placed into a container and supplied together as a single unit.
Kitting itself may be viewed as a specialization of the general bin-picking problem.
In industrial assembly of manufactured products, kitting is often performed prior to final assembly. Manufacturers utilize kitting
due to its ability to provide cost savings \cite{Carlsson_2008} including saving manufacturing or assembly space \cite{Medbo2003}, reducing assembly workers walking and searching times \cite{Schwind1992}, and increasing line flexibility \cite{Bozer1992} and balance \cite{Jiao2000}.

Several different techniques are used to create kits. A kitting operation where a kit box is stationary until filled at a single
kitting workstation is referred to as {\it batch kitting}. In {\it zone kitting}, the kit moves while being filled and will pass through one or
more zones before it is completed. This paper focuses on batch kitting processes.

In batch kitting, the kit's component parts may be staged in containers positioned in the workstation or may arrive on a conveyor.
Component parts may be fixtured, for example placed in compartments on trays, or may be in random orientations, for example
placed in a large bin. In addition to the kit's component parts, the workstation usually contains a storage area for empty kit boxes as
well as completed kits.

Kitting has not yet been automated in many industries where automation may be feasible. Consequently, the cost of building kits is higher than it could be. We are addressing this problem by building models of the knowledge that will be required to operate an automated kitting workstation in an agile manufacturing environment. This workstation must be able to cope with
variations in kit contents, kit layout, and component supply. Our models
include representations for non-executable information about the workstation such as information about parts and kit designs, models of executable information such as actions, preconditions, and effects, and models of the  process plan
necessary for kit construction. A discussion of the functional requirements for the process plan may be found in \cite{Balakirsky2012_1}.
For our automated kitting workstation, we assume that a robot performs a series of pick-and-place operations
in order to construct the kit. These operations include:
\begin{enumerate}
\item Pick empty kit and place on work table.
\item Pick multiple component parts and place in kit.
\item Pick completed kit and place in full kit storage area.
\end{enumerate}
Each of these actions may be a compound action that includes other actions such as end-of-arm tool changes, path planning,
and obstacle avoidance.

It should be noted that multiple kits may be built simultaneously. Finished kits are moved to the assembly floor where components
are picked
from the kit for use in the assembly procedure. The kits are normally designed to facilitate component picking in the correct
sequence for assembly. Component orientation may be constrained by the kit design in order to ease the pick-to-assembly process.
%The final kit does not normally contain small fasteners which are usually stored in the assembly area.
Empty kits are returned to the kit building area for reuse.

Although the knowledge requirements described in the previous paragraph have been identified for the kitting domain, they are clearly applicable to many types of industrial robot applications. As such, we expect that these knowledge requirements will serve as the basis for the industrial robot ontology being developed in the IEEE  RAS Ontologies for Robotics and Automation Working Group \cite{Madhavan2011} (henceforth referred to as the IEEE WG). Throughout the process of developing the kitting ontology, the group will constantly look at the applicability of the requirements outside of kitting and move the pertinent knowledge ``up'' the ontology (whether in the portion that models the kitting sub-domain, the industrial robot domain, or the upper ontology), as appropriate.

In keeping with the standards philosophy of the IEEE WG, we require the models being developed to be as widely applicable as possible. Therefore, we have
created a layered model abstraction where users may adopt as many of the layers of the abstraction as make sense for their
specific application.  The architecture shown in Figure \ref{fig:ProcessDataFlow}, though developed for the kitting ontology, can be equally applicable to the implementation of any type of formal manufacturing knowledge representation. Said in a different way, the implementor can plug in a knowledge representation for a different domain and the architecture would still be valid. In a similar manner, different planning language abstractions could be utilized in the planning language layer of the
abstraction and different planning/execution systems could be utilized in the robot language layer of the abstraction.

Specifics on the architecture may be found in Section \ref{sect:Architecture}. An example of the
knowledge representations and the flow from one to the next is presented in Section \ref{sect:Example}. Finally,
conclusions and future work may be found in Section \ref{sect:Conclusions}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[htb]
\includegraphics[width=8cm]{images/ProcessDataFlowV2.jpg}
\caption{Kitting data flow abstraction.}
\vspace{-.15in}
\label{fig:ProcessDataFlow}
\end{figure}

\section{Architecture Description}
\label{sect:Architecture}
The main focus of this work is on the development of knowledge models that allow a kitting workstation to construct kits
in an agile manufacturing environment. However, in order to validate these knowledge models, we felt that it was
important to be able to utilize the models to construct kit building plans, and then to execute these plans in dynamic
virtual and real environments. Due to the advent of open source robotic operating systems such as ROS\footnote{Certain commercial/open source software and tools are identified in this paper in order to explain our research. Such identification does not imply
recommendation or endorsement by the authors, nor does it imply that the software tools identified are necessarily the best available for the purpose.}\cite{ROS}
 and simulation
packages such as USARSim \cite{Balakirsky2007}, we do not need to design these systems ourselves. However, our architecture must
be designed to represent the required knowledge base in several different abstractions that are likely to be
required by these systems as the knowledge flows from domain and process specification, to plan generation, to plan execution.
As shown in Figure \ref{fig:ProcessDataFlow}, the abstraction is decomposed into four
distinct layers of {\it Domain Specific Information}, {\it Ontology}, {\it Planning Language}, and {\it Robot Language} that correspond to these
knowledge requirements. In this paper, we will discuss the layers of the Domain Specific Information through Planning Language. Implementors of the abstraction are free to connect to the knowledge interface at the layer that makes sense for
their particular application. For our simulated kitting workstation, we intend to fully design the Domain Specific Information and the Ontology and
then utilize open
source tools that will automatically generate the remaining layers and provide a workstation simulation.

\subsection{Domain Specific Information}
\label{subsect:DomainSpecific}
The foundation for the knowledge representation is domain specific information that is produced by an expert in the particular field of study. This includes
information on items ranging from what actions and attributes are relevant, to what the necessary conditions are for an action to occur and what the
likely results of the action are. We have chosen to encode this basic information in a formalism know as a state variable representation (SVR) \cite{NAU.2004}.
This information will then flow up the abstraction and be transformed into the ontology, planning language, and robot language.
In a SVR, each state is represented by a tuple of values of $n$ state variables $\lbrace x_1,\dots,x_n\rbrace$, and each action is represented by a partial function that maps this tuple into some other tuple of values of the $n$ state variables.

To build the SVR, the group has taken a very systematic approach of identifying and modeling the concepts. Because the industrial robot field is so broad, the group decided to limit its efforts to a single type of operation, namely kitting. A scenario was developed that described, in detail, the types of operations that would be performed in kitting, the sequencing of steps, the parts and machines that were needed, constraints on the process such as pre- and post-conditions, etc. For this scenario, a set of concepts were extracted and defined. These concepts served as the initial requirements for the kitting SVR. The concepts were then modeling in our SVR, building off of the definitions and relationships that were identified in the scenario.

A SVR relies on the elements of constant variable symbols, object variable symbols, state variable symbols, rigid relations, and planning operators. These are defined for the kitting domain in the rest of this section.

\subsubsection{Constant Variable Symbols}
For the kitting domain, there is a finite set of constant variable symbols that must be represented. In the SVR, constant variable symbols are partitioned into disjoint classes corresponding to the objects of the domain. The finite set of all constant variable symbols in the kitting domain is partitioned into the following sets:
%\begin{small}
\begin{itemize}
\item A set of \class{Part}: \class{Parts} are the basic items that will be used to fill a kit.

\item A set of \class{PartsTray}: \class{Parts} arrive at the workstation in \class{PartsTrays}. Each \class{Part} is at a known position in the \class{PartsTray}. Each \class{PartsTray} contains one type of \class{Part}.

\item A set of \class{KitTray}:  A \class{KitTray} can hold \class{Parts} in known positions.

\item A set of \class{Kit}: A \class{Kit} consists of a \class{KitTray} and, possibly, some \class{Parts}. A \class{Kit} is empty when it does not contain any \class{Part} and finished when it contains all the \class{Parts} that constitute a kit.

\item A symbol \class{WorkTable}: A \class{WorkTable} is an area in the kitting workstation where \class{KitTrays} are placed to build \class{Kits}.

\item A set of \class{LargeBoxWithKits}: A \class{LargeBoxWithKits} contains only finished \class{Kits}.

\item A set of \class{LargeBoxWithEmptyKitTrays}: A \class{LargeBoxWithEmptyKitTrays} is a box that contains only empty \class{KitTrays}.

\item A set of \class{Robot}: A \class{Robot} in the kitting workstation is a robotic arm that can move objects in order to build \class{Kits}.

\item A set of \class{VacuumEffectorSingleCup}: \class{VacuumEffectorSingleCups} are used in a kitting workstation to manipulate \class{Parts}, \class{PartsTrays}, \class{KitTrays}, and \class{Kits}. A \class{VacuumEffectorSingleCup} is attached to a \class{Robot}.

\item A set of \class{EndEffectorHolder}: An \class{EndEffectorHolder} is a storage unit that holds one type of \class{EndEffector}.

%\item A symbol \class{EndEffectorChangingStation}: An \class{EndEffectorChangingStation} is made up of \class{EndEffectorHolders}.
\end{itemize}
%\end {small}

\subsubsection{Object Variable Symbols}
Object variable symbols are typed variables which range over a class or the union of classes of constant variable symbols. Examples of object variable symbols are \const{r} $\in$ \class{Robot}, \const{kt} $\in$ \class{KitTray}, etc.

\subsubsection{State Variable Symbols}
\label{subsubsect:State_Variable_Symbols}
A state variable $\mathrm{x}$ symbol is defined as follows:
$\mathrm{x: A_1\times \dots\times A_i\times S\rightarrow B_1\cup\dots\cup B_j}$ ($i, j\geq 1$) is a function from the set of states ($\mathrm{S}$) and at least one set of constant variable symbols $\mathrm{A_1\times \dots\times A_i}$ into a set of constant variable symbols $\mathrm{B_1\cup\dots\cup B_j}$.

The use of state variable symbols reduces the possibility of inconsistent states and generates a smaller state space. The following state variable symbols are used in the kitting domain:

\begin{itemize}
\item \stvar{effloc}: \class{VacuumEffectorSingleCup}$\mathrm{\times S\rightarrow}$\class{Robot} $\cup$ \class{EndEffectorHolder} designates the location of a \class{VacuumEffectorSingleCup} in the workstation: Attached to a \class{Robot} or placed in an \class{EndEffectorHolder}.

\item \stvar{reff}: \class{Robot}$\mathrm{\times S\rightarrow}$\class{VacuumEffectorSingleCup} $\cup$ \{\textit{nil}\} designates the \class{VacuumEffectorSingleCup} attached to the \class{Robot} if there is one attached, otherwise \textit{nil}.

\item \stvar{onworktable}: \class{WorkTable}$\mathrm{\times S\rightarrow}$\class{Kit} $\cup$ \class{KitTray} $\cup$ \{\textit{nil}\} designates the object placed on the \class{WorkTable}: A \class{Kit}, a \class{KitTray}, or nothing.

\item \stvar{kitloc}: \class{Kit}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithKits} $\cup$ \class{WorkTable} $\cup$ \class{Robot} designates the different possible locations of a \class{Kit} in the workstation: in a \class{LargeBoxWithKits}, on the \class{WorkTable}, or being held by a \class{Robot}.

\item \stvar{kittrayloc}: \class{KitTray}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithEmptyKitTrays} $\cup$ \class{Robot} $\cup$ \class{WorkTable} designates the different possible locations of a \class{KitTray} in the workstation: In a \class{LargeBoxWithEmptyKitTrays}, being held by on a \class{Robot}, or on a \class{WorkTable}.

\item \stvar{partloc}: \class{Part}$\mathrm{\times S\rightarrow}$\class{PartsTray} $\cup$ \class{Kit} $\cup$ \class{Robot} designates the different possible locations of a \class{Part} in the workstation: In a \class{PartsTray}, in a \class{Kit}, or being held by a \class{Robot}.

\item \stvar{rhold}: \class{Robot}$\mathrm{\times S\rightarrow}$\class{KitTray} $\cup$ \class{Kit} $\cup$ \class{Part} $\cup$ \{\textit{nil}\}: designates the object being held by a \class{Robot}: A \class{KitTray}, a \class{Kit}, a \class{Part}, or nothing.

\item \stvar{islbwkfull}: \class{LargeBoxWithKits}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\} designates if a \class{LargeBoxWithKits} is full or not.

\item \stvar{islbwektempty}: \class{LargeBoxWithEmptyKitTrays}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\} designates if a \class{LargeBoxWithEmptyKitTrays} is empty (1) or not (0).

\item \stvar{ispartstrayempty}: \class{PartsTray}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\} designates if a \class{PartsTray} is empty or not.

\item \stvar{efftype}: \class{VacuumEffectorSingleCup}$\mathrm{\times S \rightarrow}$\class{KitTray} $\cup$ \class{Kit} $\cup$ \class{Part} designates the type of object a \class{VacuumEffectorSingleCup} can hold: A \class{KitTray}, a \class{Kit}, or a \class{Part}.

\item \stvar{eeffhtype}: \class{EndEffectorHolder}$\mathrm{\times S \rightarrow}$ \{\textit{nil}\} $\cup$ \class{VacuumEffectorSingleCup} designates the object an \class{EndEffectorHolder} is holding.
\end{itemize}


\subsubsection{Sets of Literals}
\label{subsubsect:Rigid_Relation}
%\stvar{efftype} and \stvar{effhold-eff} are rigid relations since their values do not vary from one state to another. In each state, a given \class{EndEffector} will always hold the same type of object and a given \class{EndEffectorHolder} will always hold the same \class{EndEffectors}.
In order to generate PDDL files, each state variable symbol must be converted into a set of literals (i.e., atoms and negation of atoms). For instance, in order to use the state variable symbol \stvar{partloc}: \class{Part}$\mathrm{\times S\rightarrow}$\class{PartsTray} $\cup$ \class{Kit} $\cup$ \class{Robot} in PDDL, this state variable symbol is converted into the set of literals $\{$\stvar{partloc}(\const{p},\const{pt}), \stvar{partloc}(\const{p},\const{k}), \stvar{partloc}(\const{p},\const{r})$\}$, where \const{p} $\in$ \class{Part}, \const{k} $\in$ \class{Kit}, \const{k} $\in$ \class{KitTray}, and \const{r} $\in$ \class{Robot}. The representation of the location of a \class{Part} in PDDL is performed by using the correct literal within this set of literals.


\subsubsection{Planning Operators}
\label{subsect:Planning_Operators}
\begin{comment}
A planning operator~\cite{NAU.2004} is a triple \textit{o=(name(o), precond(o), effects(o))}
where:
\begin{itemize}
\item name(o) is a syntactic expression of the form $n(u_1,\dots,u_k)$, where $n$ is a symbol
called an operator symbol, $u_1,\dots,u_k$ are all of the object variable symbols that
appear anywhere in \textit{o}, and $n$ is unique (i.e., no two operators can have the
same operator symbol).
\item precond(o) is a set of expressions on state variables and relations.
\item effects(o) is a set of assignments of values to state variables of the form
$x(t_1,\dots,t_k)\leftarrow t_{k+1}$, where each $t_i$ is a term in the appropriate range.
\end{itemize}
\end{comment}
A planning operator is used to describe one of the procedures that can be used to move from one state to another. A planning operator~\cite{NAU.2004} is a triple \textit{o=(name(o), precond(o), effects(o))}
whose elements are as follows:
\begin{itemize}
\item \textit{name(o)}, the name of the operator, is a syntactic expression of the form $n(x_1,\dots,x_k)$, where $n$ is a symbol called an operator symbol, $x_1,\dots,x_k$ are all of the object variable symbols that
appear anywhere in \textit{o}, and $n$ is unique (i.e., no two operators can have the
same operator symbol).
\item \textit{precond(o)} and \textit{effects(o)}, the preconditions and effects of \textit{o}, respectively, are sets of literals.
\end{itemize}


The kitting domain presented in this paper is composed of eight operators: \op{take-kit-tray}, \op{put-kit-tray}, \op{take-kit}, \op{put-kit}, \op{take-part}, \op{put-part}, \op{attach-eff}, and \op{remove-eff}. Due to space restriction, this section describes only one of these operators as follows:

\begin{itemize}
\item \op{take-kit-tray}(\const{r},\const{kt},\const{lbwekt},\const{eff},\const{wtable}): The \class{Robot} \const{r} equipped with the \class{VacuumEffectorSingleCup} \const{eff} picks up the \class{KitTray} \const{kt} from the \class{LargeBoxWithEmptyKitTrays} \const{lbwekt}. TheWorkTable \const{wtable} must be \textit{a priori} empty.
\begin{center}
\begin{tabular}{ l|l }
  \textit{precond} & \textit{effects} \\
  \hline
  \stvar{rhold-empty}(\const{r}),&$\neg$\stvar{rhold-empty}(\const{r}),\\
  \stvar{lbwekt-not-empty}(\const{lbwekt}),&\stvar{kittrayloc}(\const{kt},\const{r}),\\
  \stvar{r-with-eff}(\const{r},\const{eff}),&\stvar{rhold}(\const{r},\const{kt}), \\
  \stvar{kittrayloc}(\const{kt},\const{lbwekt}),&$\neg$\stvar{kittrayloc}(\const{kt},\const{lbwekt}) \\
  \stvar{effloc}(\const{eff},\const{r}),&\\
  \stvar{worktable-empty}(\const{wtable}),& \\
  \stvar{efftype}(\const{eff},\const{kt})&
\end{tabular}
\end{center}

Note that an action \textit{a} can be obtained by substituting the object variable symbols that
appear anywhere in the operator with constant variable symbols.
%\item \op{put-kit-tray}(\const{r},\const{kt},\const{wtable}): The \class{Robot} \const{r} puts down the \class{KitTray} \const{kt} on the \class{WorkTable} \const{wtable}.
%
%\item \op{take-kit}(\const{r},\const{kit},\const{wtable},\const{eff}): The \class{Robot} \const{r} equipped with the \class{VacuumEffectorSingleCup} \const{eff} picks up the \class{Kit} \const{kit} from the \class{WorkTable} \const{wtable}.
%
%\item \op{put-kit}(\const{r},\const{kit},\const{lbwk}): The \class{Robot} \const{r} puts down the \class{Kit} \const{kit} in the \class{LargeBoxWithKits} \const{lbwk}.
%
%\item \op{take-part}(\const{r},\const{part},\const{pt},\const{eff},\const{wtable},\const{kit}): The \class{Robot} \const{r} uses the \class{VacuumEffectorSingleCup} \const{eff} to pick up the \class{Part} \const{part} from the \class{PartTray} \const{pt}.
%
%\item \op{put-part}(\const{r},\const{part},\const{kit},\const{wtable}): The \class{Robot} \const{r} puts down the \class{Part} \const{part} in the \class{Kit} \const{kit}.
%
%\item \op{attach-eff}(\const{r},\const{eff},\const{eeffh}): The \class{Robot} \const{r} attaches the \class{VacuumEffectorSingleCup} \const{eff} which is situated in the \class{EndEffectorHolder} \const{eeffh}.
%
%\item \op{remove-eff}(\const{r},\const{eff},\const{eeffh}): The \class{Robot} \const{r} removes the \class{VacuumEffectorSingleCup} \const{eff} and puts it in the \class{EndEffectorHolder} \const{eeffh}.
\end{itemize}

%An action \textit{a} can be obtained by substituting the object variable symbols that
%appear anywhere in the operator with constant variable symbols. For instance, the operator \op{take-kit}(\const{r},\const{kit},\const{wtable},\const{eff}) in the kitting domain can be translated into the action \op{take-kit}(\const{r_1},\const{kit_1},\const{wtable_1},\const{eff_2}) where \const{r_1}, \const{part_1}, \const{wtable_1}, and \const{eff_2} are constant variable symbols in the classes \class{Robots}, \class{Parts}, \class{WorkTable}, and \class{VacuumEffectorSingleCup}, respectively.
\subsection{Ontology}
\label{subsect:Ontology}
%``Ontology deals with questions concerning what entities exist or can be said to exist, and how such entities can be grouped, related within a hierarchy, and subdivided according to %similarities and differences'' \cite{ontologyDef}.

Knowledge models may take many forms ranging from informal natural language, to XML schemas, to ontologies.
For the development of the  knowledge representation, the industrial robots sub-group has decided to use the  Web Ontology Language (OWL) \cite{OWL} as the knowledge representation language. OWL is a family of knowledge representation languages for authoring ontologies and is endorsed by the World Wide Web Consortium (W3C).
%It is characterized by formal semantics and Resource Description Framework/eXtensible Markup Language (RDF/XML)-based serialization for the Semantic Web.
 OWL was chosen by the group because of its popularity among the ontology development community, its endorsement by the W3C, as well as the number of tools and reasoning engines that are available. OWL was also selected as the representation language that will be used in the overall IEEE WG efforts.

In addition to OWL, the industrial robots subgroup will also be using OWL-S \cite{Martin2012} to represent the processes and actions that the robot will perform. OWL-S is an ontology built on top of OWL by the DARPA Agent Markup Language (DAML) program \cite{damlWeb}
for describing Semantic Web Services. Many of the constructs that are used to describe services are equally applicable to encoding our SVR. For example, concepts such as preconditions, results, inputs, outputs, effects, and participants are generic enough to be applied to just about any type of process specification.

Since this work is being directed at the IEEE RAS Ontologies for Robotics and Automation Working Group, it is appropriate that our  domain specific knowledge  be
encoded in an OWL ontology at the first domain independent  layer of our abstraction. The knowledge contained in this layer is derived from our SVR and may also contain
information that has been collected over other domains.

As more detailed scenarios are determined and a richer set of concepts are uncovered, the ontology will be partitioned based upon the generality of the concept, with the most generally applicable concepts being ``higher'' in the ontology so they are available to other domains and the more detailed concepts being ``lower'' because they will likely be very specific to the kitting area. An example of a general concept may be a \class{Robot} while a specific concept may be a \class{KitTray}.

As shown in Figure \ref{fig:ProcessDataFlow}, the information in our ontology is divided into three sets of files and consists of a representation of the process specification,
the kitting ontology, and the instance file. The process specification file is based off of the planning operators from the SVR and contains descriptions of
the individual actions and sequences necessary to construct a kit, e.g. gripping a component from a tray. The kitting ontology file is based off of the constant variable symbols and
state variable symbols and contains the concepts related to the specific items
that compose the kitting domain, e.g. the hierarchy of what it means to be a \const{part\_a}. That a \const{part\_a} is a type of \class{Part}, and that
all \class{Parts} contain properties such as the part's weight, dimensions, and grip points. The instance file is based off of the SVR object variable symbols and
contains specific information on {\it this} particular kitting problem and configuration, e.g. \class{KitTray} \const{kit\_tray\_1} contains four \class{Parts} of type \const{part\_a}.

While this file set provides a complete description of the problem domain and environment, most planning systems cannot directly ingest information from an ontology.
Therefore, the next layer of the data abstraction known as the Planning Language layer was created.

\subsection{Planning Language}
The Planning Domain Definition Language (PDDL) \cite{PDDL} is an attempt by the domain independent planning community to formulate a standard language for planning. A community
of planning researchers has been producing planning systems that comply with this formalism since the first International Planning Competition held in 1998. This competition series
continues today, with the seventh competition being held in 2011. PDDL is constantly adding extensions to the base language in order to represent more expressive problem domains. Our
work is based on PDDL Version  3.0.

By placing our knowledge in a PDDL representation, we enable the use of an entire family of open source planning systems.
As shown in Figure \ref{fig:ProcessDataFlow}, each PDDL file-set consists of two files that specify the domain and the problem. The PDDL domain file is composed of four sections that include
requirements, types and constants, predicates, and actions. This file may be automatically generated from a combination of information that is contained in the OWL-S process specification file and the OWL Kitting Ontology file. This auto-generation uses a modified version of the algorithms from Klusch and Gerber \cite{Klusch2005} that directly generate PDDL syntax.

The requirements section specifies which extensions this problem domain relies on. The planning system can examine this statement to determine if it is capable of solving problems in this domain. In PDDL, all variables that are used in the domain must be typed. Types are defined in the $\mathrm{types}$ section. It is also possible to have constants that specify that all problems will share this single value. For example, in the simplest kitting workstation we will have a single \class{Robot} \const{robot\_1}.
Predicates specify relationships between instances. For example, an instance of a \class{KitTray}, \const{kit\_tray\_1}, can have a physical location and contains instances of \class{Parts}, \const{part\_a\_1}, \const{part\_a\_2}, \const{part\_b\_1}, and \const{part\_c\_1}. The final section of the PDDL domain file is concerned with actions. An action statement specifies a way that a planner affects the state of the world. The statement includes parameters, preconditions, and effects. The preconditions dictate items that must be initially true for the action to be legal. The effect equation dictates the changes in the world that will occur due to the execution of the action.

The second file of the PDDL file-set is a  problem file. The problem file specifies information about the specific instance of the given problem. This file contains the initial conditions and definition of the world (in the init section) and the goal state that the world must be brought to (in the goal section). A specific example of the ontology to planning language conversion is provided in Section \ref{sect:Example}.

%\subsection{Robot Plan Conformance}
%\label{subsect:RobotPlan}
%Any one of a number of open source planning systems may now be run on the Planning Language layer's knowledge representation. The output of these planners will be
%a PDDL action sequence file that is based on our original vocabulary. This file
%contains a time sequenced series of actions that must be carried out in order to create a transition from our initial system state to the goal system state. It should be noted that
%the sequence of knowledge transformations that takes place from the ontology through the planning language, to the action sequence is independent of the kitting domain or any specific %hardware configurations and is able to solve problems for many types of industrial robot applications.
%The top layer of our abstraction ties the specific commands to the kitting workstation and is dependent on the workstation's resident hardware.  In order to maintain as
%much hardware independence as possible, we have chosen to use the ROS environment for communicating with our simulation. Therefore, the PDDL commands will
%be translated into appropriate commands that will be sent into various ROS processes. These ROS stacks will then control all aspects of our USARSim virtual workstation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example of Operation}
\label{sect:Example}
\input{ExampleOfOperation}


\addtolength{\textheight}{-15cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CONCLUSIONS AND FUTURE WORK}
\label{sect:Conclusions}
In this paper we have presented the first knowledge model that is part of the IEEE RAS Ontologies for Robotics and Automation, Industrial Robotics subgroup on kitting.
This abstraction begins with data that has been created by an expert user as a state variable representation and encoded into an OWL ontology. The knowledge
is then automatically transitioned into a Planning Domain Definition Language that may be used by a class of planners to find a solution that will provide for actions that will
transition the system for its initial state to a prescribed goal state.

This workstation is still very much a work in progress. The IEEE working group has an active mailing list and meets in person at both the IEEE ICRA and IROS conferences.
At present, we are working on connecting the planned action sequence through the ROS control stack to our USARSim virtual world. As the knowledge representation is
exercised, it is expected that shortcomings and missing data will be detected. Our representation will be updated as necessary to cope with these developments. In addition,
the representation will be expanded to include metrics that allow us to represent not only the the information necessary for the construction of a kit, but also for the representation
of the quality of the finished kit and the kit building process.

\bibliographystyle{plain}
\bibliography{./iros}
\end{document}
