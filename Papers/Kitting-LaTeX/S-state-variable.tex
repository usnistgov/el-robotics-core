\section{State-Variable Representation}
In a SVR, each state is represented by a tuple of values of $n$ state variables $\lbrace x_1,\dots,x_n\rbrace$, and each action is represented by a partial function that maps this tuple into some other tuple of values of the $n$ state variables.\\ \\
To build the SVR, the group has taken a very systematic approach of identifying and modeling the concepts. Because the industrial robot field is so broad, the group decided to limit its efforts to a single type of operation, namely kitting. A scenario was developed that described, in detail, the types of operations that would be performed in kitting, the sequencing of steps, the parts and machines that were needed, constraints on the process such as pre- and post-conditions, etc. For this scenario, a set of concepts were extracted and defined. These concepts served as the initial requirements for the kitting SVR. The concepts were then modeling in our SVR, building off of the definitions and relationships that were identified in the scenario. A SVR relies on the elements of constant variable symbols, object variable symbols, state variable symbols, rigid relations, and planning operators. These are defined for the kitting domain in the rest of this section.


\subsubsection{Constant Variable Symbols}
For the kitting domain, there is a finite set of constant variable symbols that must be represented. In the SVR, constant variable symbols are partitioned into disjoint classes corresponding to the objects of the domain. The finite set of all constant variable symbols in the kitting domain is partitioned into the following sets:
%\begin{small}
\begin{itemize}
\item A set of \class{Parts} \{\const{part_1},\const{part_2},\ldots\}: \class{Parts} are the basic items that will be used to fill a kit.

\item A set of \class{PartTrays} \{\const{pt_1},\const{pt_2},\ldots\}: \class{Parts} arrive at the workstation in \class{PartTrays}. Each part is at a known position in the \class{PartTray}. Each \class{PartTray} contains one type of \class{Part}.

\item A set of \class{KitTrays} \{\const{kt_1},\const{kt_2},\ldots\}:  A \class{KitTray} can hold \class{Parts} in known positions.

\item A set of \class{KitInstances} \{\const{kins_1},\const{kins_2},\ldots\}: A \class{KitInstance} is built when \class{Parts} are placed in a \class{KitTray}. A \class{KitInstance} consists of a \class{KitTray} and, possibly, some \class{Parts}. A \class{KitInstance} is empty when it does not contain any \class{Part} and finished when it contains all the \class{Parts} that constitute a kit.

\item A symbol \class{WorkTable} -- \const{wtable}: A \class{WorkTable} is an area in the kitting workstation where \class{KitTrays} are placed to build \class{KitInstances}.

\item A set of \class{LargeBoxWithKits} \{\const{lbwk_1},\const{lbwk_2},\ldots\}: A \class{LargeBoxWithKits} contains only finished \class{KitInstances}.

\item A set of \class{LargeBoxWithEmptyKitTrays} \{\const{lbwekt_1}, \const{lbwekt_2},\ldots\}: A \class{LargeBoxWithEmptyKitTrays} is a box that contains only empty \class{KitTrays}.

\item A set of \class{Robots} \{\const{r_1},\const{r_2},\ldots\}: A \class{Robot} in the kitting workstation is a robotic arm that can move objects in order to build \class{KitInstances}.

\item A set of \class{EndEffectors} \{\const{eff_1},\const{eff_2},\ldots\}: \class{EndEffectors} are used in a kitting workstation to manipulate \class{Parts}, \class{PartTrays}, \class{KitTrays}, and \class{KitInstances}. An \class{EndEffector} is attached to a \class{Robot}.

\item A set of \class{EndEffectorHolders}  \{\const{effh_1},\const{effh_2}, \ldots\}: An \class{EndEffectorHolder} is a storage unit that holds one type of \class{EndEffector}.

\item A symbol \class{EndEffectorChangingStation} -- \const{chstation}: An \class{EndEffectorChangingStation} is made up of \class{EndEffectorHolders}.
\end{itemize}
%\end {small}

\subsection{Object Variable Symbols}
Object variable symbols are typed variables which range over a class or the union of classes of constant variable symbols. Examples of object variable symbols are \const{r} $\in$ \class{Robots}, \const{kt} $\in$ \class{KitTrays}, etc.

\subsection{State Variable Symbols}
\label{subsubsect:State_Variable_Symbols}
A state variable symbol is defined as follows:
$\mathrm{x: A_1\times \dots\times A_i\times S\rightarrow B_1\cup\dots\cup B_j}$ ($i, j\geq 1$) is a function from the set of states ($\mathrm{S}$) and at least one set of constant variable symbols $\mathrm{A_1\times \dots\times A_i}$ into a set of constant variable symbols $\mathrm{B_1\cup\dots\cup B_j}$.

The use of state variable symbols reduces the possibility of inconsistent states and generates a smaller state space. The following state variable symbols are used in the kitting domain:

\begin{itemize}
\item \stvar{effloc}: \class{EndEffectors}$\mathrm{\times S\rightarrow}$\class{Robots} $\cup$ \class{EndEffectorHolders}: designates the location of an \class{EndEffector} in the workstation, i.e., in a \class{EndEffectorHolder} or attached to a \class{Robot}.

\item \stvar{reff}: \class{Robots}$\mathrm{\times S\rightarrow}$\class{EndEffectors} $\cup$ \{\textit{nil}\}: designates the \class{EndEffector} attached to a \class{Robot} if there is one attached, otherwise \textit{nil}.

\item \stvar{onworktable}: \class{WorkTable}$\mathrm{\times S\rightarrow}$\class{KitInstances} $\cup$ \class{KitTrays} $\cup$ \{\textit{nil}\}: designates the object placed on the \class{WorkTable}, i.e., a \class{KitInstance}, a \class{KitTray}, or nothing (\textit{nil}).

\item \stvar{kinsloc}: \class{KitInstances}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithKits} $\cup$ \class{WorkTable} $\cup$ \class{Robots}: designates the different possible locations of a \class{KitInstance} in the workstation, i.e., in a \class{LargeBoxWithKits}, on the \class{WorkTable}, or being held by a \class{Robot}.

\item \stvar{ktloc}: \class{KitTrays}$\mathrm{\times S\rightarrow}$\class{LargeBoxWithEmptyKitTrays} $\cup$ \class{Robots} $\cup$ \class{WorkTable}: designates the different possible locations of a \class{KitTray} in the workstation, i.e., in a \class{LargeBoxWithEmptyKitTrays}, on a \class{WorkTable} or being held by a \class{Robot}.

\item \stvar{partloc}: \class{Parts}$\mathrm{\times S\rightarrow}$\class{PartTrays} $\cup$ \class{KitInstances} $\cup$ \class{Robots}: designates the different possible locations of a \class{Part} in the workstation, i.e., in a \class{PartTray}, in a \class{KitInstance}, or being held by a \class{Robot}.

\item \stvar{rhold}: \class{Robots}$\mathrm{\times S\rightarrow}$\class{KitTrays} $\cup$ \class{KitInstances} $\cup$ \class{Parts} $\cup$ \{\textit{nil}\}: designates the object being held by a \class{Robot}, i.e., a \class{KitTray}, a \class{KitInstance}, \class{Part}, or nothing (\textit{nil}). It is assumed that the \class{Robot} is already equipped with the appropriate \class{EndEffector}.

\item \stvar{islbwkfull}: \class{LargeBoxWithKits}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{LargeBoxWithKits} is full (1) or not (0).

\item \stvar{islbwektempty}: \class{LargeBoxWithEmptyKitTrays}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{LargeBoxWithEmptyKitTrays} is empty (1) or not (0).

\item \stvar{isptempty}: \class{PartTrays}$\mathrm{\times S\rightarrow}$ \{0\} $\cup$ \{1\}: designates if a \class{PartTray} is empty (1) or not (0).

\item \stvar{efftype}: \class{EndEffectors}$\mathrm{\times S \rightarrow}$\class{KitTrays} $\cup$ \class{KitInstancess} $\cup$ \class{Parts}: designates the type of object an \class{EndEffector} can hold, i.e., \class{KitTrays}, \class{KitInstances}, or \class{Parts}.

\item \stvar{effhtype}: \class{EndEffectorHolders}$\mathrm{\times S \rightarrow}$\class{EndEffectors}: designates the \class{EndEffector} that an \class{EndEffectorHolder} can hold.
\end{itemize}


\subsection{Rigid Relations}
\label{subsubsect:Rigid_Relation}
\stvar{efftype} and \stvar{effhtype} are rigid relations since their values do not vary from one state to another. In each state, a given \class{EndEffector} will always hold the same type of object and a given \class{EndEffectorHolder} will always hold the same \class{EndEffectors}.

\subsection{Planning Operators and Actions}
\label{subsect:Planning_Operators}

\subsubsection{Planning Operators}
A planning operator is used to describe one of the procedures that can be used to move from one state to another. A planning operator~\cite{NAU.2004} is a triple \textit{o=(name(o), precond(o), effects(o))}
where:
\begin{itemize}
\item name(o) is a syntactic expression of the form $n(u_1,\dots,u_k)$, where $n$ is a symbol
called an operator symbol, $u_1,\dots,u_k$ are all of the object variable symbols that
appear anywhere in \textit{o}, and $n$ is unique (i.e., no two operators can have the
same operator symbol).
\item precond(o) is a set of expressions on state variables and relations.
\item effects(o) is a set of assignments of values to state variables of the form
$x(t_1,\dots,t_k)\leftarrow t_{k+1}$, where each $t_i$ is a term in the appropriate range.
\end{itemize}

Our kitting domain is composed of eight operators which are defined below.


\begin{enumerate}
\item \op{take-kt}(\const{r},\const{kt},\const{lbwekt},\const{eff}): The \class{Robot} \const{r} equipped with the \class{EndEffector} \const{eeff} picks up the \class{KitTray} \const{kt} from the \class{LargeBoxWithEmptyKitTrays} \const{lbwekt}.
    \begin{itemize}
\item precond: \stvar{ktloc}(\const{kt})=\const{lbwekt}, \stvar{rhold}(\const{r})=\textit{nil}, \stvar{reff}(\const{r})=\const{eff}, \stvar{effloc}(\const{eff})=\const{r}, \stvar{islbwektempty}(\const{lbwekt})=0
\item effects: \stvar{ktloc}(\const{kt})$\leftarrow$\const{r}, \stvar{rhold}(\const{r})$\leftarrow$\const{kt}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-kt}(\const{r},\const{kt},\const{wtable}): The \class{Robot} \const{r} puts down the \class{KitTray} \const{kt} on the \class{WorkTable} \const{wtable}.
    \begin{itemize}
        \item precond: \stvar{ktloc}(\const{kt})=\const{r}, \stvar{rhold}(\const{r})=\const{kt}, \stvar{onworktable}(\const{wtable})=\textit{nil}
        \item effects: \stvar{ktloc}(\const{kt})$\leftarrow$\const{wtable}, \stvar{rhold}(\const{r})$\leftarrow$\textit{nil}, \stvar{onworktable}(\const{wtable})$\leftarrow$\const{kt}
    \end{itemize}
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{take-kins}(\const{r},\const{kins},\const{wtable},\const{eff}): The \class{Robot} \const{r} equipped with the \class{EndEffector} \const{eff} picks up the \class{KitInstance} \const{kins} from the \class{WorkTable} \const{wtable}.
    \begin{itemize}
        \item precond: \stvar{kinsloc}(\const{kins})=\const{wtable}, \stvar{rhold}(\const{r})=\textit{nil}, \stvar{onworktable}(\const{wtable})=\const{kins}, \stvar{reff}(\const{r})=\const{eff}
        \item effects: \stvar{kinsloc}(\const{kins})$\leftarrow$\const{r}, \stvar{rhold}(\const{r})$\leftarrow$\const{kins}, \stvar{onworktable}(\const{wtable})$\leftarrow$\textit{nil}
    \end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-kins}(\const{r},\const{kins},\const{lbwk}): The \class{Robot} \const{r} puts down the \class{KitInstance} \const{kins} in the \class{LargeBoxWithKits} \const{lbwk}.
    \begin{itemize}
        \item precond: \stvar{kinsloc}(\const{kins})=\const{r}, \stvar{rhold}(\const{r})=\const{kins}, \stvar{islbwkfull}(\const{lbwk})=0
        \item effects: \stvar{kinsloc}(\const{kins})$\leftarrow$\const{lbwk}, \stvar{rhold}(\const{r})$\leftarrow$\textit{nil}
    \end{itemize}    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{take-p}(\const{r},\const{part},\const{pt},\const{eff}): The \class{Robot} \const{r} uses the \class{EndEffector} \const{eff} to pick up the \class{Part} \const{part} from the \class{PartTray} \const{pt}.
    \begin{itemize}
        \item precond: \stvar{partloc}(\const{part})=\const{pt}, \stvar{rhold}(\const{r})=\textit{nil}, \stvar{reff}(\const{r})=\const{eff}
        \item effects: \stvar{partloc}(\const{part})$\leftarrow$\const{r}, \stvar{rhold}(\const{r})$\leftarrow$\const{part}
    \end{itemize}   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{put-p}(\const{r},\const{part},\const{kins}): The \class{Robot} \const{r} puts down the \class{Part} \const{part} in the \class{KitInstance} \const{kins}.
    \begin{itemize}
        \item precond: \stvar{partloc}(\const{part})=\const{r}, \stvar{rhold}(\const{r})=\const{part}
        \item effects: \stvar{partloc}(\const{part})$\leftarrow$\const{kins}, \stvar{rhold}(\const{r})$\leftarrow$\textit{nil}
    \end{itemize}   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{attach-eff}(\const{r},\const{eff},\const{effh}): The \class{Robot} \const{r} attaches the \class{EndEffector} \const{eff}, situated in the \class{EndEffectorHolder} \const{effh}.
    \begin{itemize}
        \item precond: \stvar{effloc}(\const{eff})=\const{effh}, \stvar{reff}(\const{r})=\textit{nil}
        \item effects: \stvar{effloc}(\const{eff})$\leftarrow$\const{r}, \stvar{reff}(\const{r})$\leftarrow$\const{eff}
    \end{itemize}    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item \op{remove-eff}(\const{r},\const{eff},\const{effh}): The \class{Robot} \const{r} removes the \class{EndEffector} \const{eff} and puts it in the \class{EndEffectorHolder} \const{effh}.
    \begin{itemize}
        \item precond: \stvar{effloc}(\const{eff})=\const{r}, \stvar{reff}(\const{r})=\const{eff}, \stvar{rhold}(\const{r})=\textit{nil}
        \item effects: \stvar{effloc}(\const{eff})$\leftarrow$\const{effh}, \stvar{reff}(\const{r})=\textit{nil}
    \end{itemize}
\end{enumerate}

\subsubsection{Actions}
An action \textit{a} can be obtained by substituting the object variable symbols that
appear anywhere in the operator with constant variable symbols. For instance, the operator \op{take-p}(\const{r},\const{part},\const{pt},\const{eff}) in the kitting domain can be translated into the action \op{take-p}(\const{r_1},\const{part_1},\const{pt_1},\const{eff_2}) where \const{r_1}, \const{part_1}, \const{pt_1}, and \const{eff_2} are constant variable symbols in the classes \class{Robots}, \class{Parts}, \class{PartTrays}, and \class{EndEffectors}, respectively.





