INTRODUCTION

After this introduction is a text version of an example workstation
level process plan for building N kits of a specific design in a
kitting workstation. Text in square brackets in the plan is comments
that would not be in the actual plan.  The numbers on the left of the
plan steps would not be in the actual plan, either.

The plan would be used by a plan executor that receives a command
providing the plan identifier and the parameters of the plan. This
plan has only one parameter, which is the number of kits to be made.

The kit this builds is a tray of KitTrayXType containing 2 PartA,
1 PartB, and 1 PartC.

The fixed equipment in the workstation assumed by this plan includes
a table, a robot, and grippers.

The plan has big boxes for empty kit trays and full kit trays.  The
big boxes themselves are identical. The executor is expected to
determine which is which by interrogating the workstation model to
find out what each contains.

The plan has trays for incoming parts. An alternative would be to have
boxes of trays of incoming parts (same idea as for kit trays).

The plan assumes that, without having to worry about collisions, all
parts in a tray of incoming parts may be picked from above and may be
placed from above in the kit tray. This is likely to be the case if,
for example, all the trays are on top of the work table in the workstation.

The plan assumes that the same PartGripper may be used for all parts but
that a TrayGripper is needed for handling empty and full trays.

The workstation model includes the locations of everything whose
location is needed. The plan executor updates the model as plan steps
are executed on the assumption that the plan steps produce the
intended effects. When a statement moves objects, the plan executor
gives modeling commands as well as motion commands.

Implementing updating the world model when an object consisting of
other objects is created (by an assembly or placement action) or
destroyed (by a disassembly action), however, is not straightforward.
Motion statements may or may not imply that an assembly has been
created or destroyed, so creation and destruction cannot be
implemented as side effects of motion statements. They are implemented
here as CreateInstance and DestroyInstance. In the example, an
instance of kitABC is created when an empty KitTrayX is placed on the
table, and an instance of trayOfPartASku is destroyed when it is found to
be empty.  The descriptions of the commands below give further
details.

The plan includes FactotumReplace, FactotumRemove, and FactotumRefill
commands. The factotum is an external agent that is able to change
things in the workstation. When any of those three commands is executed,
the workstation model is updated by the factotum.

The messaging protocol between the workstation controller and the
two command recipients (robot and factotum) would include a status
response. The plan does not include dealing with status responses.
How to respond is up to the workstation controller.

This example plan was written so as to be a reasonable plan for making
a kit. The information requirements of the plan are intended to
satisfiable from the existing kitting workstation model. The plan model
to which this example plan conforms includes the following features.

1. The sections of a plan are:

    About - information about the plan including the following, and
           possibly other administrative items such as approvals:
       PlanId - an identifier for the plan that is unique in some scope
           (global URI scope is probably appropriate).
       PlanVersion - a version number
       PlanDateAndTime - when this version was finished
       PlanAuthor - the person or system that made the plan
       PlanWorkstation - an identifier for the workstation in which the
         plan can be executed, also unique in some scope.
       Description - A natural language description of the plan.
       TargetSKU - an identifier of the SKU for the kit made by the plan.

    PlanRequirements - a list of required items that are not fixed parts
       of the workstation. Descriptions of items that have a SkuRef
       can be obtained from the workstation's SKU library.

    PlanParameters - Variables used in the plan that are assigned values
         when the command to start executing the plan is given.

    InternalVariables - Variables used in the plan that are assigned
         values while the plan is executing.

    ToDo - The things to do in order to execute the plan.

2. The following statements may be used in the ToDo section of a plan.
   Those that are not used in the example are marked with and asterisk.
   

   Bind - This is followed by (a) the name of an internal variable to 
      which a value should be assigned and (b) three modifiers. The
      value is found by searching the workstation model. The first
      modifier specifies a part of the model to look in. The second
      modifier specifies which instance to pick if there is a choice.
      The third modifier specifies what to do if no value can be found.

   CreateInstance - This is followed by (a) the name of an internal
      variable that will represent the instance (b) a SolidObject that
      is part of the instance, and (c) the name of the property of the
      instance whose value is the object. This creates an instance of
      the appropriate type of SolidObject (the type of the internal
      variable). The Pose of the instance is set (a) to be relative to
      whatever the Pose of the object used to start the instance was
      relative to, (b) so that the object is in the correct place
      in the instance and (c) so that the object is at the same place
      in the workstation as it was before the instance was
      created. The object used to start the instance must have a
      completely specified location in the design of the
      instance. When the instance is created, the Pose of the object
      used to start the instance is changed to be relative to the
      instance. The value of the internal variable is set to point to
      the instance.

   DestroyInstance - This is followed by the name of an internal variable
      whose value is the instance to destroy. An instance to be destroyed
      by this statement may have only one component part. When the
      instance is destroyed, the Pose of the remaining component is
      changed to be relative to whatever the Pose of the instance was
      relative to. The value of the internal variable is set
      to Null.

   DoInAnyOrder - This is followed by a list of statements to be executed
      in any order or even in parallel, if the executor can do parallel
      execution. The executor determines the order of execution at
      execution time.

   DoInGivenOrder - This is followed by a list of statements to be executed
      in the order given. Execution of a statement in the list starts after
      execution of the previous statement is finished.

   *DoInPreconditionOrder - This implements a directed graph type plan.
      The idea is to have the preconditions for executing a statement be
      the execution of other statements (rather than the effects of
      executing other statements). The statement is followed by a list
      of triples of the form (index (doBefores) statement), for example,
      (3 (1 2) RobotPutDown(currentKitTray)). The index is a sequence
      number; in the example, the index is 3, meaning it is the third
      item in the list. The doBefores is a list of integers giving
      the indexes of statements that must be executed before this one;
      in the example, statements 1 and 2 must be executed before
      statement 3. Except for conforming to the doBefores requirements,
      the statements may be executed in any order. If the doBefores
      of item n is (n-1) for every item in the list except the first,
      then this is identical to DoInGivenOrder. If the doBefores of item
      n is empty for every item in the list, then this is identical to
      DoInAnyOrder. This statement is able to express complex conditions
      that would otherwise require (possibly exponentially) many statements.
      Hence, it is an extremely useful statement to have.

   *DoOne - This is followed by a list of alternative statements. The
      executor picks whichever one it prefers. The If-ElseIf-Else
      construct allows alternatives with conditions whereas the DoOne
      has no conditions.

   *Else - This is similar to the C language "else".

   *ElseIf - This is similar to the C language "else if".

   FactotumRefill - This is followed by a variable representing a
      requirement. When the statement is executed, the factotum
      puts an object of the required type in the workstation and
      updates the workstation model.

   FactotumRemove - This is followed by a variable representing the
      object to remove. When the statement is executed, the factotum
      removes the object and updates the workstation model.

   FactotumReplace - This is followed by a variable representing the
      object to replace. When the statement is executed, the factotum
      removes the object, puts another object of the same type in
      the same place, and updates the workstation model. The new object
      should be different from the old one in an appropriate way.

   If - This is followed by a boolean expression and a statement to
      execute if the expression evaluates to true. This is similar to
      to a C language "if". "If" works with "ElseIf" and "Else".

   *LoopInAnyOrderWhile - This is like LoopInGivenOrderWhile except that
      the statements may be executed in any order.
   
   LoopInGivenOrderWhile - This is followed by a boolean expression and
      a list of statements to be executed in the order given. It is similar
      to a C language "while".

   Quit - When the statement is executed, execution stops.

   RobotChangeEndEffector - This is followed by the name of an
      EndEffector to change to. When the statement is executed, if the
      robot is not already holding the named EndEffector, the robot moves
      to the changing station, puts down the EndEffector it has (if
      it has one) and picks up the named EndEffector. If the robot is
      already holding the named EndEffector, no action is taken.

   RobotMoveAbove - This is followed by a Pose. When this statement is
      executed, the controlled point on the robot's end effector
      moves to a point that has the same X and Y values of the location
      of the Pose but has a greater Z value by some amount the
      executor thinks will be sufficient so that the robot will not
      collide with anything near the location point. This statement
      is not particularly well defined and might be modified.

   RobotPickUp - This is followed by a variable whose value is the object to
      pick up. When the statement is executed, the robot moves its gripper
      down into position for grasping the object, the gripper grasps the
      object, and the robot moves up so that the height of the lowest point
      of the object is the same as what the height of the lowest point
      of the gripper was previously.

   RobotPutDown - This is followed by a variable representing the object
      to put down and a variable representing the Pose of the object at
      which the object should be released. When the statement is executed,
      the robot moves the object into the given Pose and releases the
      gripper's grip on the object. Then the robot moves up so that the
      height of lowest point of the gripper is the same as what the height
      of the lowest point of the object was previously.

   Set - This is followed by the name of an internal variable to set
      and an expression. When the Set statement is executed, the
      expression is evaluated, and that value is assigned to the
      variable. This is similar to a C language "=". The expression
      must evaluate to a value that has the same type as the variable.

   SetPose - This is followed by (a) the name of an internal variable
      of type Pose to be set, (b) the object to use as the value of
      hasPhysicalLocation_RefObject in the Pose, and (c) a Pose
      expression.  The Pose expression may be the Pose of another
      object. The value of the variable is set to the Pose of the
      other object relative to the object specified. Since chains
      of locations may be long, implementing this statement will
      not be simple. The statement will fail if there are any
      RelativeLocations in the chain.

   Start - When the statement is executed nothing is required to happen.
      The plan executor might set something internal. The ToDo
      section of a plan must begin with a Start statement.

   Stop - When the statement is executed, plan execution stops. A
      Stop command must appear as the last statement in the ToDo list
      and may appear elsewhere in the plan.

3. Expressions may be used as described above. Boolean expressions are
   used in 5.2.3.1, 5.2.3.2, and 5.2.3.3 in the example. An arithmetic
   expression is used in 5.2.3.22. Pose expressions are used in 5.2.3.5,
   5.2.3.13.1.3, 5.2.3.13.2.3, and elsewhere. The plan model will need
   to have an expression model built in or imported.

4. There are a few key words:
   ANY - Choose from a list any item meeting certain conditions.
   QUIT - If there is an error, execute the Quit statement.
   ROBOT - Use the robot as the reference object
   TABLE - As the value of a location, this means look on the table.
      As the value of a reference object, this means use the table
      as the reference object.
   WORKSTATION - As the value of a location, this means look anywhere
      in the workstation. As the value of a reference object, this
      means use the workstation as the reference object.

5. There are a few functions:

   Contains(Container, ContainedSkuRef, Levels) - Takes three
   arguments: (1) a SolidObject such as a LargeContainer that might
   have something in it, (2) the SKU id of a type of object, (3) the
   number of hierarchical levels of containment to dig through.
   Returns the number of items of the given type in the given
   container through the given number of levels.

   GetTop(ListOfSolidObjects) - Takes an argument that is a list of solid
   objects of the same type (in a stack, perhaps) and returns the one
   on top (the one with the largest location point Z value).

   GetFirst(AnyList) - Takes an argument that is a list and returns
   the first one on the list.

   GetPartPose(aKitTray, SkuRef, index) - Takes three arguments ((1)
   a KitTray, (2) a SKU id, and (3) an index that indicates which instance
   of the item with the given SKU id to look for) and returns
   the pose of that item in the SKU description for the KitTray.
   The model of a StockKeepingUnit is not yet adequate for
   implementing this function since ShapeDesign is a stub.

This example plan does not include any explicit sensory data, and the
initial plan model will not model it. Future versions of the plan
model might model sensory data. Some checking using sensory data might
be performed by the plan executor even if such checking is not in the
plan. For example, if a camera is available on the robot arm, an image
could be taken from time to time and compared with an expected virtual
image that would be generated by a solid modeler from the data in the
workstation model. The workstation controller would decide for itself
when such checking would be done and what to do if actual and virtual
images differ more than is acceptable.

A supply tray is of type PartsTrayWithParts, which has a PartsTray
and set of Parts. The plan is handling the emptying of a part supply
tray in two different ways to show alternatives. When the supply tray
for PartA is empty, (1) a variable is set to the tray in the supply
tray, (2) the supply tray is destroyed (a data change only), (3) the
tray is removed, and (4) a new supply tray is provided. When the
supply tray for PartB or PartC is empty, it is replaced with a new
supply tray.

-----------------------------------------------------

1. About
   1.1 PlanId = "kitABCPlan"
       [This an identifier that is unique in some scope that may be
       used to identify the plan.]
   1.2 PlanVersion = "1.0"
   1.3 PlanDateAndTime = "2012-01-26T08:28:17Z"
       [Some standard date and time representation.
        This one is from XML schema.]
   1.4 PlanAuthor = "Noman"
   1.5 PlanWorkstation = "workstation1"
       [This identifies the KittingWorkstation that can execute the plan.
       It allows retrieval of information about the workstation.]
   1.6 Description = "This builds one to many KitInstances of a
       kit defined by the StockKeepingUnit whose hasSku_Id is kitABC.
       Each kit is built in a KitTray whose hasSku_Id is KitTrayX.
       The finished kit contains two PartA, one PartB, and one PartC."
   1.7 TargetSKU = "kitABC"

2. PlanRequirements
    [This is a list of required items that are not a fixed part of
     the workstation. The information here might be used for setting
     up the workstation. These items must be in the workstation before
     plan execution starts, and the workstation model must model them
     before plan execution starts.]
   2.1 name = "boxWithEmptyTraysRequirement"
       type = "LargeContainer"
       SkuRef = "Box1"
          [This is the SKUID of a LargeContainer box that can hold up
          to 12 empty or full KitTrays of the correct type (KitTrayX for
          empty trays). A description of the box is available from the
          SKU library. The SKU model does not have information about how
          many empty trays any given box actually contains.]
       contentsType = "SkuRef KitTrayX"
       contentsQuantity = "12"
       location = WORKSTATION [anywhere in the workstation.]
   2.2 name = "boxForFullTraysRequirement"
       type = "LargeContainer"
       SkuRef = "Box1"
          [This is the SKU id of a LargeContainer box that can hold up
          to 12 empty or full KitTrays (i.e. KitInstances) of the correct
          type (kitABC for KitInstances). A description of the box is
          available from the SKU library. The SKU model does not have
          information about how many full trays any given box actually
          contains.]
       contentsType = "SkuRef kitABC"
       contentsQuantity = "0"
       location = WORKSTATION [anywhere in the workstation]
   2.3 name = "partASupplyRequirement"
       type = "PartsTrayWithParts"
       (((GetFirst(hasPartsTrayWithParts_Parts)).hasPart_SkuRef) = "PartA")
          [The SKU id of the first Part in the PartsTrayWithParts
           must be PartA.]
       location = TABLE [anywhere on the table in the workstation]
   2.4 name = "partBSupplyRequirement"
       type = "PartsTrayWithParts"
       (((GetFirst(hasPartsTrayWithParts_Parts)).hasPart_SkuRef) = "PartB")
          [The SKU id of the first Part in the PartsTrayWithParts
           must be PartB.]
       location = TABLE [anywhere on the table in the workstation]
   2.5 name = "partCSupplyRequirement"
       type = "PartsTrayWithParts"
       (((GetFirst(hasPartsTrayWithParts_Parts)).hasPart_SkuRef) = "PartC")
          [The SKU id of the first Part in the PartsTrayWithParts
           must be PartC.]
       location = TABLE [anywhere on the table in the workstation]

3. Plan Parameters = [a list of parameters of the plan]
   3.1 name = "NumberOfKitsToMake"
       type = "positiveInteger"
             [another XML schema data type]

4. InternalVariables = [a list of internal variables]
   4.1 name = "BoxWithEmptyTrays"
       type = "LargeContainer"
       requirement = "boxWithEmptyTraysRequirement"
   4.2 name = "BoxForFullTrays"
       type = LargeContainer
       requirement = "boxForFullTraysRequirement"
   4.3 name = "PartASupply"
       type = "PartsTrayWithParts"
       requirement = "partASupplyRequirement"
   4.4 name = "PartBSupply"
       type = "PartsTrayWithParts"
       requirement = "partBSupplyRequirement"
   4.5 name = "PartCSupply"
       type = "PartsTrayWithParts"
       requirement = "partCSupplyRequirement"
   4.6 name = "CurrentKitTray"
       type = "KitTray"
       SkuRef = "KitTrayX"
       initialValue = Null
   4.7 name = "SourcePartA"
       type = "Part"
       SkuRef = "PartA"
       initialValue = Null
   4.8 name = "SourcePartB"
       type = "Part"
       SkuRef = "PartB"
       initialValue = Null
   4.9 name = "SourcePartC"
       type = Part
       SkuRef= "PartC"
       initialValue = Null
   4.10 name = "n"
       type = "integer"
       initialValue = "0"
   4.11 name = "CurrentTrayPose"
       type = "Pose"
       initialValue = Null
   4.12 name = "partSourcePose"
       type = "Pose"
       initialValue = Null
   4.13 name = "PartDestinationPose"
       type = "Pose"
       initialValue = Null
   4.14 name = "TrayDestinationPose"
       type = "Pose"
       initialValue = Null
   4.15 name = "CurrentKitInstance"
       type = "KitInstance"
       SkuRef = "kitABC"
       initialValue = Null
   4.16 name = "PartATray"
       type = PartsTray
       initialValue = Null
   4.17 name = "KitTrayPose"
       type = "Pose"
       initialValue = Pose(Point(10, 10, 30), RollPitchYaw(0, 0, 0), ROBOT)
        [a literal Pose relative to the robot]

5. ToDo [in order]
   5.1 Start()
   5.2 DoInGivenOrder
      5.2.1 DoInAnyOrder
         5.2.1.1 Bind (BoxWithEmptyTrays, WORKSTATION, ANY, QUIT)
           [The plan executor finds a LargeContainer in the workstation
            model that fills the requirements of the BoxWithEmptyTrays
            and sets BoxWithEmptyTrays to it. Any such object will do.
            If no such object is found, QUIT.]
         5.2.1.2 Bind (BoxForFullTrays, WORKSTATION, ANY, QUIT)
         5.2.1.3 Bind (PartASupply, TABLE, ANY, QUIT)
           [The plan executor finds a PartsTrayWithParts on the table in
            the workstation model that fills the requirements of the
            PartASupply and sets PartASupply to it.
            Any such object will do. If no such object is found, QUIT.]
         5.2.1.4 Bind (PartBSupply, TABLE, ANY, QUIT)
         5.2.1.5 Bind (PartCSupply, TABLE, ANY, QUIT)
      5.2.2 Set (n, 0)
      5.2.3 LoopInGivenOrderWhile { n < NumberOfKitsToMake }
         5.2.3.1 If {Robot.hasRobot_EndEffector != "TrayGripper"}
                  RobotChangeEndEffector ("TrayGripper")
         5.2.3.2 If {Contains(BoxWithEmptyTrays, KitTrayX, 1) == 0}
                  FactotumReplace (BoxWithEmptyTrays)
         5.2.3.3 If {Contains(BoxWithEmptyTrays, KitTrayX, 1) == 0}
                  Quit() [replacement should not be empty]
         5.2.3.4 Set (CurrentKitTray, GetTop(BoxWithEmptyTrays.trays))
                  [Sets the CurrentKitTray to the one at the top of the
                   stack of trays in the BoxWithEmptyTrays. The ".trays"
                   syntax here is bogus (since there is no such property
                   of a LargeContainer) and will need changing.]
         5.2.3.5 SetPose (CurrentTrayPose, ROBOT,
                          CurrentKitTray.hasSolidObject_PhysicalLocation)
         5.2.3.6 RobotMoveAbove(CurrentTrayPose)
                  [Positions the TrayGripper above the BoxWithEmptyTrays]
         5.2.3.7 RobotPickUp(CurrentKitTray)
                  [robot moves TrayGripper down into position for grasping
                   the tray, TrayGripper grasps tray, robot moves up so
                   that tray clears top of BoxWithEmptyTrays]
         5.2.3.8 RobotMoveAbove(KitTrayPose)
                  [Positions the CurrentKitTray above the table.
                   KitTrayPose is the pose in robot coordinates at which
                   to place the CurrentKitTray. This is a fixed pose.]
         5.2.3.9 RobotPutDown(CurrentKitTray, KitTrayPose)
                  [Robot puts CurrentKitTray down (on the table) at
                   the KitTrayPose and withdraws to where it was.]
         5.2.3.10 CreateInstance(CurrentKitInstance, CurrentKitTray,
                                 "hasKitInstance_Tray")
         5.2.3.11 Set (CurrentKitInstance.isKitInstance_Finished, false)
         5.2.3.12 RobotChangeEndEffector ("PartGripper")
         5.2.3.13 DoInAnyOrder 
            5.2.3.13.1 DoInGivenOrder
               [the following statements put the first PartA in the kit
                being built]
               5.2.3.13.1.1 If {Contains(PartASupply, PartA, 1) == 0}
                  DoInGivenOrder
                     5.2.3.13.1.1.1 Set (PartATray,
                                    PartASupply.hasPartsTrayWithParts_Tray)
                     5.2.3.13.1.1.2 DestroyInstance(PartASupply)
                     5.2.3.13.1.1.3 FactotumRemove(PartATray)
                     5.2.3.13.1.1.4 FactotumRefill (PartASupply)
                     5.2.3.13.1.1.5 If {Contains(PartASupply, PartA, 1) == 0}
                                      Quit()
               5.2.3.13.1.2 Set (SourcePartA,
                          GetFirst(PartASupply.hasPartsTrayWithParts_Parts))
                  [Sets SourcePartA to the first part found in the PartASupply]
               5.2.3.13.1.3 SetPose (PartSourcePose, ROBOT,
                               SourcePartA.hasSolidObject_PhysicalLocation)
               5.2.3.13.1.4 SetPose (PartDestinationPose, ROBOT,
                                 GetPartPose(CurrentKitTray, PartA, 1))
                  [GetPartPose gets the pose in the design of the
                   CurrentKitTray of the first PartA. The SetPose statement
                   sets the PartDestinationPose relative to the robot.]
               5.2.3.13.1.5 RobotMoveAbove(PartSourcePose)
               5.2.3.13.1.6 RobotPickUp(SourcePartA)
               5.2.3.13.1.7 RobotMoveAbove(PartDestinationPose)
               5.2.3.13.1.8 RobotPutDown(SourcePartA, PartDestinationPose)
            5.2.3.13.2 DoInGivenOrder
               [the following statements put the second PartA in the kit
               being built]
               5.2.3.13.2.1 If {Contains(PartASupply, PartA, 1) == 0}
                  DoInGivenOrder
                     5.2.3.13.2.1.1 Set (PartATray,
                                    PartASupply.hasPartsTrayWithParts_Tray)
                     5.2.3.13.2.1.2 DestroyInstance(PartASupply)
                     5.2.3.13.2.1.3 FactotumRemove(PartATray)
                     5.2.3.13.2.1.4 FactotumRefill (PartASupply)
                     5.2.3.13.2.1.5 If {Contains(PartASupply, PartA, 1) == 0}
                                      Quit()
               5.2.3.13.2.2 Set (SourcePartA,
                          GetFirst(PartASupply.hasPartsTrayWithParts_Parts))
                  [Sets SourcePartA to the first part found in the PartASupply]
               5.2.3.13.2.3 SetPose (PartSourcePose, ROBOT,
                                 SourcePartA.hasSolidObject_PhysicalLocation)
               5.2.3.13.2.4 SetPose (PartDestinationPose, ROBOT,
                                     GetPartPose(CurrentKitTray, PartA, 2))
                  [GetPartPose gets the pose in the design of the
                   CurrentKitTray of the second PartA. The SetPose statement
                   sets the PartDestinationPose relative to the robot.]
               5.2.3.13.2.5 RobotMoveAbove(PartSourcePose)
               5.2.3.13.2.6 RobotPickUp(SourcePartA)
               5.2.3.13.2.7 RobotMoveAbove(PartDestinationPose)
               5.2.3.13.2.8 RobotPutDown(SourcePartA, PartDestinationPose)
            5.2.3.13.3 DoInGivenOrder
               [the following statements put a PartB in the kit being built]
               5.2.3.13.3.1 If {Contains(PartBSupply, PartB, 1) == 0}
                  FactotumReplace "PartBSupply"
               5.2.3.13.3.2 If {Contains(PartBSupply, PartB, 1) == 0} Quit()
               5.2.3.13.3.3 Set (SourcePartB,
                          GetFirst(PartBSupply.hasPartsTrayWithParts_Parts))
                  [Sets SourcePartB to the first part found in the PartBSupply]
               5.2.3.13.3.4 SetPose (PartSourcePose, ROBOT,
                               SourcePartB.hasSolidObject_PhysicalLocation)
               5.2.3.13.3.5 SetPose (PartDestinationPose, ROBOT,
                                     GetPartPose(CurrentKitTray, PartB, 1))
                  [GetPartPose gets the pose in the design of the
                   CurrentKitTray of the PartB. The SetPose statement
                   sets the PartDestinationPose relative to the robot.]
               5.2.3.13.3.6 RobotMoveAbove(PartSourcePose)
               5.2.3.13.3.7 RobotPickUp(SourcePartB)
               5.2.3.13.3.8 RobotMoveAbove(PartDestinationPose)
               5.2.3.13.3.9 RobotPutDown(SourcePartB, PartDestinationPose)
            5.2.3.13.4 DoInGivenOrder
               [the following statements put a PartC in the kit being built]
               5.2.3.13.4.1 If {Contains(PartCSupply, PartC, 1) == 0}
                  FactotumReplace "PartCSupply"
               5.2.3.13.4.2 If {Contains(PartCSupply, PartC, 1) == 0} Quit()
               5.2.3.13.4.3 Set (SourcePartC,
                          GetFirst(PartCSupply.hasPartsTrayWithParts_Parts))
                  [Sets SourcePartC to the first part found in the PartCSupply]
               5.2.3.13.4.4 SetPose (PartSourcePose, ROBOT,
                               SourcePartC.hasSolidObject_PhysicalLocation)
               5.2.3.13.4.5 SetPose (PartDestinationPose, ROBOT,
                                     GetPartPose(CurrentKitTray, PartC, 1))
                  [GetPartPose gets the pose in the design of the
                   CurrentKitTray of the PartC. The SetPose statement
                   sets the PartDestinationPose relative to the robot.]
               5.2.3.13.4.6 RobotMoveAbove(PartSourcePose)
               5.2.3.13.4.7 RobotPickUp(SourcePartC)
               5.2.3.13.4.8 RobotMoveAbove(PartDestinationPose)
               5.2.3.13.4.9 RobotPutDown(SourcePartC, PartDestinationPose)
         [The kit is finished. The following statements put the finished
          kit in the BoxForFullTrays.]
         5.2.3.14 Set (CurrentKitInstance.isKitInstance_Finished, true)
         5.2.3.15 If {Contains(BoxForFullTrays, kitABC, 1) == 12}
                    DoInGivenOrder
               5.2.3.15.1 FactotumReplace (BoxForFullTrays)
               5.2.3.15.2 If {Contains(BoxForFullTrays, kitABC, 1) == 12}
                               Quit() [replacement should not be full]
         5.2.3.16 RobotChangeEndEffector("TrayGripper")
         5.2.3.17 SetPose (TrayDestinationPose, ROBOT,
                           BoxForFullTrays.hasSolidObject_PhysicalLocation)
                   [Where to put the finished kit. This should actually
                    be a pose that is just above the uppermost tray
                    already in the BoxForFullTrays, if there are any
                    trays there.]
         5.2.3.18 SetPose (CurrentTrayPose, ROBOT,
                           CurrentKitInstance.hasSolidObject_PhysicalLocation)
         5.2.3.18 RobotMoveAbove(CurrentTrayPose)
                  [Positions the TrayGripper above the finished kit.]
         5.2.3.19 RobotPickUp(CurrentKitInstance)
                  [robot moves TrayGripper down into position for grasping
                   the tray, TrayGripper grasps tray, robot moves up so that
                   the CurrentKitInstance clears the other trays on the table]
         5.2.3.20 RobotMoveAbove(TrayDestinationPose)
                  [Positions the CurrentKitInstance above the BoxForFullTrays.]
         5.2.3.21 RobotPutDown(CurrentKitInstance, TrayDestinationPose)
                  [Robot puts CurrentKitInstance down at TrayDestinationPose,
                   which is inside the BoxForFullTrays and withdraws to
                   where it was]
         5.2.3.22 Set (n, n+1)
   5.3 Stop

