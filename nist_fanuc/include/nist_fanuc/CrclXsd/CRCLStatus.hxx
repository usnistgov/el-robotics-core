// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CRCLSTATUS_HXX
#define CRCLSTATUS_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class CommandStateEnumType;
class CommandStatusType;
class CRCLStatusType;
class GripperStatusType;
class JointStatusesType;
class JointStatusType;
class ParallelGripperStatusType;
class PoseStatusType;
class ThreeFingerGripperStatusType;
class VacuumGripperStatusType;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "DataPrimitives.hxx"

class CommandStateEnumType: public ::xml_schema::string
{
  public:
  enum value
  {
    CRCL_Done,
    CRCL_Error,
    CRCL_Working,
    CRCL_Ready
  };

  CommandStateEnumType (value v);

  CommandStateEnumType (const char* v);

  CommandStateEnumType (const ::std::string& v);

  CommandStateEnumType (const ::xml_schema::string& v);

  CommandStateEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CommandStateEnumType (const CommandStateEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual CommandStateEnumType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CommandStateEnumType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_CommandStateEnumType_convert ();
  }

  protected:
  value
  _xsd_CommandStateEnumType_convert () const;

  public:
  static const char* const _xsd_CommandStateEnumType_literals_[4];
  static const value _xsd_CommandStateEnumType_indexes_[4];
};

class CommandStatusType: public ::DataThingType
{
  public:
  // CommandID
  //
  typedef ::xml_schema::non_negative_integer CommandID_type;
  typedef ::xsd::cxx::tree::traits< CommandID_type, char > CommandID_traits;

  const CommandID_type&
  CommandID () const;

  CommandID_type&
  CommandID ();

  void
  CommandID (const CommandID_type& x);

  // StatusID
  //
  typedef ::xml_schema::positive_integer StatusID_type;
  typedef ::xsd::cxx::tree::traits< StatusID_type, char > StatusID_traits;

  const StatusID_type&
  StatusID () const;

  StatusID_type&
  StatusID ();

  void
  StatusID (const StatusID_type& x);

  // CommandState
  //
  typedef ::CommandStateEnumType CommandState_type;
  typedef ::xsd::cxx::tree::traits< CommandState_type, char > CommandState_traits;

  const CommandState_type&
  CommandState () const;

  CommandState_type&
  CommandState ();

  void
  CommandState (const CommandState_type& x);

  void
  CommandState (::std::auto_ptr< CommandState_type > p);

  // StateDescription
  //
  typedef ::xml_schema::string StateDescription_type;
  typedef ::xsd::cxx::tree::optional< StateDescription_type > StateDescription_optional;
  typedef ::xsd::cxx::tree::traits< StateDescription_type, char > StateDescription_traits;

  const StateDescription_optional&
  StateDescription () const;

  StateDescription_optional&
  StateDescription ();

  void
  StateDescription (const StateDescription_type& x);

  void
  StateDescription (const StateDescription_optional& x);

  void
  StateDescription (::std::auto_ptr< StateDescription_type > p);

  // Constructors.
  //
  CommandStatusType (const CommandID_type&,
                     const StatusID_type&,
                     const CommandState_type&);

  CommandStatusType (const CommandID_type&,
                     const StatusID_type&,
                     ::std::auto_ptr< CommandState_type >);

  CommandStatusType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  CommandStatusType (const CommandStatusType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual CommandStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CommandStatusType&
  operator= (const CommandStatusType& x);

  virtual 
  ~CommandStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CommandID_type > CommandID_;
  ::xsd::cxx::tree::one< StatusID_type > StatusID_;
  ::xsd::cxx::tree::one< CommandState_type > CommandState_;
  StateDescription_optional StateDescription_;
};

class CRCLStatusType: public ::DataThingType
{
  public:
  // CommandStatus
  //
  typedef ::CommandStatusType CommandStatus_type;
  typedef ::xsd::cxx::tree::traits< CommandStatus_type, char > CommandStatus_traits;

  const CommandStatus_type&
  CommandStatus () const;

  CommandStatus_type&
  CommandStatus ();

  void
  CommandStatus (const CommandStatus_type& x);

  void
  CommandStatus (::std::auto_ptr< CommandStatus_type > p);

  // JointStatuses
  //
  typedef ::JointStatusesType JointStatuses_type;
  typedef ::xsd::cxx::tree::optional< JointStatuses_type > JointStatuses_optional;
  typedef ::xsd::cxx::tree::traits< JointStatuses_type, char > JointStatuses_traits;

  const JointStatuses_optional&
  JointStatuses () const;

  JointStatuses_optional&
  JointStatuses ();

  void
  JointStatuses (const JointStatuses_type& x);

  void
  JointStatuses (const JointStatuses_optional& x);

  void
  JointStatuses (::std::auto_ptr< JointStatuses_type > p);

  // PoseStatus
  //
  typedef ::PoseStatusType PoseStatus_type;
  typedef ::xsd::cxx::tree::optional< PoseStatus_type > PoseStatus_optional;
  typedef ::xsd::cxx::tree::traits< PoseStatus_type, char > PoseStatus_traits;

  const PoseStatus_optional&
  PoseStatus () const;

  PoseStatus_optional&
  PoseStatus ();

  void
  PoseStatus (const PoseStatus_type& x);

  void
  PoseStatus (const PoseStatus_optional& x);

  void
  PoseStatus (::std::auto_ptr< PoseStatus_type > p);

  // GripperStatus
  //
  typedef ::GripperStatusType GripperStatus_type;
  typedef ::xsd::cxx::tree::optional< GripperStatus_type > GripperStatus_optional;
  typedef ::xsd::cxx::tree::traits< GripperStatus_type, char > GripperStatus_traits;

  const GripperStatus_optional&
  GripperStatus () const;

  GripperStatus_optional&
  GripperStatus ();

  void
  GripperStatus (const GripperStatus_type& x);

  void
  GripperStatus (const GripperStatus_optional& x);

  void
  GripperStatus (::std::auto_ptr< GripperStatus_type > p);

  // Constructors.
  //
  CRCLStatusType (const CommandStatus_type&);

  CRCLStatusType (::std::auto_ptr< CommandStatus_type >);

  CRCLStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  CRCLStatusType (const CRCLStatusType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual CRCLStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CRCLStatusType&
  operator= (const CRCLStatusType& x);

  virtual 
  ~CRCLStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CommandStatus_type > CommandStatus_;
  JointStatuses_optional JointStatuses_;
  PoseStatus_optional PoseStatus_;
  GripperStatus_optional GripperStatus_;
};

class GripperStatusType: public ::DataThingType
{
  public:
  // GripperName
  //
  typedef ::xml_schema::nmtoken GripperName_type;
  typedef ::xsd::cxx::tree::traits< GripperName_type, char > GripperName_traits;

  const GripperName_type&
  GripperName () const;

  GripperName_type&
  GripperName ();

  void
  GripperName (const GripperName_type& x);

  void
  GripperName (::std::auto_ptr< GripperName_type > p);

  // Constructors.
  //
  GripperStatusType (const GripperName_type&);

  GripperStatusType (::std::auto_ptr< GripperName_type >);

  GripperStatusType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  GripperStatusType (const GripperStatusType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual GripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  GripperStatusType&
  operator= (const GripperStatusType& x);

  virtual 
  ~GripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< GripperName_type > GripperName_;
};

class JointStatusesType: public ::DataThingType
{
  public:
  // JointStatus
  //
  typedef ::JointStatusType JointStatus_type;
  typedef ::xsd::cxx::tree::sequence< JointStatus_type > JointStatus_sequence;
  typedef JointStatus_sequence::iterator JointStatus_iterator;
  typedef JointStatus_sequence::const_iterator JointStatus_const_iterator;
  typedef ::xsd::cxx::tree::traits< JointStatus_type, char > JointStatus_traits;

  const JointStatus_sequence&
  JointStatus () const;

  JointStatus_sequence&
  JointStatus ();

  void
  JointStatus (const JointStatus_sequence& s);

  // Constructors.
  //
  JointStatusesType ();

  JointStatusesType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  JointStatusesType (const JointStatusesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual JointStatusesType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  JointStatusesType&
  operator= (const JointStatusesType& x);

  virtual 
  ~JointStatusesType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  JointStatus_sequence JointStatus_;
};

class JointStatusType: public ::DataThingType
{
  public:
  // JointNumber
  //
  typedef ::xml_schema::positive_integer JointNumber_type;
  typedef ::xsd::cxx::tree::traits< JointNumber_type, char > JointNumber_traits;

  const JointNumber_type&
  JointNumber () const;

  JointNumber_type&
  JointNumber ();

  void
  JointNumber (const JointNumber_type& x);

  // JointPosition
  //
  typedef ::xml_schema::decimal JointPosition_type;
  typedef ::xsd::cxx::tree::optional< JointPosition_type > JointPosition_optional;
  typedef ::xsd::cxx::tree::traits< JointPosition_type, char, ::xsd::cxx::tree::schema_type::decimal > JointPosition_traits;

  const JointPosition_optional&
  JointPosition () const;

  JointPosition_optional&
  JointPosition ();

  void
  JointPosition (const JointPosition_type& x);

  void
  JointPosition (const JointPosition_optional& x);

  // JointTorqueOrForce
  //
  typedef ::xml_schema::decimal JointTorqueOrForce_type;
  typedef ::xsd::cxx::tree::optional< JointTorqueOrForce_type > JointTorqueOrForce_optional;
  typedef ::xsd::cxx::tree::traits< JointTorqueOrForce_type, char, ::xsd::cxx::tree::schema_type::decimal > JointTorqueOrForce_traits;

  const JointTorqueOrForce_optional&
  JointTorqueOrForce () const;

  JointTorqueOrForce_optional&
  JointTorqueOrForce ();

  void
  JointTorqueOrForce (const JointTorqueOrForce_type& x);

  void
  JointTorqueOrForce (const JointTorqueOrForce_optional& x);

  // JointVelocity
  //
  typedef ::xml_schema::decimal JointVelocity_type;
  typedef ::xsd::cxx::tree::optional< JointVelocity_type > JointVelocity_optional;
  typedef ::xsd::cxx::tree::traits< JointVelocity_type, char, ::xsd::cxx::tree::schema_type::decimal > JointVelocity_traits;

  const JointVelocity_optional&
  JointVelocity () const;

  JointVelocity_optional&
  JointVelocity ();

  void
  JointVelocity (const JointVelocity_type& x);

  void
  JointVelocity (const JointVelocity_optional& x);

  // Constructors.
  //
  JointStatusType (const JointNumber_type&);

  JointStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  JointStatusType (const JointStatusType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual JointStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  JointStatusType&
  operator= (const JointStatusType& x);

  virtual 
  ~JointStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< JointNumber_type > JointNumber_;
  JointPosition_optional JointPosition_;
  JointTorqueOrForce_optional JointTorqueOrForce_;
  JointVelocity_optional JointVelocity_;
};

class ParallelGripperStatusType: public ::GripperStatusType
{
  public:
  // Separation
  //
  typedef ::xml_schema::decimal Separation_type;
  typedef ::xsd::cxx::tree::traits< Separation_type, char, ::xsd::cxx::tree::schema_type::decimal > Separation_traits;

  const Separation_type&
  Separation () const;

  Separation_type&
  Separation ();

  void
  Separation (const Separation_type& x);

  // Constructors.
  //
  ParallelGripperStatusType (const ::GripperStatusType&,
                             const Separation_type&);

  ParallelGripperStatusType (const GripperName_type&,
                             const Separation_type&);

  ParallelGripperStatusType (::std::auto_ptr< GripperName_type >,
                             const Separation_type&);

  ParallelGripperStatusType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  ParallelGripperStatusType (const ParallelGripperStatusType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual ParallelGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParallelGripperStatusType&
  operator= (const ParallelGripperStatusType& x);

  virtual 
  ~ParallelGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Separation_type > Separation_;
};

class PoseStatusType: public ::DataThingType
{
  public:
  // Pose
  //
  typedef ::PoseType Pose_type;
  typedef ::xsd::cxx::tree::traits< Pose_type, char > Pose_traits;

  const Pose_type&
  Pose () const;

  Pose_type&
  Pose ();

  void
  Pose (const Pose_type& x);

  void
  Pose (::std::auto_ptr< Pose_type > p);

  // Twist
  //
  typedef ::TwistType Twist_type;
  typedef ::xsd::cxx::tree::optional< Twist_type > Twist_optional;
  typedef ::xsd::cxx::tree::traits< Twist_type, char > Twist_traits;

  const Twist_optional&
  Twist () const;

  Twist_optional&
  Twist ();

  void
  Twist (const Twist_type& x);

  void
  Twist (const Twist_optional& x);

  void
  Twist (::std::auto_ptr< Twist_type > p);

  // Wrench
  //
  typedef ::WrenchType Wrench_type;
  typedef ::xsd::cxx::tree::optional< Wrench_type > Wrench_optional;
  typedef ::xsd::cxx::tree::traits< Wrench_type, char > Wrench_traits;

  const Wrench_optional&
  Wrench () const;

  Wrench_optional&
  Wrench ();

  void
  Wrench (const Wrench_type& x);

  void
  Wrench (const Wrench_optional& x);

  void
  Wrench (::std::auto_ptr< Wrench_type > p);

  // Constructors.
  //
  PoseStatusType (const Pose_type&);

  PoseStatusType (::std::auto_ptr< Pose_type >);

  PoseStatusType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  PoseStatusType (const PoseStatusType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual PoseStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PoseStatusType&
  operator= (const PoseStatusType& x);

  virtual 
  ~PoseStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Pose_type > Pose_;
  Twist_optional Twist_;
  Wrench_optional Wrench_;
};

class ThreeFingerGripperStatusType: public ::GripperStatusType
{
  public:
  // Finger1Position
  //
  typedef ::FractionType Finger1Position_type;
  typedef ::xsd::cxx::tree::optional< Finger1Position_type > Finger1Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger1Position_type, char > Finger1Position_traits;

  const Finger1Position_optional&
  Finger1Position () const;

  Finger1Position_optional&
  Finger1Position ();

  void
  Finger1Position (const Finger1Position_type& x);

  void
  Finger1Position (const Finger1Position_optional& x);

  void
  Finger1Position (::std::auto_ptr< Finger1Position_type > p);

  // Finger2Position
  //
  typedef ::FractionType Finger2Position_type;
  typedef ::xsd::cxx::tree::optional< Finger2Position_type > Finger2Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger2Position_type, char > Finger2Position_traits;

  const Finger2Position_optional&
  Finger2Position () const;

  Finger2Position_optional&
  Finger2Position ();

  void
  Finger2Position (const Finger2Position_type& x);

  void
  Finger2Position (const Finger2Position_optional& x);

  void
  Finger2Position (::std::auto_ptr< Finger2Position_type > p);

  // Finger3Position
  //
  typedef ::FractionType Finger3Position_type;
  typedef ::xsd::cxx::tree::optional< Finger3Position_type > Finger3Position_optional;
  typedef ::xsd::cxx::tree::traits< Finger3Position_type, char > Finger3Position_traits;

  const Finger3Position_optional&
  Finger3Position () const;

  Finger3Position_optional&
  Finger3Position ();

  void
  Finger3Position (const Finger3Position_type& x);

  void
  Finger3Position (const Finger3Position_optional& x);

  void
  Finger3Position (::std::auto_ptr< Finger3Position_type > p);

  // Finger1Force
  //
  typedef ::xml_schema::decimal Finger1Force_type;
  typedef ::xsd::cxx::tree::optional< Finger1Force_type > Finger1Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger1Force_type, char, ::xsd::cxx::tree::schema_type::decimal > Finger1Force_traits;

  const Finger1Force_optional&
  Finger1Force () const;

  Finger1Force_optional&
  Finger1Force ();

  void
  Finger1Force (const Finger1Force_type& x);

  void
  Finger1Force (const Finger1Force_optional& x);

  // Finger2Force
  //
  typedef ::xml_schema::decimal Finger2Force_type;
  typedef ::xsd::cxx::tree::optional< Finger2Force_type > Finger2Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger2Force_type, char, ::xsd::cxx::tree::schema_type::decimal > Finger2Force_traits;

  const Finger2Force_optional&
  Finger2Force () const;

  Finger2Force_optional&
  Finger2Force ();

  void
  Finger2Force (const Finger2Force_type& x);

  void
  Finger2Force (const Finger2Force_optional& x);

  // Finger3Force
  //
  typedef ::xml_schema::decimal Finger3Force_type;
  typedef ::xsd::cxx::tree::optional< Finger3Force_type > Finger3Force_optional;
  typedef ::xsd::cxx::tree::traits< Finger3Force_type, char, ::xsd::cxx::tree::schema_type::decimal > Finger3Force_traits;

  const Finger3Force_optional&
  Finger3Force () const;

  Finger3Force_optional&
  Finger3Force ();

  void
  Finger3Force (const Finger3Force_type& x);

  void
  Finger3Force (const Finger3Force_optional& x);

  // Constructors.
  //
  ThreeFingerGripperStatusType (const ::GripperStatusType&);

  ThreeFingerGripperStatusType (const GripperName_type&);

  ThreeFingerGripperStatusType (::std::auto_ptr< GripperName_type >);

  ThreeFingerGripperStatusType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  ThreeFingerGripperStatusType (const ThreeFingerGripperStatusType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual ThreeFingerGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ThreeFingerGripperStatusType&
  operator= (const ThreeFingerGripperStatusType& x);

  virtual 
  ~ThreeFingerGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Finger1Position_optional Finger1Position_;
  Finger2Position_optional Finger2Position_;
  Finger3Position_optional Finger3Position_;
  Finger1Force_optional Finger1Force_;
  Finger2Force_optional Finger2Force_;
  Finger3Force_optional Finger3Force_;
};

class VacuumGripperStatusType: public ::GripperStatusType
{
  public:
  // IsPowered
  //
  typedef ::xml_schema::boolean IsPowered_type;
  typedef ::xsd::cxx::tree::traits< IsPowered_type, char > IsPowered_traits;

  const IsPowered_type&
  IsPowered () const;

  IsPowered_type&
  IsPowered ();

  void
  IsPowered (const IsPowered_type& x);

  // Constructors.
  //
  VacuumGripperStatusType (const ::GripperStatusType&,
                           const IsPowered_type&);

  VacuumGripperStatusType (const GripperName_type&,
                           const IsPowered_type&);

  VacuumGripperStatusType (::std::auto_ptr< GripperName_type >,
                           const IsPowered_type&);

  VacuumGripperStatusType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  VacuumGripperStatusType (const VacuumGripperStatusType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual VacuumGripperStatusType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  VacuumGripperStatusType&
  operator= (const VacuumGripperStatusType& x);

  virtual 
  ~VacuumGripperStatusType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< IsPowered_type > IsPowered_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::std::ostream& os,
            const ::CRCLStatusType& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

void
CRCLStatus (::xercesc::XMLFormatTarget& ft,
            const ::CRCLStatusType& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
CRCLStatus (::xercesc::DOMDocument& d,
            const ::CRCLStatusType& x,
            ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CRCLStatus (const ::CRCLStatusType& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const CommandStateEnumType&);

void
operator<< (::xercesc::DOMAttr&, const CommandStateEnumType&);

void
operator<< (::xml_schema::list_stream&,
            const CommandStateEnumType&);

void
operator<< (::xercesc::DOMElement&, const CommandStatusType&);

void
operator<< (::xercesc::DOMElement&, const CRCLStatusType&);

void
operator<< (::xercesc::DOMElement&, const GripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const JointStatusesType&);

void
operator<< (::xercesc::DOMElement&, const JointStatusType&);

void
operator<< (::xercesc::DOMElement&, const ParallelGripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const PoseStatusType&);

void
operator<< (::xercesc::DOMElement&, const ThreeFingerGripperStatusType&);

void
operator<< (::xercesc::DOMElement&, const VacuumGripperStatusType&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CRCLSTATUS_HXX
