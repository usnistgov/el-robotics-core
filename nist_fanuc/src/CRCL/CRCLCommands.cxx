// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CRCLCommands.hxx"

// CRCLCommandType
// 

const CRCLCommandType::CommandID_type& CRCLCommandType::
CommandID () const
{
  return this->CommandID_.get ();
}

CRCLCommandType::CommandID_type& CRCLCommandType::
CommandID ()
{
  return this->CommandID_.get ();
}

void CRCLCommandType::
CommandID (const CommandID_type& x)
{
  this->CommandID_.set (x);
}


// MiddleCommandType
// 


// ActuateJointsType
// 

const ActuateJointsType::ActuateJoint_sequence& ActuateJointsType::
ActuateJoint () const
{
  return this->ActuateJoint_;
}

ActuateJointsType::ActuateJoint_sequence& ActuateJointsType::
ActuateJoint ()
{
  return this->ActuateJoint_;
}

void ActuateJointsType::
ActuateJoint (const ActuateJoint_sequence& s)
{
  this->ActuateJoint_ = s;
}


// ActuateJointType
// 

const ActuateJointType::JointNumber_type& ActuateJointType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

ActuateJointType::JointNumber_type& ActuateJointType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void ActuateJointType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const ActuateJointType::JointPosition_type& ActuateJointType::
JointPosition () const
{
  return this->JointPosition_.get ();
}

ActuateJointType::JointPosition_type& ActuateJointType::
JointPosition ()
{
  return this->JointPosition_.get ();
}

void ActuateJointType::
JointPosition (const JointPosition_type& x)
{
  this->JointPosition_.set (x);
}

const ActuateJointType::JointDetails_type& ActuateJointType::
JointDetails () const
{
  return this->JointDetails_.get ();
}

ActuateJointType::JointDetails_type& ActuateJointType::
JointDetails ()
{
  return this->JointDetails_.get ();
}

void ActuateJointType::
JointDetails (const JointDetails_type& x)
{
  this->JointDetails_.set (x);
}

void ActuateJointType::
JointDetails (::std::auto_ptr< JointDetails_type > x)
{
  this->JointDetails_.set (x);
}


// CloseToolChangerType
// 


// ConfigureJointReportsType
// 

const ConfigureJointReportsType::ResetAll_type& ConfigureJointReportsType::
ResetAll () const
{
  return this->ResetAll_.get ();
}

ConfigureJointReportsType::ResetAll_type& ConfigureJointReportsType::
ResetAll ()
{
  return this->ResetAll_.get ();
}

void ConfigureJointReportsType::
ResetAll (const ResetAll_type& x)
{
  this->ResetAll_.set (x);
}

const ConfigureJointReportsType::ConfigureJointReport_sequence& ConfigureJointReportsType::
ConfigureJointReport () const
{
  return this->ConfigureJointReport_;
}

ConfigureJointReportsType::ConfigureJointReport_sequence& ConfigureJointReportsType::
ConfigureJointReport ()
{
  return this->ConfigureJointReport_;
}

void ConfigureJointReportsType::
ConfigureJointReport (const ConfigureJointReport_sequence& s)
{
  this->ConfigureJointReport_ = s;
}


// ConfigureJointReportType
// 

const ConfigureJointReportType::JointNumber_type& ConfigureJointReportType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

ConfigureJointReportType::JointNumber_type& ConfigureJointReportType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void ConfigureJointReportType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const ConfigureJointReportType::ReportPosition_type& ConfigureJointReportType::
ReportPosition () const
{
  return this->ReportPosition_.get ();
}

ConfigureJointReportType::ReportPosition_type& ConfigureJointReportType::
ReportPosition ()
{
  return this->ReportPosition_.get ();
}

void ConfigureJointReportType::
ReportPosition (const ReportPosition_type& x)
{
  this->ReportPosition_.set (x);
}

const ConfigureJointReportType::ReportTorqueOrForce_type& ConfigureJointReportType::
ReportTorqueOrForce () const
{
  return this->ReportTorqueOrForce_.get ();
}

ConfigureJointReportType::ReportTorqueOrForce_type& ConfigureJointReportType::
ReportTorqueOrForce ()
{
  return this->ReportTorqueOrForce_.get ();
}

void ConfigureJointReportType::
ReportTorqueOrForce (const ReportTorqueOrForce_type& x)
{
  this->ReportTorqueOrForce_.set (x);
}

const ConfigureJointReportType::ReportVelocity_type& ConfigureJointReportType::
ReportVelocity () const
{
  return this->ReportVelocity_.get ();
}

ConfigureJointReportType::ReportVelocity_type& ConfigureJointReportType::
ReportVelocity ()
{
  return this->ReportVelocity_.get ();
}

void ConfigureJointReportType::
ReportVelocity (const ReportVelocity_type& x)
{
  this->ReportVelocity_.set (x);
}


// DwellType
// 

const DwellType::DwellTime_type& DwellType::
DwellTime () const
{
  return this->DwellTime_.get ();
}

DwellType::DwellTime_type& DwellType::
DwellTime ()
{
  return this->DwellTime_.get ();
}

void DwellType::
DwellTime (const DwellTime_type& x)
{
  this->DwellTime_.set (x);
}


// EndCanonType
// 


// GetStatusType
// 


// InitCanonType
// 


// JointDetailsType
// 


// JointForceTorqueType
// 

const JointForceTorqueType::Setting_optional& JointForceTorqueType::
Setting () const
{
  return this->Setting_;
}

JointForceTorqueType::Setting_optional& JointForceTorqueType::
Setting ()
{
  return this->Setting_;
}

void JointForceTorqueType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}

void JointForceTorqueType::
Setting (const Setting_optional& x)
{
  this->Setting_ = x;
}

const JointForceTorqueType::ChangeRate_optional& JointForceTorqueType::
ChangeRate () const
{
  return this->ChangeRate_;
}

JointForceTorqueType::ChangeRate_optional& JointForceTorqueType::
ChangeRate ()
{
  return this->ChangeRate_;
}

void JointForceTorqueType::
ChangeRate (const ChangeRate_type& x)
{
  this->ChangeRate_.set (x);
}

void JointForceTorqueType::
ChangeRate (const ChangeRate_optional& x)
{
  this->ChangeRate_ = x;
}


// JointSpeedAccelType
// 

const JointSpeedAccelType::JointSpeed_optional& JointSpeedAccelType::
JointSpeed () const
{
  return this->JointSpeed_;
}

JointSpeedAccelType::JointSpeed_optional& JointSpeedAccelType::
JointSpeed ()
{
  return this->JointSpeed_;
}

void JointSpeedAccelType::
JointSpeed (const JointSpeed_type& x)
{
  this->JointSpeed_.set (x);
}

void JointSpeedAccelType::
JointSpeed (const JointSpeed_optional& x)
{
  this->JointSpeed_ = x;
}

const JointSpeedAccelType::JointAccel_optional& JointSpeedAccelType::
JointAccel () const
{
  return this->JointAccel_;
}

JointSpeedAccelType::JointAccel_optional& JointSpeedAccelType::
JointAccel ()
{
  return this->JointAccel_;
}

void JointSpeedAccelType::
JointAccel (const JointAccel_type& x)
{
  this->JointAccel_.set (x);
}

void JointSpeedAccelType::
JointAccel (const JointAccel_optional& x)
{
  this->JointAccel_ = x;
}


// MessageType
// 

const MessageType::Message_type& MessageType::
Message () const
{
  return this->Message_.get ();
}

MessageType::Message_type& MessageType::
Message ()
{
  return this->Message_.get ();
}

void MessageType::
Message (const Message_type& x)
{
  this->Message_.set (x);
}

void MessageType::
Message (::std::auto_ptr< Message_type > x)
{
  this->Message_.set (x);
}


// MoveScrewType
// 

const MoveScrewType::StartPosition_optional& MoveScrewType::
StartPosition () const
{
  return this->StartPosition_;
}

MoveScrewType::StartPosition_optional& MoveScrewType::
StartPosition ()
{
  return this->StartPosition_;
}

void MoveScrewType::
StartPosition (const StartPosition_type& x)
{
  this->StartPosition_.set (x);
}

void MoveScrewType::
StartPosition (const StartPosition_optional& x)
{
  this->StartPosition_ = x;
}

void MoveScrewType::
StartPosition (::std::auto_ptr< StartPosition_type > x)
{
  this->StartPosition_.set (x);
}

const MoveScrewType::AxisPoint_optional& MoveScrewType::
AxisPoint () const
{
  return this->AxisPoint_;
}

MoveScrewType::AxisPoint_optional& MoveScrewType::
AxisPoint ()
{
  return this->AxisPoint_;
}

void MoveScrewType::
AxisPoint (const AxisPoint_type& x)
{
  this->AxisPoint_.set (x);
}

void MoveScrewType::
AxisPoint (const AxisPoint_optional& x)
{
  this->AxisPoint_ = x;
}

void MoveScrewType::
AxisPoint (::std::auto_ptr< AxisPoint_type > x)
{
  this->AxisPoint_.set (x);
}

const MoveScrewType::AxialDistanceFree_optional& MoveScrewType::
AxialDistanceFree () const
{
  return this->AxialDistanceFree_;
}

MoveScrewType::AxialDistanceFree_optional& MoveScrewType::
AxialDistanceFree ()
{
  return this->AxialDistanceFree_;
}

void MoveScrewType::
AxialDistanceFree (const AxialDistanceFree_type& x)
{
  this->AxialDistanceFree_.set (x);
}

void MoveScrewType::
AxialDistanceFree (const AxialDistanceFree_optional& x)
{
  this->AxialDistanceFree_ = x;
}

const MoveScrewType::AxialDistanceScrew_type& MoveScrewType::
AxialDistanceScrew () const
{
  return this->AxialDistanceScrew_.get ();
}

MoveScrewType::AxialDistanceScrew_type& MoveScrewType::
AxialDistanceScrew ()
{
  return this->AxialDistanceScrew_.get ();
}

void MoveScrewType::
AxialDistanceScrew (const AxialDistanceScrew_type& x)
{
  this->AxialDistanceScrew_.set (x);
}

const MoveScrewType::Turn_type& MoveScrewType::
Turn () const
{
  return this->Turn_.get ();
}

MoveScrewType::Turn_type& MoveScrewType::
Turn ()
{
  return this->Turn_.get ();
}

void MoveScrewType::
Turn (const Turn_type& x)
{
  this->Turn_.set (x);
}


// MoveThroughToType
// 

const MoveThroughToType::MoveStraight_type& MoveThroughToType::
MoveStraight () const
{
  return this->MoveStraight_.get ();
}

MoveThroughToType::MoveStraight_type& MoveThroughToType::
MoveStraight ()
{
  return this->MoveStraight_.get ();
}

void MoveThroughToType::
MoveStraight (const MoveStraight_type& x)
{
  this->MoveStraight_.set (x);
}

const MoveThroughToType::Waypoint_sequence& MoveThroughToType::
Waypoint () const
{
  return this->Waypoint_;
}

MoveThroughToType::Waypoint_sequence& MoveThroughToType::
Waypoint ()
{
  return this->Waypoint_;
}

void MoveThroughToType::
Waypoint (const Waypoint_sequence& s)
{
  this->Waypoint_ = s;
}

const MoveThroughToType::NumPositions_type& MoveThroughToType::
NumPositions () const
{
  return this->NumPositions_.get ();
}

MoveThroughToType::NumPositions_type& MoveThroughToType::
NumPositions ()
{
  return this->NumPositions_.get ();
}

void MoveThroughToType::
NumPositions (const NumPositions_type& x)
{
  this->NumPositions_.set (x);
}


// MoveToType
// 

const MoveToType::MoveStraight_type& MoveToType::
MoveStraight () const
{
  return this->MoveStraight_.get ();
}

MoveToType::MoveStraight_type& MoveToType::
MoveStraight ()
{
  return this->MoveStraight_.get ();
}

void MoveToType::
MoveStraight (const MoveStraight_type& x)
{
  this->MoveStraight_.set (x);
}

const MoveToType::EndPosition_type& MoveToType::
EndPosition () const
{
  return this->EndPosition_.get ();
}

MoveToType::EndPosition_type& MoveToType::
EndPosition ()
{
  return this->EndPosition_.get ();
}

void MoveToType::
EndPosition (const EndPosition_type& x)
{
  this->EndPosition_.set (x);
}

void MoveToType::
EndPosition (::std::auto_ptr< EndPosition_type > x)
{
  this->EndPosition_.set (x);
}


// OpenToolChangerType
// 


// ParameterSettingType
// 

const ParameterSettingType::ParameterName_type& ParameterSettingType::
ParameterName () const
{
  return this->ParameterName_.get ();
}

ParameterSettingType::ParameterName_type& ParameterSettingType::
ParameterName ()
{
  return this->ParameterName_.get ();
}

void ParameterSettingType::
ParameterName (const ParameterName_type& x)
{
  this->ParameterName_.set (x);
}

void ParameterSettingType::
ParameterName (::std::auto_ptr< ParameterName_type > x)
{
  this->ParameterName_.set (x);
}

const ParameterSettingType::ParameterValue_type& ParameterSettingType::
ParameterValue () const
{
  return this->ParameterValue_.get ();
}

ParameterSettingType::ParameterValue_type& ParameterSettingType::
ParameterValue ()
{
  return this->ParameterValue_.get ();
}

void ParameterSettingType::
ParameterValue (const ParameterValue_type& x)
{
  this->ParameterValue_.set (x);
}

void ParameterSettingType::
ParameterValue (::std::auto_ptr< ParameterValue_type > x)
{
  this->ParameterValue_.set (x);
}


// PoseAndSetType
// 

const PoseAndSetType::Coordinated_type& PoseAndSetType::
Coordinated () const
{
  return this->Coordinated_.get ();
}

PoseAndSetType::Coordinated_type& PoseAndSetType::
Coordinated ()
{
  return this->Coordinated_.get ();
}

void PoseAndSetType::
Coordinated (const Coordinated_type& x)
{
  this->Coordinated_.set (x);
}

const PoseAndSetType::TransSpeed_optional& PoseAndSetType::
TransSpeed () const
{
  return this->TransSpeed_;
}

PoseAndSetType::TransSpeed_optional& PoseAndSetType::
TransSpeed ()
{
  return this->TransSpeed_;
}

void PoseAndSetType::
TransSpeed (const TransSpeed_type& x)
{
  this->TransSpeed_.set (x);
}

void PoseAndSetType::
TransSpeed (const TransSpeed_optional& x)
{
  this->TransSpeed_ = x;
}

void PoseAndSetType::
TransSpeed (::std::auto_ptr< TransSpeed_type > x)
{
  this->TransSpeed_.set (x);
}

const PoseAndSetType::RotSpeed_optional& PoseAndSetType::
RotSpeed () const
{
  return this->RotSpeed_;
}

PoseAndSetType::RotSpeed_optional& PoseAndSetType::
RotSpeed ()
{
  return this->RotSpeed_;
}

void PoseAndSetType::
RotSpeed (const RotSpeed_type& x)
{
  this->RotSpeed_.set (x);
}

void PoseAndSetType::
RotSpeed (const RotSpeed_optional& x)
{
  this->RotSpeed_ = x;
}

void PoseAndSetType::
RotSpeed (::std::auto_ptr< RotSpeed_type > x)
{
  this->RotSpeed_.set (x);
}

const PoseAndSetType::TransAccel_optional& PoseAndSetType::
TransAccel () const
{
  return this->TransAccel_;
}

PoseAndSetType::TransAccel_optional& PoseAndSetType::
TransAccel ()
{
  return this->TransAccel_;
}

void PoseAndSetType::
TransAccel (const TransAccel_type& x)
{
  this->TransAccel_.set (x);
}

void PoseAndSetType::
TransAccel (const TransAccel_optional& x)
{
  this->TransAccel_ = x;
}

void PoseAndSetType::
TransAccel (::std::auto_ptr< TransAccel_type > x)
{
  this->TransAccel_.set (x);
}

const PoseAndSetType::RotAccel_optional& PoseAndSetType::
RotAccel () const
{
  return this->RotAccel_;
}

PoseAndSetType::RotAccel_optional& PoseAndSetType::
RotAccel ()
{
  return this->RotAccel_;
}

void PoseAndSetType::
RotAccel (const RotAccel_type& x)
{
  this->RotAccel_.set (x);
}

void PoseAndSetType::
RotAccel (const RotAccel_optional& x)
{
  this->RotAccel_ = x;
}

void PoseAndSetType::
RotAccel (::std::auto_ptr< RotAccel_type > x)
{
  this->RotAccel_.set (x);
}

const PoseAndSetType::Tolerance_optional& PoseAndSetType::
Tolerance () const
{
  return this->Tolerance_;
}

PoseAndSetType::Tolerance_optional& PoseAndSetType::
Tolerance ()
{
  return this->Tolerance_;
}

void PoseAndSetType::
Tolerance (const Tolerance_type& x)
{
  this->Tolerance_.set (x);
}

void PoseAndSetType::
Tolerance (const Tolerance_optional& x)
{
  this->Tolerance_ = x;
}

void PoseAndSetType::
Tolerance (::std::auto_ptr< Tolerance_type > x)
{
  this->Tolerance_.set (x);
}


// PoseToleranceType
// 

const PoseToleranceType::XPointTolerance_optional& PoseToleranceType::
XPointTolerance () const
{
  return this->XPointTolerance_;
}

PoseToleranceType::XPointTolerance_optional& PoseToleranceType::
XPointTolerance ()
{
  return this->XPointTolerance_;
}

void PoseToleranceType::
XPointTolerance (const XPointTolerance_type& x)
{
  this->XPointTolerance_.set (x);
}

void PoseToleranceType::
XPointTolerance (const XPointTolerance_optional& x)
{
  this->XPointTolerance_ = x;
}

const PoseToleranceType::YPointTolerance_optional& PoseToleranceType::
YPointTolerance () const
{
  return this->YPointTolerance_;
}

PoseToleranceType::YPointTolerance_optional& PoseToleranceType::
YPointTolerance ()
{
  return this->YPointTolerance_;
}

void PoseToleranceType::
YPointTolerance (const YPointTolerance_type& x)
{
  this->YPointTolerance_.set (x);
}

void PoseToleranceType::
YPointTolerance (const YPointTolerance_optional& x)
{
  this->YPointTolerance_ = x;
}

const PoseToleranceType::ZPointTolerance_optional& PoseToleranceType::
ZPointTolerance () const
{
  return this->ZPointTolerance_;
}

PoseToleranceType::ZPointTolerance_optional& PoseToleranceType::
ZPointTolerance ()
{
  return this->ZPointTolerance_;
}

void PoseToleranceType::
ZPointTolerance (const ZPointTolerance_type& x)
{
  this->ZPointTolerance_.set (x);
}

void PoseToleranceType::
ZPointTolerance (const ZPointTolerance_optional& x)
{
  this->ZPointTolerance_ = x;
}

const PoseToleranceType::XAxisTolerance_optional& PoseToleranceType::
XAxisTolerance () const
{
  return this->XAxisTolerance_;
}

PoseToleranceType::XAxisTolerance_optional& PoseToleranceType::
XAxisTolerance ()
{
  return this->XAxisTolerance_;
}

void PoseToleranceType::
XAxisTolerance (const XAxisTolerance_type& x)
{
  this->XAxisTolerance_.set (x);
}

void PoseToleranceType::
XAxisTolerance (const XAxisTolerance_optional& x)
{
  this->XAxisTolerance_ = x;
}

const PoseToleranceType::ZAxisTolerance_optional& PoseToleranceType::
ZAxisTolerance () const
{
  return this->ZAxisTolerance_;
}

PoseToleranceType::ZAxisTolerance_optional& PoseToleranceType::
ZAxisTolerance ()
{
  return this->ZAxisTolerance_;
}

void PoseToleranceType::
ZAxisTolerance (const ZAxisTolerance_type& x)
{
  this->ZAxisTolerance_.set (x);
}

void PoseToleranceType::
ZAxisTolerance (const ZAxisTolerance_optional& x)
{
  this->ZAxisTolerance_ = x;
}


// RotAccelType
// 


// RotAccelAbsoluteType
// 

const RotAccelAbsoluteType::Setting_type& RotAccelAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

RotAccelAbsoluteType::Setting_type& RotAccelAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void RotAccelAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// RotAccelRelativeType
// 

const RotAccelRelativeType::Fraction_type& RotAccelRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

RotAccelRelativeType::Fraction_type& RotAccelRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void RotAccelRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void RotAccelRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// RotSpeedType
// 


// RotSpeedAbsoluteType
// 

const RotSpeedAbsoluteType::Setting_type& RotSpeedAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

RotSpeedAbsoluteType::Setting_type& RotSpeedAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void RotSpeedAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// RotSpeedRelativeType
// 

const RotSpeedRelativeType::Fraction_type& RotSpeedRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

RotSpeedRelativeType::Fraction_type& RotSpeedRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void RotSpeedRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void RotSpeedRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// RunProgramType
// 

const RunProgramType::ProgramText_type& RunProgramType::
ProgramText () const
{
  return this->ProgramText_.get ();
}

RunProgramType::ProgramText_type& RunProgramType::
ProgramText ()
{
  return this->ProgramText_.get ();
}

void RunProgramType::
ProgramText (const ProgramText_type& x)
{
  this->ProgramText_.set (x);
}

void RunProgramType::
ProgramText (::std::auto_ptr< ProgramText_type > x)
{
  this->ProgramText_.set (x);
}


// SetAngleUnitsType
// 

const SetAngleUnitsType::UnitName_type& SetAngleUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetAngleUnitsType::UnitName_type& SetAngleUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetAngleUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetAngleUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetEndEffectorParametersType
// 

const SetEndEffectorParametersType::ParameterSetting_sequence& SetEndEffectorParametersType::
ParameterSetting () const
{
  return this->ParameterSetting_;
}

SetEndEffectorParametersType::ParameterSetting_sequence& SetEndEffectorParametersType::
ParameterSetting ()
{
  return this->ParameterSetting_;
}

void SetEndEffectorParametersType::
ParameterSetting (const ParameterSetting_sequence& s)
{
  this->ParameterSetting_ = s;
}


// SetEndEffectorType
// 

const SetEndEffectorType::Setting_type& SetEndEffectorType::
Setting () const
{
  return this->Setting_.get ();
}

SetEndEffectorType::Setting_type& SetEndEffectorType::
Setting ()
{
  return this->Setting_.get ();
}

void SetEndEffectorType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}

void SetEndEffectorType::
Setting (::std::auto_ptr< Setting_type > x)
{
  this->Setting_.set (x);
}


// SetEndPoseToleranceType
// 

const SetEndPoseToleranceType::Tolerance_type& SetEndPoseToleranceType::
Tolerance () const
{
  return this->Tolerance_.get ();
}

SetEndPoseToleranceType::Tolerance_type& SetEndPoseToleranceType::
Tolerance ()
{
  return this->Tolerance_.get ();
}

void SetEndPoseToleranceType::
Tolerance (const Tolerance_type& x)
{
  this->Tolerance_.set (x);
}

void SetEndPoseToleranceType::
Tolerance (::std::auto_ptr< Tolerance_type > x)
{
  this->Tolerance_.set (x);
}


// SetForceUnitsType
// 

const SetForceUnitsType::UnitName_type& SetForceUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetForceUnitsType::UnitName_type& SetForceUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetForceUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetForceUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetIntermediatePoseToleranceType
// 

const SetIntermediatePoseToleranceType::Tolerance_type& SetIntermediatePoseToleranceType::
Tolerance () const
{
  return this->Tolerance_.get ();
}

SetIntermediatePoseToleranceType::Tolerance_type& SetIntermediatePoseToleranceType::
Tolerance ()
{
  return this->Tolerance_.get ();
}

void SetIntermediatePoseToleranceType::
Tolerance (const Tolerance_type& x)
{
  this->Tolerance_.set (x);
}

void SetIntermediatePoseToleranceType::
Tolerance (::std::auto_ptr< Tolerance_type > x)
{
  this->Tolerance_.set (x);
}


// SetLengthUnitsType
// 

const SetLengthUnitsType::UnitName_type& SetLengthUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetLengthUnitsType::UnitName_type& SetLengthUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetLengthUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetLengthUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetMotionCoordinationType
// 

const SetMotionCoordinationType::Coordinated_type& SetMotionCoordinationType::
Coordinated () const
{
  return this->Coordinated_.get ();
}

SetMotionCoordinationType::Coordinated_type& SetMotionCoordinationType::
Coordinated ()
{
  return this->Coordinated_.get ();
}

void SetMotionCoordinationType::
Coordinated (const Coordinated_type& x)
{
  this->Coordinated_.set (x);
}


// SetRobotParametersType
// 

const SetRobotParametersType::ParameterSetting_sequence& SetRobotParametersType::
ParameterSetting () const
{
  return this->ParameterSetting_;
}

SetRobotParametersType::ParameterSetting_sequence& SetRobotParametersType::
ParameterSetting ()
{
  return this->ParameterSetting_;
}

void SetRobotParametersType::
ParameterSetting (const ParameterSetting_sequence& s)
{
  this->ParameterSetting_ = s;
}


// SetRotAccelType
// 

const SetRotAccelType::RotAccel_type& SetRotAccelType::
RotAccel () const
{
  return this->RotAccel_.get ();
}

SetRotAccelType::RotAccel_type& SetRotAccelType::
RotAccel ()
{
  return this->RotAccel_.get ();
}

void SetRotAccelType::
RotAccel (const RotAccel_type& x)
{
  this->RotAccel_.set (x);
}

void SetRotAccelType::
RotAccel (::std::auto_ptr< RotAccel_type > x)
{
  this->RotAccel_.set (x);
}


// SetRotSpeedType
// 

const SetRotSpeedType::RotSpeed_type& SetRotSpeedType::
RotSpeed () const
{
  return this->RotSpeed_.get ();
}

SetRotSpeedType::RotSpeed_type& SetRotSpeedType::
RotSpeed ()
{
  return this->RotSpeed_.get ();
}

void SetRotSpeedType::
RotSpeed (const RotSpeed_type& x)
{
  this->RotSpeed_.set (x);
}

void SetRotSpeedType::
RotSpeed (::std::auto_ptr< RotSpeed_type > x)
{
  this->RotSpeed_.set (x);
}


// SetTorqueUnitsType
// 

const SetTorqueUnitsType::UnitName_type& SetTorqueUnitsType::
UnitName () const
{
  return this->UnitName_.get ();
}

SetTorqueUnitsType::UnitName_type& SetTorqueUnitsType::
UnitName ()
{
  return this->UnitName_.get ();
}

void SetTorqueUnitsType::
UnitName (const UnitName_type& x)
{
  this->UnitName_.set (x);
}

void SetTorqueUnitsType::
UnitName (::std::auto_ptr< UnitName_type > x)
{
  this->UnitName_.set (x);
}


// SetTransAccelType
// 

const SetTransAccelType::TransAccel_type& SetTransAccelType::
TransAccel () const
{
  return this->TransAccel_.get ();
}

SetTransAccelType::TransAccel_type& SetTransAccelType::
TransAccel ()
{
  return this->TransAccel_.get ();
}

void SetTransAccelType::
TransAccel (const TransAccel_type& x)
{
  this->TransAccel_.set (x);
}

void SetTransAccelType::
TransAccel (::std::auto_ptr< TransAccel_type > x)
{
  this->TransAccel_.set (x);
}


// SetTransSpeedType
// 

const SetTransSpeedType::TransSpeed_type& SetTransSpeedType::
TransSpeed () const
{
  return this->TransSpeed_.get ();
}

SetTransSpeedType::TransSpeed_type& SetTransSpeedType::
TransSpeed ()
{
  return this->TransSpeed_.get ();
}

void SetTransSpeedType::
TransSpeed (const TransSpeed_type& x)
{
  this->TransSpeed_.set (x);
}

void SetTransSpeedType::
TransSpeed (::std::auto_ptr< TransSpeed_type > x)
{
  this->TransSpeed_.set (x);
}


// StopConditionEnumType
// 

StopConditionEnumType::
StopConditionEnumType (value v)
: ::xml_schema::token (_xsd_StopConditionEnumType_literals_[v])
{
}

StopConditionEnumType::
StopConditionEnumType (const char* v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const ::std::string& v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

StopConditionEnumType::
StopConditionEnumType (const StopConditionEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

StopConditionEnumType& StopConditionEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_StopConditionEnumType_literals_[v]);

  return *this;
}


// StopMotionType
// 

const StopMotionType::StopCondition_type& StopMotionType::
StopCondition () const
{
  return this->StopCondition_.get ();
}

StopMotionType::StopCondition_type& StopMotionType::
StopCondition ()
{
  return this->StopCondition_.get ();
}

void StopMotionType::
StopCondition (const StopCondition_type& x)
{
  this->StopCondition_.set (x);
}

void StopMotionType::
StopCondition (::std::auto_ptr< StopCondition_type > x)
{
  this->StopCondition_.set (x);
}


// TransAccelType
// 


// TransAccelAbsoluteType
// 

const TransAccelAbsoluteType::Setting_type& TransAccelAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

TransAccelAbsoluteType::Setting_type& TransAccelAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void TransAccelAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// TransAccelRelativeType
// 

const TransAccelRelativeType::Fraction_type& TransAccelRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

TransAccelRelativeType::Fraction_type& TransAccelRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void TransAccelRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void TransAccelRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// TransSpeedType
// 


// TransSpeedAbsoluteType
// 

const TransSpeedAbsoluteType::Setting_type& TransSpeedAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

TransSpeedAbsoluteType::Setting_type& TransSpeedAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void TransSpeedAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// TransSpeedRelativeType
// 

const TransSpeedRelativeType::Fraction_type& TransSpeedRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

TransSpeedRelativeType::Fraction_type& TransSpeedRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void TransSpeedRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void TransSpeedRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// CRCLCommandType
//

CRCLCommandType::
CRCLCommandType (const CommandID_type& CommandID)
: ::DataThingType (),
  CommandID_ (CommandID, this)
{
}

CRCLCommandType::
CRCLCommandType (const CRCLCommandType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandID_ (x.CommandID_, f, this)
{
}

CRCLCommandType::
CRCLCommandType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandID_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCLCommandType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandID
    //
    if (n.name () == "CommandID" && n.namespace_ ().empty ())
    {
      if (!CommandID_.present ())
      {
        this->CommandID_.set (CommandID_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!CommandID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandID",
      "");
  }
}

CRCLCommandType* CRCLCommandType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCLCommandType (*this, f, c);
}

CRCLCommandType& CRCLCommandType::
operator= (const CRCLCommandType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandID_ = x.CommandID_;
  }

  return *this;
}

CRCLCommandType::
~CRCLCommandType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CRCLCommandType >
_xsd_CRCLCommandType_type_factory_init (
  "CRCLCommandType",
  "");

// MiddleCommandType
//

MiddleCommandType::
MiddleCommandType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

MiddleCommandType::
MiddleCommandType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

MiddleCommandType::
MiddleCommandType (const MiddleCommandType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

MiddleCommandType::
MiddleCommandType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

MiddleCommandType* MiddleCommandType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MiddleCommandType (*this, f, c);
}

MiddleCommandType::
~MiddleCommandType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MiddleCommandType >
_xsd_MiddleCommandType_type_factory_init (
  "MiddleCommandType",
  "");

// ActuateJointsType
//

ActuateJointsType::
ActuateJointsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ActuateJoint_ (this)
{
}

ActuateJointsType::
ActuateJointsType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ActuateJoint_ (this)
{
}

ActuateJointsType::
ActuateJointsType (const ActuateJointsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ActuateJoint_ (x.ActuateJoint_, f, this)
{
}

ActuateJointsType::
ActuateJointsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ActuateJoint_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ActuateJointsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ActuateJoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ActuateJoint",
          "",
          &::xsd::cxx::tree::factory_impl< ActuateJoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ActuateJoint_type > r (
          dynamic_cast< ActuateJoint_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ActuateJoint_.push_back (r);
        continue;
      }
    }

    break;
  }
}

ActuateJointsType* ActuateJointsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActuateJointsType (*this, f, c);
}

ActuateJointsType& ActuateJointsType::
operator= (const ActuateJointsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ActuateJoint_ = x.ActuateJoint_;
  }

  return *this;
}

ActuateJointsType::
~ActuateJointsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActuateJointsType >
_xsd_ActuateJointsType_type_factory_init (
  "ActuateJointsType",
  "");

// ActuateJointType
//

ActuateJointType::
ActuateJointType (const JointNumber_type& JointNumber,
                  const JointPosition_type& JointPosition,
                  const JointDetails_type& JointDetails)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (JointPosition, this),
  JointDetails_ (JointDetails, this)
{
}

ActuateJointType::
ActuateJointType (const JointNumber_type& JointNumber,
                  const JointPosition_type& JointPosition,
                  ::std::auto_ptr< JointDetails_type > JointDetails)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (JointPosition, this),
  JointDetails_ (JointDetails, this)
{
}

ActuateJointType::
ActuateJointType (const ActuateJointType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointPosition_ (x.JointPosition_, f, this),
  JointDetails_ (x.JointDetails_, f, this)
{
}

ActuateJointType::
ActuateJointType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointPosition_ (this),
  JointDetails_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ActuateJointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointPosition
    //
    if (n.name () == "JointPosition" && n.namespace_ ().empty ())
    {
      if (!JointPosition_.present ())
      {
        this->JointPosition_.set (JointPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointDetails
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointDetails",
          "",
          &::xsd::cxx::tree::factory_impl< JointDetails_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!JointDetails_.present ())
        {
          ::std::auto_ptr< JointDetails_type > r (
            dynamic_cast< JointDetails_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointDetails_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }

  if (!JointPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointPosition",
      "");
  }

  if (!JointDetails_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointDetails",
      "");
  }
}

ActuateJointType* ActuateJointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActuateJointType (*this, f, c);
}

ActuateJointType& ActuateJointType::
operator= (const ActuateJointType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointPosition_ = x.JointPosition_;
    this->JointDetails_ = x.JointDetails_;
  }

  return *this;
}

ActuateJointType::
~ActuateJointType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActuateJointType >
_xsd_ActuateJointType_type_factory_init (
  "ActuateJointType",
  "");

// CloseToolChangerType
//

CloseToolChangerType::
CloseToolChangerType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

CloseToolChangerType::
CloseToolChangerType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

CloseToolChangerType::
CloseToolChangerType (const CloseToolChangerType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

CloseToolChangerType::
CloseToolChangerType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

CloseToolChangerType* CloseToolChangerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CloseToolChangerType (*this, f, c);
}

CloseToolChangerType::
~CloseToolChangerType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CloseToolChangerType >
_xsd_CloseToolChangerType_type_factory_init (
  "CloseToolChangerType",
  "");

// ConfigureJointReportsType
//

ConfigureJointReportsType::
ConfigureJointReportsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                           const ResetAll_type& ResetAll)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ResetAll_ (ResetAll, this),
  ConfigureJointReport_ (this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const CommandID_type& CommandID,
                           const ResetAll_type& ResetAll)
: ::MiddleCommandType (CommandID),
  ResetAll_ (ResetAll, this),
  ConfigureJointReport_ (this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const ConfigureJointReportsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ResetAll_ (x.ResetAll_, f, this),
  ConfigureJointReport_ (x.ConfigureJointReport_, f, this)
{
}

ConfigureJointReportsType::
ConfigureJointReportsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ResetAll_ (this),
  ConfigureJointReport_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConfigureJointReportsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ResetAll
    //
    if (n.name () == "ResetAll" && n.namespace_ ().empty ())
    {
      if (!ResetAll_.present ())
      {
        this->ResetAll_.set (ResetAll_traits::create (i, f, this));
        continue;
      }
    }

    // ConfigureJointReport
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ConfigureJointReport",
          "",
          &::xsd::cxx::tree::factory_impl< ConfigureJointReport_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ConfigureJointReport_type > r (
          dynamic_cast< ConfigureJointReport_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ConfigureJointReport_.push_back (r);
        continue;
      }
    }

    break;
  }

  if (!ResetAll_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ResetAll",
      "");
  }
}

ConfigureJointReportsType* ConfigureJointReportsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConfigureJointReportsType (*this, f, c);
}

ConfigureJointReportsType& ConfigureJointReportsType::
operator= (const ConfigureJointReportsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ResetAll_ = x.ResetAll_;
    this->ConfigureJointReport_ = x.ConfigureJointReport_;
  }

  return *this;
}

ConfigureJointReportsType::
~ConfigureJointReportsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConfigureJointReportsType >
_xsd_ConfigureJointReportsType_type_factory_init (
  "ConfigureJointReportsType",
  "");

// ConfigureJointReportType
//

ConfigureJointReportType::
ConfigureJointReportType (const JointNumber_type& JointNumber,
                          const ReportPosition_type& ReportPosition,
                          const ReportTorqueOrForce_type& ReportTorqueOrForce,
                          const ReportVelocity_type& ReportVelocity)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  ReportPosition_ (ReportPosition, this),
  ReportTorqueOrForce_ (ReportTorqueOrForce, this),
  ReportVelocity_ (ReportVelocity, this)
{
}

ConfigureJointReportType::
ConfigureJointReportType (const ConfigureJointReportType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  ReportPosition_ (x.ReportPosition_, f, this),
  ReportTorqueOrForce_ (x.ReportTorqueOrForce_, f, this),
  ReportVelocity_ (x.ReportVelocity_, f, this)
{
}

ConfigureJointReportType::
ConfigureJointReportType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  ReportPosition_ (this),
  ReportTorqueOrForce_ (this),
  ReportVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConfigureJointReportType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // ReportPosition
    //
    if (n.name () == "ReportPosition" && n.namespace_ ().empty ())
    {
      if (!ReportPosition_.present ())
      {
        this->ReportPosition_.set (ReportPosition_traits::create (i, f, this));
        continue;
      }
    }

    // ReportTorqueOrForce
    //
    if (n.name () == "ReportTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!ReportTorqueOrForce_.present ())
      {
        this->ReportTorqueOrForce_.set (ReportTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // ReportVelocity
    //
    if (n.name () == "ReportVelocity" && n.namespace_ ().empty ())
    {
      if (!ReportVelocity_.present ())
      {
        this->ReportVelocity_.set (ReportVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }

  if (!ReportPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportPosition",
      "");
  }

  if (!ReportTorqueOrForce_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportTorqueOrForce",
      "");
  }

  if (!ReportVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReportVelocity",
      "");
  }
}

ConfigureJointReportType* ConfigureJointReportType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConfigureJointReportType (*this, f, c);
}

ConfigureJointReportType& ConfigureJointReportType::
operator= (const ConfigureJointReportType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->ReportPosition_ = x.ReportPosition_;
    this->ReportTorqueOrForce_ = x.ReportTorqueOrForce_;
    this->ReportVelocity_ = x.ReportVelocity_;
  }

  return *this;
}

ConfigureJointReportType::
~ConfigureJointReportType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConfigureJointReportType >
_xsd_ConfigureJointReportType_type_factory_init (
  "ConfigureJointReportType",
  "");

// DwellType
//

DwellType::
DwellType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
           const DwellTime_type& DwellTime)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  DwellTime_ (DwellTime, this)
{
}

DwellType::
DwellType (const CommandID_type& CommandID,
           const DwellTime_type& DwellTime)
: ::MiddleCommandType (CommandID),
  DwellTime_ (DwellTime, this)
{
}

DwellType::
DwellType (const DwellType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  DwellTime_ (x.DwellTime_, f, this)
{
}

DwellType::
DwellType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  DwellTime_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DwellType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DwellTime
    //
    if (n.name () == "DwellTime" && n.namespace_ ().empty ())
    {
      if (!DwellTime_.present ())
      {
        this->DwellTime_.set (DwellTime_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!DwellTime_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DwellTime",
      "");
  }
}

DwellType* DwellType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DwellType (*this, f, c);
}

DwellType& DwellType::
operator= (const DwellType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->DwellTime_ = x.DwellTime_;
  }

  return *this;
}

DwellType::
~DwellType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DwellType >
_xsd_DwellType_type_factory_init (
  "DwellType",
  "");

// EndCanonType
//

EndCanonType::
EndCanonType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

EndCanonType::
EndCanonType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

EndCanonType::
EndCanonType (const EndCanonType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

EndCanonType::
EndCanonType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

EndCanonType* EndCanonType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EndCanonType (*this, f, c);
}

EndCanonType::
~EndCanonType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, EndCanonType >
_xsd_EndCanonType_type_factory_init (
  "EndCanonType",
  "");

// GetStatusType
//

GetStatusType::
GetStatusType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

GetStatusType::
GetStatusType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

GetStatusType::
GetStatusType (const GetStatusType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

GetStatusType::
GetStatusType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

GetStatusType* GetStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GetStatusType (*this, f, c);
}

GetStatusType::
~GetStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GetStatusType >
_xsd_GetStatusType_type_factory_init (
  "GetStatusType",
  "");

// InitCanonType
//

InitCanonType::
InitCanonType (const ::CRCLCommandType& _xsd_CRCLCommandType_base)
: ::CRCLCommandType (_xsd_CRCLCommandType_base)
{
}

InitCanonType::
InitCanonType (const CommandID_type& CommandID)
: ::CRCLCommandType (CommandID)
{
}

InitCanonType::
InitCanonType (const InitCanonType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CRCLCommandType (x, f, c)
{
}

InitCanonType::
InitCanonType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CRCLCommandType (e, f, c)
{
}

InitCanonType* InitCanonType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InitCanonType (*this, f, c);
}

InitCanonType::
~InitCanonType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, InitCanonType >
_xsd_InitCanonType_type_factory_init (
  "InitCanonType",
  "");

// JointDetailsType
//

JointDetailsType::
JointDetailsType ()
: ::DataThingType ()
{
}

JointDetailsType::
JointDetailsType (const JointDetailsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

JointDetailsType::
JointDetailsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

JointDetailsType* JointDetailsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointDetailsType (*this, f, c);
}

JointDetailsType::
~JointDetailsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointDetailsType >
_xsd_JointDetailsType_type_factory_init (
  "JointDetailsType",
  "");

// JointForceTorqueType
//

JointForceTorqueType::
JointForceTorqueType ()
: ::JointDetailsType (),
  Setting_ (this),
  ChangeRate_ (this)
{
}

JointForceTorqueType::
JointForceTorqueType (const JointForceTorqueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::JointDetailsType (x, f, c),
  Setting_ (x.Setting_, f, this),
  ChangeRate_ (x.ChangeRate_, f, this)
{
}

JointForceTorqueType::
JointForceTorqueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::JointDetailsType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this),
  ChangeRate_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointForceTorqueType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::JointDetailsType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!this->Setting_)
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    // ChangeRate
    //
    if (n.name () == "ChangeRate" && n.namespace_ ().empty ())
    {
      if (!this->ChangeRate_)
      {
        this->ChangeRate_.set (ChangeRate_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

JointForceTorqueType* JointForceTorqueType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointForceTorqueType (*this, f, c);
}

JointForceTorqueType& JointForceTorqueType::
operator= (const JointForceTorqueType& x)
{
  if (this != &x)
  {
    static_cast< ::JointDetailsType& > (*this) = x;
    this->Setting_ = x.Setting_;
    this->ChangeRate_ = x.ChangeRate_;
  }

  return *this;
}

JointForceTorqueType::
~JointForceTorqueType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointForceTorqueType >
_xsd_JointForceTorqueType_type_factory_init (
  "JointForceTorqueType",
  "");

// JointSpeedAccelType
//

JointSpeedAccelType::
JointSpeedAccelType ()
: ::JointDetailsType (),
  JointSpeed_ (this),
  JointAccel_ (this)
{
}

JointSpeedAccelType::
JointSpeedAccelType (const JointSpeedAccelType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::JointDetailsType (x, f, c),
  JointSpeed_ (x.JointSpeed_, f, this),
  JointAccel_ (x.JointAccel_, f, this)
{
}

JointSpeedAccelType::
JointSpeedAccelType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::JointDetailsType (e, f | ::xml_schema::flags::base, c),
  JointSpeed_ (this),
  JointAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointSpeedAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::JointDetailsType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointSpeed
    //
    if (n.name () == "JointSpeed" && n.namespace_ ().empty ())
    {
      if (!this->JointSpeed_)
      {
        this->JointSpeed_.set (JointSpeed_traits::create (i, f, this));
        continue;
      }
    }

    // JointAccel
    //
    if (n.name () == "JointAccel" && n.namespace_ ().empty ())
    {
      if (!this->JointAccel_)
      {
        this->JointAccel_.set (JointAccel_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

JointSpeedAccelType* JointSpeedAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointSpeedAccelType (*this, f, c);
}

JointSpeedAccelType& JointSpeedAccelType::
operator= (const JointSpeedAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::JointDetailsType& > (*this) = x;
    this->JointSpeed_ = x.JointSpeed_;
    this->JointAccel_ = x.JointAccel_;
  }

  return *this;
}

JointSpeedAccelType::
~JointSpeedAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointSpeedAccelType >
_xsd_JointSpeedAccelType_type_factory_init (
  "JointSpeedAccelType",
  "");

// MessageType
//

MessageType::
MessageType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
             const Message_type& Message)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
             ::std::auto_ptr< Message_type > Message)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const CommandID_type& CommandID,
             const Message_type& Message)
: ::MiddleCommandType (CommandID),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const CommandID_type& CommandID,
             ::std::auto_ptr< Message_type > Message)
: ::MiddleCommandType (CommandID),
  Message_ (Message, this)
{
}

MessageType::
MessageType (const MessageType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Message_ (x.Message_, f, this)
{
}

MessageType::
MessageType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Message_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Message
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Message",
          "",
          &::xsd::cxx::tree::factory_impl< Message_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Message_.present ())
        {
          ::std::auto_ptr< Message_type > r (
            dynamic_cast< Message_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Message_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Message_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Message",
      "");
  }
}

MessageType* MessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MessageType (*this, f, c);
}

MessageType& MessageType::
operator= (const MessageType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Message_ = x.Message_;
  }

  return *this;
}

MessageType::
~MessageType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MessageType >
_xsd_MessageType_type_factory_init (
  "MessageType",
  "");

// MoveScrewType
//

MoveScrewType::
MoveScrewType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
               const AxialDistanceScrew_type& AxialDistanceScrew,
               const Turn_type& Turn)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (AxialDistanceScrew, this),
  Turn_ (Turn, this)
{
}

MoveScrewType::
MoveScrewType (const CommandID_type& CommandID,
               const AxialDistanceScrew_type& AxialDistanceScrew,
               const Turn_type& Turn)
: ::MiddleCommandType (CommandID),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (AxialDistanceScrew, this),
  Turn_ (Turn, this)
{
}

MoveScrewType::
MoveScrewType (const MoveScrewType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  StartPosition_ (x.StartPosition_, f, this),
  AxisPoint_ (x.AxisPoint_, f, this),
  AxialDistanceFree_ (x.AxialDistanceFree_, f, this),
  AxialDistanceScrew_ (x.AxialDistanceScrew_, f, this),
  Turn_ (x.Turn_, f, this)
{
}

MoveScrewType::
MoveScrewType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  StartPosition_ (this),
  AxisPoint_ (this),
  AxialDistanceFree_ (this),
  AxialDistanceScrew_ (this),
  Turn_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveScrewType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // StartPosition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StartPosition",
          "",
          &::xsd::cxx::tree::factory_impl< StartPosition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->StartPosition_)
        {
          ::std::auto_ptr< StartPosition_type > r (
            dynamic_cast< StartPosition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StartPosition_.set (r);
          continue;
        }
      }
    }

    // AxisPoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AxisPoint",
          "",
          &::xsd::cxx::tree::factory_impl< AxisPoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AxisPoint_)
        {
          ::std::auto_ptr< AxisPoint_type > r (
            dynamic_cast< AxisPoint_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AxisPoint_.set (r);
          continue;
        }
      }
    }

    // AxialDistanceFree
    //
    if (n.name () == "AxialDistanceFree" && n.namespace_ ().empty ())
    {
      if (!this->AxialDistanceFree_)
      {
        this->AxialDistanceFree_.set (AxialDistanceFree_traits::create (i, f, this));
        continue;
      }
    }

    // AxialDistanceScrew
    //
    if (n.name () == "AxialDistanceScrew" && n.namespace_ ().empty ())
    {
      if (!AxialDistanceScrew_.present ())
      {
        this->AxialDistanceScrew_.set (AxialDistanceScrew_traits::create (i, f, this));
        continue;
      }
    }

    // Turn
    //
    if (n.name () == "Turn" && n.namespace_ ().empty ())
    {
      if (!Turn_.present ())
      {
        this->Turn_.set (Turn_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!AxialDistanceScrew_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AxialDistanceScrew",
      "");
  }

  if (!Turn_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Turn",
      "");
  }
}

MoveScrewType* MoveScrewType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveScrewType (*this, f, c);
}

MoveScrewType& MoveScrewType::
operator= (const MoveScrewType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->StartPosition_ = x.StartPosition_;
    this->AxisPoint_ = x.AxisPoint_;
    this->AxialDistanceFree_ = x.AxialDistanceFree_;
    this->AxialDistanceScrew_ = x.AxialDistanceScrew_;
    this->Turn_ = x.Turn_;
  }

  return *this;
}

MoveScrewType::
~MoveScrewType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveScrewType >
_xsd_MoveScrewType_type_factory_init (
  "MoveScrewType",
  "");

// MoveThroughToType
//

MoveThroughToType::
MoveThroughToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const MoveStraight_type& MoveStraight,
                   const NumPositions_type& NumPositions)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  Waypoint_ (this),
  NumPositions_ (NumPositions, this)
{
}

MoveThroughToType::
MoveThroughToType (const CommandID_type& CommandID,
                   const MoveStraight_type& MoveStraight,
                   const NumPositions_type& NumPositions)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  Waypoint_ (this),
  NumPositions_ (NumPositions, this)
{
}

MoveThroughToType::
MoveThroughToType (const MoveThroughToType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  MoveStraight_ (x.MoveStraight_, f, this),
  Waypoint_ (x.Waypoint_, f, this),
  NumPositions_ (x.NumPositions_, f, this)
{
}

MoveThroughToType::
MoveThroughToType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  MoveStraight_ (this),
  Waypoint_ (this),
  NumPositions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveThroughToType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MoveStraight
    //
    if (n.name () == "MoveStraight" && n.namespace_ ().empty ())
    {
      if (!MoveStraight_.present ())
      {
        this->MoveStraight_.set (MoveStraight_traits::create (i, f, this));
        continue;
      }
    }

    // Waypoint
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Waypoint",
          "",
          &::xsd::cxx::tree::factory_impl< Waypoint_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Waypoint_type > r (
          dynamic_cast< Waypoint_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Waypoint_.push_back (r);
        continue;
      }
    }

    // NumPositions
    //
    if (n.name () == "NumPositions" && n.namespace_ ().empty ())
    {
      if (!NumPositions_.present ())
      {
        this->NumPositions_.set (NumPositions_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!MoveStraight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MoveStraight",
      "");
  }

  if (!NumPositions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NumPositions",
      "");
  }
}

MoveThroughToType* MoveThroughToType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveThroughToType (*this, f, c);
}

MoveThroughToType& MoveThroughToType::
operator= (const MoveThroughToType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->MoveStraight_ = x.MoveStraight_;
    this->Waypoint_ = x.Waypoint_;
    this->NumPositions_ = x.NumPositions_;
  }

  return *this;
}

MoveThroughToType::
~MoveThroughToType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveThroughToType >
_xsd_MoveThroughToType_type_factory_init (
  "MoveThroughToType",
  "");

// MoveToType
//

MoveToType::
MoveToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
            const MoveStraight_type& MoveStraight,
            const EndPosition_type& EndPosition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
            const MoveStraight_type& MoveStraight,
            ::std::auto_ptr< EndPosition_type > EndPosition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const CommandID_type& CommandID,
            const MoveStraight_type& MoveStraight,
            const EndPosition_type& EndPosition)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const CommandID_type& CommandID,
            const MoveStraight_type& MoveStraight,
            ::std::auto_ptr< EndPosition_type > EndPosition)
: ::MiddleCommandType (CommandID),
  MoveStraight_ (MoveStraight, this),
  EndPosition_ (EndPosition, this)
{
}

MoveToType::
MoveToType (const MoveToType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  MoveStraight_ (x.MoveStraight_, f, this),
  EndPosition_ (x.EndPosition_, f, this)
{
}

MoveToType::
MoveToType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  MoveStraight_ (this),
  EndPosition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveToType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MoveStraight
    //
    if (n.name () == "MoveStraight" && n.namespace_ ().empty ())
    {
      if (!MoveStraight_.present ())
      {
        this->MoveStraight_.set (MoveStraight_traits::create (i, f, this));
        continue;
      }
    }

    // EndPosition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndPosition",
          "",
          &::xsd::cxx::tree::factory_impl< EndPosition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!EndPosition_.present ())
        {
          ::std::auto_ptr< EndPosition_type > r (
            dynamic_cast< EndPosition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EndPosition_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!MoveStraight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MoveStraight",
      "");
  }

  if (!EndPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EndPosition",
      "");
  }
}

MoveToType* MoveToType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveToType (*this, f, c);
}

MoveToType& MoveToType::
operator= (const MoveToType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->MoveStraight_ = x.MoveStraight_;
    this->EndPosition_ = x.EndPosition_;
  }

  return *this;
}

MoveToType::
~MoveToType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, MoveToType >
_xsd_MoveToType_type_factory_init (
  "MoveToType",
  "");

// OpenToolChangerType
//

OpenToolChangerType::
OpenToolChangerType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base)
{
}

OpenToolChangerType::
OpenToolChangerType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID)
{
}

OpenToolChangerType::
OpenToolChangerType (const OpenToolChangerType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c)
{
}

OpenToolChangerType::
OpenToolChangerType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::MiddleCommandType (e, f, c)
{
}

OpenToolChangerType* OpenToolChangerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OpenToolChangerType (*this, f, c);
}

OpenToolChangerType::
~OpenToolChangerType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, OpenToolChangerType >
_xsd_OpenToolChangerType_type_factory_init (
  "OpenToolChangerType",
  "");

// ParameterSettingType
//

ParameterSettingType::
ParameterSettingType (const ParameterName_type& ParameterName,
                      const ParameterValue_type& ParameterValue)
: ::DataThingType (),
  ParameterName_ (ParameterName, this),
  ParameterValue_ (ParameterValue, this)
{
}

ParameterSettingType::
ParameterSettingType (::std::auto_ptr< ParameterName_type > ParameterName,
                      ::std::auto_ptr< ParameterValue_type > ParameterValue)
: ::DataThingType (),
  ParameterName_ (ParameterName, this),
  ParameterValue_ (ParameterValue, this)
{
}

ParameterSettingType::
ParameterSettingType (const ParameterSettingType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  ParameterName_ (x.ParameterName_, f, this),
  ParameterValue_ (x.ParameterValue_, f, this)
{
}

ParameterSettingType::
ParameterSettingType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  ParameterName_ (this),
  ParameterValue_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParameterSettingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterName",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ParameterName_.present ())
        {
          ::std::auto_ptr< ParameterName_type > r (
            dynamic_cast< ParameterName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ParameterName_.set (r);
          continue;
        }
      }
    }

    // ParameterValue
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterValue",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterValue_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ParameterValue_.present ())
        {
          ::std::auto_ptr< ParameterValue_type > r (
            dynamic_cast< ParameterValue_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ParameterValue_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!ParameterName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ParameterName",
      "");
  }

  if (!ParameterValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ParameterValue",
      "");
  }
}

ParameterSettingType* ParameterSettingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParameterSettingType (*this, f, c);
}

ParameterSettingType& ParameterSettingType::
operator= (const ParameterSettingType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->ParameterName_ = x.ParameterName_;
    this->ParameterValue_ = x.ParameterValue_;
  }

  return *this;
}

ParameterSettingType::
~ParameterSettingType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParameterSettingType >
_xsd_ParameterSettingType_type_factory_init (
  "ParameterSettingType",
  "");

// PoseAndSetType
//

PoseAndSetType::
PoseAndSetType (const ::PoseType& _xsd_PoseType_base,
                const Coordinated_type& Coordinated)
: ::PoseType (_xsd_PoseType_base),
  Coordinated_ (Coordinated, this),
  TransSpeed_ (this),
  RotSpeed_ (this),
  TransAccel_ (this),
  RotAccel_ (this),
  Tolerance_ (this)
{
}

PoseAndSetType::
PoseAndSetType (const Point_type& Point,
                const XAxis_type& XAxis,
                const ZAxis_type& ZAxis,
                const Coordinated_type& Coordinated)
: ::PoseType (Point,
              XAxis,
              ZAxis),
  Coordinated_ (Coordinated, this),
  TransSpeed_ (this),
  RotSpeed_ (this),
  TransAccel_ (this),
  RotAccel_ (this),
  Tolerance_ (this)
{
}

PoseAndSetType::
PoseAndSetType (::std::auto_ptr< Point_type > Point,
                ::std::auto_ptr< XAxis_type > XAxis,
                ::std::auto_ptr< ZAxis_type > ZAxis,
                const Coordinated_type& Coordinated)
: ::PoseType (Point,
              XAxis,
              ZAxis),
  Coordinated_ (Coordinated, this),
  TransSpeed_ (this),
  RotSpeed_ (this),
  TransAccel_ (this),
  RotAccel_ (this),
  Tolerance_ (this)
{
}

PoseAndSetType::
PoseAndSetType (const PoseAndSetType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::PoseType (x, f, c),
  Coordinated_ (x.Coordinated_, f, this),
  TransSpeed_ (x.TransSpeed_, f, this),
  RotSpeed_ (x.RotSpeed_, f, this),
  TransAccel_ (x.TransAccel_, f, this),
  RotAccel_ (x.RotAccel_, f, this),
  Tolerance_ (x.Tolerance_, f, this)
{
}

PoseAndSetType::
PoseAndSetType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::PoseType (e, f | ::xml_schema::flags::base, c),
  Coordinated_ (this),
  TransSpeed_ (this),
  RotSpeed_ (this),
  TransAccel_ (this),
  RotAccel_ (this),
  Tolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseAndSetType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::PoseType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinated
    //
    if (n.name () == "Coordinated" && n.namespace_ ().empty ())
    {
      if (!Coordinated_.present ())
      {
        this->Coordinated_.set (Coordinated_traits::create (i, f, this));
        continue;
      }
    }

    // TransSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransSpeed_)
        {
          ::std::auto_ptr< TransSpeed_type > r (
            dynamic_cast< TransSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeed_.set (r);
          continue;
        }
      }
    }

    // RotSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotSpeed_)
        {
          ::std::auto_ptr< RotSpeed_type > r (
            dynamic_cast< RotSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeed_.set (r);
          continue;
        }
      }
    }

    // TransAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccel",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransAccel_)
        {
          ::std::auto_ptr< TransAccel_type > r (
            dynamic_cast< TransAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccel_.set (r);
          continue;
        }
      }
    }

    // RotAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccel",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotAccel_)
        {
          ::std::auto_ptr< RotAccel_type > r (
            dynamic_cast< RotAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccel_.set (r);
          continue;
        }
      }
    }

    // Tolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Tolerance",
          "",
          &::xsd::cxx::tree::factory_impl< Tolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Tolerance_)
        {
          ::std::auto_ptr< Tolerance_type > r (
            dynamic_cast< Tolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Tolerance_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Coordinated_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Coordinated",
      "");
  }
}

PoseAndSetType* PoseAndSetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseAndSetType (*this, f, c);
}

PoseAndSetType& PoseAndSetType::
operator= (const PoseAndSetType& x)
{
  if (this != &x)
  {
    static_cast< ::PoseType& > (*this) = x;
    this->Coordinated_ = x.Coordinated_;
    this->TransSpeed_ = x.TransSpeed_;
    this->RotSpeed_ = x.RotSpeed_;
    this->TransAccel_ = x.TransAccel_;
    this->RotAccel_ = x.RotAccel_;
    this->Tolerance_ = x.Tolerance_;
  }

  return *this;
}

PoseAndSetType::
~PoseAndSetType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseAndSetType >
_xsd_PoseAndSetType_type_factory_init (
  "PoseAndSetType",
  "");

// PoseToleranceType
//

PoseToleranceType::
PoseToleranceType ()
: ::DataThingType (),
  XPointTolerance_ (this),
  YPointTolerance_ (this),
  ZPointTolerance_ (this),
  XAxisTolerance_ (this),
  ZAxisTolerance_ (this)
{
}

PoseToleranceType::
PoseToleranceType (const PoseToleranceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  XPointTolerance_ (x.XPointTolerance_, f, this),
  YPointTolerance_ (x.YPointTolerance_, f, this),
  ZPointTolerance_ (x.ZPointTolerance_, f, this),
  XAxisTolerance_ (x.XAxisTolerance_, f, this),
  ZAxisTolerance_ (x.ZAxisTolerance_, f, this)
{
}

PoseToleranceType::
PoseToleranceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  XPointTolerance_ (this),
  YPointTolerance_ (this),
  ZPointTolerance_ (this),
  XAxisTolerance_ (this),
  ZAxisTolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // XPointTolerance
    //
    if (n.name () == "XPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->XPointTolerance_)
      {
        this->XPointTolerance_.set (XPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // YPointTolerance
    //
    if (n.name () == "YPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->YPointTolerance_)
      {
        this->YPointTolerance_.set (YPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // ZPointTolerance
    //
    if (n.name () == "ZPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->ZPointTolerance_)
      {
        this->ZPointTolerance_.set (ZPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // XAxisTolerance
    //
    if (n.name () == "XAxisTolerance" && n.namespace_ ().empty ())
    {
      if (!this->XAxisTolerance_)
      {
        this->XAxisTolerance_.set (XAxisTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // ZAxisTolerance
    //
    if (n.name () == "ZAxisTolerance" && n.namespace_ ().empty ())
    {
      if (!this->ZAxisTolerance_)
      {
        this->ZAxisTolerance_.set (ZAxisTolerance_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

PoseToleranceType* PoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseToleranceType (*this, f, c);
}

PoseToleranceType& PoseToleranceType::
operator= (const PoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->XPointTolerance_ = x.XPointTolerance_;
    this->YPointTolerance_ = x.YPointTolerance_;
    this->ZPointTolerance_ = x.ZPointTolerance_;
    this->XAxisTolerance_ = x.XAxisTolerance_;
    this->ZAxisTolerance_ = x.ZAxisTolerance_;
  }

  return *this;
}

PoseToleranceType::
~PoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseToleranceType >
_xsd_PoseToleranceType_type_factory_init (
  "PoseToleranceType",
  "");

// RotAccelType
//

RotAccelType::
RotAccelType ()
: ::DataThingType ()
{
}

RotAccelType::
RotAccelType (const RotAccelType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

RotAccelType::
RotAccelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

RotAccelType* RotAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelType (*this, f, c);
}

RotAccelType::
~RotAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelType >
_xsd_RotAccelType_type_factory_init (
  "RotAccelType",
  "");

// RotAccelAbsoluteType
//

RotAccelAbsoluteType::
RotAccelAbsoluteType (const Setting_type& Setting)
: ::RotAccelType (),
  Setting_ (Setting, this)
{
}

RotAccelAbsoluteType::
RotAccelAbsoluteType (const RotAccelAbsoluteType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

RotAccelAbsoluteType::
RotAccelAbsoluteType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotAccelAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

RotAccelAbsoluteType* RotAccelAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelAbsoluteType (*this, f, c);
}

RotAccelAbsoluteType& RotAccelAbsoluteType::
operator= (const RotAccelAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::RotAccelType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

RotAccelAbsoluteType::
~RotAccelAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelAbsoluteType >
_xsd_RotAccelAbsoluteType_type_factory_init (
  "RotAccelAbsoluteType",
  "");

// RotAccelRelativeType
//

RotAccelRelativeType::
RotAccelRelativeType (const Fraction_type& Fraction)
: ::RotAccelType (),
  Fraction_ (Fraction, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::RotAccelType (),
  Fraction_ (Fraction, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (const RotAccelRelativeType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotAccelRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

RotAccelRelativeType* RotAccelRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelRelativeType (*this, f, c);
}

RotAccelRelativeType& RotAccelRelativeType::
operator= (const RotAccelRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::RotAccelType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

RotAccelRelativeType::
~RotAccelRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelRelativeType >
_xsd_RotAccelRelativeType_type_factory_init (
  "RotAccelRelativeType",
  "");

// RotSpeedType
//

RotSpeedType::
RotSpeedType ()
: ::DataThingType ()
{
}

RotSpeedType::
RotSpeedType (const RotSpeedType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

RotSpeedType::
RotSpeedType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

RotSpeedType* RotSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedType (*this, f, c);
}

RotSpeedType::
~RotSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedType >
_xsd_RotSpeedType_type_factory_init (
  "RotSpeedType",
  "");

// RotSpeedAbsoluteType
//

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const Setting_type& Setting)
: ::RotSpeedType (),
  Setting_ (Setting, this)
{
}

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const RotSpeedAbsoluteType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotSpeedAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

RotSpeedAbsoluteType* RotSpeedAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedAbsoluteType (*this, f, c);
}

RotSpeedAbsoluteType& RotSpeedAbsoluteType::
operator= (const RotSpeedAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::RotSpeedType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

RotSpeedAbsoluteType::
~RotSpeedAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedAbsoluteType >
_xsd_RotSpeedAbsoluteType_type_factory_init (
  "RotSpeedAbsoluteType",
  "");

// RotSpeedRelativeType
//

RotSpeedRelativeType::
RotSpeedRelativeType (const Fraction_type& Fraction)
: ::RotSpeedType (),
  Fraction_ (Fraction, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::RotSpeedType (),
  Fraction_ (Fraction, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (const RotSpeedRelativeType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotSpeedRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

RotSpeedRelativeType* RotSpeedRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedRelativeType (*this, f, c);
}

RotSpeedRelativeType& RotSpeedRelativeType::
operator= (const RotSpeedRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::RotSpeedType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

RotSpeedRelativeType::
~RotSpeedRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedRelativeType >
_xsd_RotSpeedRelativeType_type_factory_init (
  "RotSpeedRelativeType",
  "");

// RunProgramType
//

RunProgramType::
RunProgramType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                const ProgramText_type& ProgramText)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                ::std::auto_ptr< ProgramText_type > ProgramText)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const CommandID_type& CommandID,
                const ProgramText_type& ProgramText)
: ::MiddleCommandType (CommandID),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const CommandID_type& CommandID,
                ::std::auto_ptr< ProgramText_type > ProgramText)
: ::MiddleCommandType (CommandID),
  ProgramText_ (ProgramText, this)
{
}

RunProgramType::
RunProgramType (const RunProgramType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ProgramText_ (x.ProgramText_, f, this)
{
}

RunProgramType::
RunProgramType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ProgramText_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RunProgramType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ProgramText
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProgramText",
          "",
          &::xsd::cxx::tree::factory_impl< ProgramText_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ProgramText_.present ())
        {
          ::std::auto_ptr< ProgramText_type > r (
            dynamic_cast< ProgramText_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProgramText_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!ProgramText_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ProgramText",
      "");
  }
}

RunProgramType* RunProgramType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RunProgramType (*this, f, c);
}

RunProgramType& RunProgramType::
operator= (const RunProgramType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ProgramText_ = x.ProgramText_;
  }

  return *this;
}

RunProgramType::
~RunProgramType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunProgramType >
_xsd_RunProgramType_type_factory_init (
  "RunProgramType",
  "");

// SetAngleUnitsType
//

SetAngleUnitsType::
SetAngleUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const CommandID_type& CommandID,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const CommandID_type& CommandID,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const SetAngleUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetAngleUnitsType::
SetAngleUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetAngleUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetAngleUnitsType* SetAngleUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetAngleUnitsType (*this, f, c);
}

SetAngleUnitsType& SetAngleUnitsType::
operator= (const SetAngleUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetAngleUnitsType::
~SetAngleUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetAngleUnitsType >
_xsd_SetAngleUnitsType_type_factory_init (
  "SetAngleUnitsType",
  "");

// SetEndEffectorParametersType
//

SetEndEffectorParametersType::
SetEndEffectorParametersType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ParameterSetting_ (this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ParameterSetting_ (this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const SetEndEffectorParametersType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ParameterSetting_ (x.ParameterSetting_, f, this)
{
}

SetEndEffectorParametersType::
SetEndEffectorParametersType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ParameterSetting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndEffectorParametersType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ParameterSetting_type > r (
          dynamic_cast< ParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ParameterSetting_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SetEndEffectorParametersType* SetEndEffectorParametersType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndEffectorParametersType (*this, f, c);
}

SetEndEffectorParametersType& SetEndEffectorParametersType::
operator= (const SetEndEffectorParametersType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ParameterSetting_ = x.ParameterSetting_;
  }

  return *this;
}

SetEndEffectorParametersType::
~SetEndEffectorParametersType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndEffectorParametersType >
_xsd_SetEndEffectorParametersType_type_factory_init (
  "SetEndEffectorParametersType",
  "");

// SetEndEffectorType
//

SetEndEffectorType::
SetEndEffectorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const Setting_type& Setting)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< Setting_type > Setting)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const CommandID_type& CommandID,
                    const Setting_type& Setting)
: ::MiddleCommandType (CommandID),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const CommandID_type& CommandID,
                    ::std::auto_ptr< Setting_type > Setting)
: ::MiddleCommandType (CommandID),
  Setting_ (Setting, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const SetEndEffectorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

SetEndEffectorType::
SetEndEffectorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndEffectorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Setting",
          "",
          &::xsd::cxx::tree::factory_impl< Setting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Setting_.present ())
        {
          ::std::auto_ptr< Setting_type > r (
            dynamic_cast< Setting_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Setting_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

SetEndEffectorType* SetEndEffectorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndEffectorType (*this, f, c);
}

SetEndEffectorType& SetEndEffectorType::
operator= (const SetEndEffectorType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

SetEndEffectorType::
~SetEndEffectorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndEffectorType >
_xsd_SetEndEffectorType_type_factory_init (
  "SetEndEffectorType",
  "");

// SetEndPoseToleranceType
//

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                         const Tolerance_type& Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                         ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const CommandID_type& CommandID,
                         const Tolerance_type& Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const CommandID_type& CommandID,
                         ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const SetEndPoseToleranceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Tolerance_ (x.Tolerance_, f, this)
{
}

SetEndPoseToleranceType::
SetEndPoseToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Tolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetEndPoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Tolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Tolerance",
          "",
          &::xsd::cxx::tree::factory_impl< Tolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Tolerance_.present ())
        {
          ::std::auto_ptr< Tolerance_type > r (
            dynamic_cast< Tolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Tolerance_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Tolerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tolerance",
      "");
  }
}

SetEndPoseToleranceType* SetEndPoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetEndPoseToleranceType (*this, f, c);
}

SetEndPoseToleranceType& SetEndPoseToleranceType::
operator= (const SetEndPoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Tolerance_ = x.Tolerance_;
  }

  return *this;
}

SetEndPoseToleranceType::
~SetEndPoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetEndPoseToleranceType >
_xsd_SetEndPoseToleranceType_type_factory_init (
  "SetEndPoseToleranceType",
  "");

// SetForceUnitsType
//

SetForceUnitsType::
SetForceUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const CommandID_type& CommandID,
                   const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const CommandID_type& CommandID,
                   ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const SetForceUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetForceUnitsType::
SetForceUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetForceUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetForceUnitsType* SetForceUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetForceUnitsType (*this, f, c);
}

SetForceUnitsType& SetForceUnitsType::
operator= (const SetForceUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetForceUnitsType::
~SetForceUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetForceUnitsType >
_xsd_SetForceUnitsType_type_factory_init (
  "SetForceUnitsType",
  "");

// SetIntermediatePoseToleranceType
//

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                  const Tolerance_type& Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                                  ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const CommandID_type& CommandID,
                                  const Tolerance_type& Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const CommandID_type& CommandID,
                                  ::std::auto_ptr< Tolerance_type > Tolerance)
: ::MiddleCommandType (CommandID),
  Tolerance_ (Tolerance, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const SetIntermediatePoseToleranceType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Tolerance_ (x.Tolerance_, f, this)
{
}

SetIntermediatePoseToleranceType::
SetIntermediatePoseToleranceType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Tolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetIntermediatePoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Tolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Tolerance",
          "",
          &::xsd::cxx::tree::factory_impl< Tolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Tolerance_.present ())
        {
          ::std::auto_ptr< Tolerance_type > r (
            dynamic_cast< Tolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Tolerance_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Tolerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Tolerance",
      "");
  }
}

SetIntermediatePoseToleranceType* SetIntermediatePoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetIntermediatePoseToleranceType (*this, f, c);
}

SetIntermediatePoseToleranceType& SetIntermediatePoseToleranceType::
operator= (const SetIntermediatePoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Tolerance_ = x.Tolerance_;
  }

  return *this;
}

SetIntermediatePoseToleranceType::
~SetIntermediatePoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetIntermediatePoseToleranceType >
_xsd_SetIntermediatePoseToleranceType_type_factory_init (
  "SetIntermediatePoseToleranceType",
  "");

// SetLengthUnitsType
//

SetLengthUnitsType::
SetLengthUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const CommandID_type& CommandID,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const CommandID_type& CommandID,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const SetLengthUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetLengthUnitsType::
SetLengthUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetLengthUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetLengthUnitsType* SetLengthUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetLengthUnitsType (*this, f, c);
}

SetLengthUnitsType& SetLengthUnitsType::
operator= (const SetLengthUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetLengthUnitsType::
~SetLengthUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetLengthUnitsType >
_xsd_SetLengthUnitsType_type_factory_init (
  "SetLengthUnitsType",
  "");

// SetMotionCoordinationType
//

SetMotionCoordinationType::
SetMotionCoordinationType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                           const Coordinated_type& Coordinated)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  Coordinated_ (Coordinated, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const CommandID_type& CommandID,
                           const Coordinated_type& Coordinated)
: ::MiddleCommandType (CommandID),
  Coordinated_ (Coordinated, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const SetMotionCoordinationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  Coordinated_ (x.Coordinated_, f, this)
{
}

SetMotionCoordinationType::
SetMotionCoordinationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  Coordinated_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetMotionCoordinationType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinated
    //
    if (n.name () == "Coordinated" && n.namespace_ ().empty ())
    {
      if (!Coordinated_.present ())
      {
        this->Coordinated_.set (Coordinated_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Coordinated_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Coordinated",
      "");
  }
}

SetMotionCoordinationType* SetMotionCoordinationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetMotionCoordinationType (*this, f, c);
}

SetMotionCoordinationType& SetMotionCoordinationType::
operator= (const SetMotionCoordinationType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->Coordinated_ = x.Coordinated_;
  }

  return *this;
}

SetMotionCoordinationType::
~SetMotionCoordinationType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetMotionCoordinationType >
_xsd_SetMotionCoordinationType_type_factory_init (
  "SetMotionCoordinationType",
  "");

// SetRobotParametersType
//

SetRobotParametersType::
SetRobotParametersType (const ::MiddleCommandType& _xsd_MiddleCommandType_base)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  ParameterSetting_ (this)
{
}

SetRobotParametersType::
SetRobotParametersType (const CommandID_type& CommandID)
: ::MiddleCommandType (CommandID),
  ParameterSetting_ (this)
{
}

SetRobotParametersType::
SetRobotParametersType (const SetRobotParametersType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  ParameterSetting_ (x.ParameterSetting_, f, this)
{
}

SetRobotParametersType::
SetRobotParametersType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  ParameterSetting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRobotParametersType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ParameterSetting_type > r (
          dynamic_cast< ParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->ParameterSetting_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SetRobotParametersType* SetRobotParametersType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRobotParametersType (*this, f, c);
}

SetRobotParametersType& SetRobotParametersType::
operator= (const SetRobotParametersType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->ParameterSetting_ = x.ParameterSetting_;
  }

  return *this;
}

SetRobotParametersType::
~SetRobotParametersType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRobotParametersType >
_xsd_SetRobotParametersType_type_factory_init (
  "SetRobotParametersType",
  "");

// SetRotAccelType
//

SetRotAccelType::
SetRotAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 const RotAccel_type& RotAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 ::std::auto_ptr< RotAccel_type > RotAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const CommandID_type& CommandID,
                 const RotAccel_type& RotAccel)
: ::MiddleCommandType (CommandID),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const CommandID_type& CommandID,
                 ::std::auto_ptr< RotAccel_type > RotAccel)
: ::MiddleCommandType (CommandID),
  RotAccel_ (RotAccel, this)
{
}

SetRotAccelType::
SetRotAccelType (const SetRotAccelType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RotAccel_ (x.RotAccel_, f, this)
{
}

SetRotAccelType::
SetRotAccelType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RotAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRotAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RotAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccel",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RotAccel_.present ())
        {
          ::std::auto_ptr< RotAccel_type > r (
            dynamic_cast< RotAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccel_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RotAccel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RotAccel",
      "");
  }
}

SetRotAccelType* SetRotAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRotAccelType (*this, f, c);
}

SetRotAccelType& SetRotAccelType::
operator= (const SetRotAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RotAccel_ = x.RotAccel_;
  }

  return *this;
}

SetRotAccelType::
~SetRotAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRotAccelType >
_xsd_SetRotAccelType_type_factory_init (
  "SetRotAccelType",
  "");

// SetRotSpeedType
//

SetRotSpeedType::
SetRotSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 const RotSpeed_type& RotSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                 ::std::auto_ptr< RotSpeed_type > RotSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const CommandID_type& CommandID,
                 const RotSpeed_type& RotSpeed)
: ::MiddleCommandType (CommandID),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const CommandID_type& CommandID,
                 ::std::auto_ptr< RotSpeed_type > RotSpeed)
: ::MiddleCommandType (CommandID),
  RotSpeed_ (RotSpeed, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const SetRotSpeedType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  RotSpeed_ (x.RotSpeed_, f, this)
{
}

SetRotSpeedType::
SetRotSpeedType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  RotSpeed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetRotSpeedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RotSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!RotSpeed_.present ())
        {
          ::std::auto_ptr< RotSpeed_type > r (
            dynamic_cast< RotSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeed_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!RotSpeed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RotSpeed",
      "");
  }
}

SetRotSpeedType* SetRotSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetRotSpeedType (*this, f, c);
}

SetRotSpeedType& SetRotSpeedType::
operator= (const SetRotSpeedType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->RotSpeed_ = x.RotSpeed_;
  }

  return *this;
}

SetRotSpeedType::
~SetRotSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRotSpeedType >
_xsd_SetRotSpeedType_type_factory_init (
  "SetRotSpeedType",
  "");

// SetTorqueUnitsType
//

SetTorqueUnitsType::
SetTorqueUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const CommandID_type& CommandID,
                    const UnitName_type& UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const CommandID_type& CommandID,
                    ::std::auto_ptr< UnitName_type > UnitName)
: ::MiddleCommandType (CommandID),
  UnitName_ (UnitName, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const SetTorqueUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  UnitName_ (x.UnitName_, f, this)
{
}

SetTorqueUnitsType::
SetTorqueUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  UnitName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTorqueUnitsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "UnitName",
          "",
          &::xsd::cxx::tree::factory_impl< UnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!UnitName_.present ())
        {
          ::std::auto_ptr< UnitName_type > r (
            dynamic_cast< UnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->UnitName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!UnitName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UnitName",
      "");
  }
}

SetTorqueUnitsType* SetTorqueUnitsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTorqueUnitsType (*this, f, c);
}

SetTorqueUnitsType& SetTorqueUnitsType::
operator= (const SetTorqueUnitsType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->UnitName_ = x.UnitName_;
  }

  return *this;
}

SetTorqueUnitsType::
~SetTorqueUnitsType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTorqueUnitsType >
_xsd_SetTorqueUnitsType_type_factory_init (
  "SetTorqueUnitsType",
  "");

// SetTransAccelType
//

SetTransAccelType::
SetTransAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const TransAccel_type& TransAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< TransAccel_type > TransAccel)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const CommandID_type& CommandID,
                   const TransAccel_type& TransAccel)
: ::MiddleCommandType (CommandID),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const CommandID_type& CommandID,
                   ::std::auto_ptr< TransAccel_type > TransAccel)
: ::MiddleCommandType (CommandID),
  TransAccel_ (TransAccel, this)
{
}

SetTransAccelType::
SetTransAccelType (const SetTransAccelType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  TransAccel_ (x.TransAccel_, f, this)
{
}

SetTransAccelType::
SetTransAccelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  TransAccel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTransAccelType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TransAccel
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccel",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccel_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!TransAccel_.present ())
        {
          ::std::auto_ptr< TransAccel_type > r (
            dynamic_cast< TransAccel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccel_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!TransAccel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TransAccel",
      "");
  }
}

SetTransAccelType* SetTransAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTransAccelType (*this, f, c);
}

SetTransAccelType& SetTransAccelType::
operator= (const SetTransAccelType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->TransAccel_ = x.TransAccel_;
  }

  return *this;
}

SetTransAccelType::
~SetTransAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTransAccelType >
_xsd_SetTransAccelType_type_factory_init (
  "SetTransAccelType",
  "");

// SetTransSpeedType
//

SetTransSpeedType::
SetTransSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   const TransSpeed_type& TransSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                   ::std::auto_ptr< TransSpeed_type > TransSpeed)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const CommandID_type& CommandID,
                   const TransSpeed_type& TransSpeed)
: ::MiddleCommandType (CommandID),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const CommandID_type& CommandID,
                   ::std::auto_ptr< TransSpeed_type > TransSpeed)
: ::MiddleCommandType (CommandID),
  TransSpeed_ (TransSpeed, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const SetTransSpeedType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  TransSpeed_ (x.TransSpeed_, f, this)
{
}

SetTransSpeedType::
SetTransSpeedType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  TransSpeed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SetTransSpeedType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TransSpeed
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeed",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeed_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!TransSpeed_.present ())
        {
          ::std::auto_ptr< TransSpeed_type > r (
            dynamic_cast< TransSpeed_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeed_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!TransSpeed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TransSpeed",
      "");
  }
}

SetTransSpeedType* SetTransSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SetTransSpeedType (*this, f, c);
}

SetTransSpeedType& SetTransSpeedType::
operator= (const SetTransSpeedType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->TransSpeed_ = x.TransSpeed_;
  }

  return *this;
}

SetTransSpeedType::
~SetTransSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetTransSpeedType >
_xsd_SetTransSpeedType_type_factory_init (
  "SetTransSpeedType",
  "");

// StopConditionEnumType
//

StopConditionEnumType::
StopConditionEnumType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType::
StopConditionEnumType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType::
StopConditionEnumType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_StopConditionEnumType_convert ();
}

StopConditionEnumType* StopConditionEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StopConditionEnumType (*this, f, c);
}

StopConditionEnumType::value StopConditionEnumType::
_xsd_StopConditionEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_StopConditionEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_StopConditionEnumType_indexes_,
                    _xsd_StopConditionEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_StopConditionEnumType_indexes_ + 3 || _xsd_StopConditionEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const StopConditionEnumType::
_xsd_StopConditionEnumType_literals_[3] =
{
  "Immediate",
  "Fast",
  "Normal"
};

const StopConditionEnumType::value StopConditionEnumType::
_xsd_StopConditionEnumType_indexes_[3] =
{
  ::StopConditionEnumType::Fast,
  ::StopConditionEnumType::Immediate,
  ::StopConditionEnumType::Normal
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopConditionEnumType >
_xsd_StopConditionEnumType_type_factory_init (
  "StopConditionEnumType",
  "");

// StopMotionType
//

StopMotionType::
StopMotionType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                const StopCondition_type& StopCondition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const ::MiddleCommandType& _xsd_MiddleCommandType_base,
                ::std::auto_ptr< StopCondition_type > StopCondition)
: ::MiddleCommandType (_xsd_MiddleCommandType_base),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const CommandID_type& CommandID,
                const StopCondition_type& StopCondition)
: ::MiddleCommandType (CommandID),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const CommandID_type& CommandID,
                ::std::auto_ptr< StopCondition_type > StopCondition)
: ::MiddleCommandType (CommandID),
  StopCondition_ (StopCondition, this)
{
}

StopMotionType::
StopMotionType (const StopMotionType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (x, f, c),
  StopCondition_ (x.StopCondition_, f, this)
{
}

StopMotionType::
StopMotionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::MiddleCommandType (e, f | ::xml_schema::flags::base, c),
  StopCondition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void StopMotionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::MiddleCommandType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // StopCondition
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StopCondition",
          "",
          &::xsd::cxx::tree::factory_impl< StopCondition_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!StopCondition_.present ())
        {
          ::std::auto_ptr< StopCondition_type > r (
            dynamic_cast< StopCondition_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StopCondition_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!StopCondition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "StopCondition",
      "");
  }
}

StopMotionType* StopMotionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class StopMotionType (*this, f, c);
}

StopMotionType& StopMotionType::
operator= (const StopMotionType& x)
{
  if (this != &x)
  {
    static_cast< ::MiddleCommandType& > (*this) = x;
    this->StopCondition_ = x.StopCondition_;
  }

  return *this;
}

StopMotionType::
~StopMotionType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopMotionType >
_xsd_StopMotionType_type_factory_init (
  "StopMotionType",
  "");

// TransAccelType
//

TransAccelType::
TransAccelType ()
: ::DataThingType ()
{
}

TransAccelType::
TransAccelType (const TransAccelType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

TransAccelType::
TransAccelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

TransAccelType* TransAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelType (*this, f, c);
}

TransAccelType::
~TransAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelType >
_xsd_TransAccelType_type_factory_init (
  "TransAccelType",
  "");

// TransAccelAbsoluteType
//

TransAccelAbsoluteType::
TransAccelAbsoluteType (const Setting_type& Setting)
: ::TransAccelType (),
  Setting_ (Setting, this)
{
}

TransAccelAbsoluteType::
TransAccelAbsoluteType (const TransAccelAbsoluteType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

TransAccelAbsoluteType::
TransAccelAbsoluteType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransAccelAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

TransAccelAbsoluteType* TransAccelAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelAbsoluteType (*this, f, c);
}

TransAccelAbsoluteType& TransAccelAbsoluteType::
operator= (const TransAccelAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::TransAccelType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

TransAccelAbsoluteType::
~TransAccelAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelAbsoluteType >
_xsd_TransAccelAbsoluteType_type_factory_init (
  "TransAccelAbsoluteType",
  "");

// TransAccelRelativeType
//

TransAccelRelativeType::
TransAccelRelativeType (const Fraction_type& Fraction)
: ::TransAccelType (),
  Fraction_ (Fraction, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::TransAccelType (),
  Fraction_ (Fraction, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (const TransAccelRelativeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransAccelRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

TransAccelRelativeType* TransAccelRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelRelativeType (*this, f, c);
}

TransAccelRelativeType& TransAccelRelativeType::
operator= (const TransAccelRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::TransAccelType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

TransAccelRelativeType::
~TransAccelRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelRelativeType >
_xsd_TransAccelRelativeType_type_factory_init (
  "TransAccelRelativeType",
  "");

// TransSpeedType
//

TransSpeedType::
TransSpeedType ()
: ::DataThingType ()
{
}

TransSpeedType::
TransSpeedType (const TransSpeedType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

TransSpeedType::
TransSpeedType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

TransSpeedType* TransSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedType (*this, f, c);
}

TransSpeedType::
~TransSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedType >
_xsd_TransSpeedType_type_factory_init (
  "TransSpeedType",
  "");

// TransSpeedAbsoluteType
//

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const Setting_type& Setting)
: ::TransSpeedType (),
  Setting_ (Setting, this)
{
}

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const TransSpeedAbsoluteType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransSpeedAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

TransSpeedAbsoluteType* TransSpeedAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedAbsoluteType (*this, f, c);
}

TransSpeedAbsoluteType& TransSpeedAbsoluteType::
operator= (const TransSpeedAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::TransSpeedType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

TransSpeedAbsoluteType::
~TransSpeedAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedAbsoluteType >
_xsd_TransSpeedAbsoluteType_type_factory_init (
  "TransSpeedAbsoluteType",
  "");

// TransSpeedRelativeType
//

TransSpeedRelativeType::
TransSpeedRelativeType (const Fraction_type& Fraction)
: ::TransSpeedType (),
  Fraction_ (Fraction, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::TransSpeedType (),
  Fraction_ (Fraction, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (const TransSpeedRelativeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransSpeedRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

TransSpeedRelativeType* TransSpeedRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedRelativeType (*this, f, c);
}

TransSpeedRelativeType& TransSpeedRelativeType::
operator= (const TransSpeedRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::TransSpeedType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

TransSpeedRelativeType::
~TransSpeedRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedRelativeType >
_xsd_TransSpeedRelativeType_type_factory_init (
  "TransSpeedRelativeType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const CRCLCommandType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CommandID",
        e));

    s << i.CommandID ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CRCLCommandType >
_xsd_CRCLCommandType_type_serializer_init (
  "CRCLCommandType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MiddleCommandType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MiddleCommandType >
_xsd_MiddleCommandType_type_serializer_init (
  "MiddleCommandType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ActuateJointsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ActuateJoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (ActuateJointsType::ActuateJoint_const_iterator
         b (i.ActuateJoint ().begin ()), n (i.ActuateJoint ().end ());
         b != n; ++b)
    {
      if (typeid (ActuateJointsType::ActuateJoint_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActuateJoint",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ActuateJoint",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActuateJointsType >
_xsd_ActuateJointsType_type_serializer_init (
  "ActuateJointsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ActuateJointType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointPosition",
        e));

    s << ::xml_schema::as_decimal(i.JointPosition ());
  }

  // JointDetails
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ActuateJointType::JointDetails_type& x (i.JointDetails ());
    if (typeid (ActuateJointType::JointDetails_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "JointDetails",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "JointDetails",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActuateJointType >
_xsd_ActuateJointType_type_serializer_init (
  "ActuateJointType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CloseToolChangerType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CloseToolChangerType >
_xsd_CloseToolChangerType_type_serializer_init (
  "CloseToolChangerType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ConfigureJointReportsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ResetAll
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ResetAll",
        e));

    s << i.ResetAll ();
  }

  // ConfigureJointReport
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (ConfigureJointReportsType::ConfigureJointReport_const_iterator
         b (i.ConfigureJointReport ().begin ()), n (i.ConfigureJointReport ().end ());
         b != n; ++b)
    {
      if (typeid (ConfigureJointReportsType::ConfigureJointReport_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConfigureJointReport",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ConfigureJointReport",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConfigureJointReportsType >
_xsd_ConfigureJointReportsType_type_serializer_init (
  "ConfigureJointReportsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ConfigureJointReportType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // ReportPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportPosition",
        e));

    s << i.ReportPosition ();
  }

  // ReportTorqueOrForce
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportTorqueOrForce",
        e));

    s << i.ReportTorqueOrForce ();
  }

  // ReportVelocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReportVelocity",
        e));

    s << i.ReportVelocity ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConfigureJointReportType >
_xsd_ConfigureJointReportType_type_serializer_init (
  "ConfigureJointReportType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DwellType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // DwellTime
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DwellTime",
        e));

    s << ::xml_schema::as_decimal(i.DwellTime ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DwellType >
_xsd_DwellType_type_serializer_init (
  "DwellType",
  "");


void
operator<< (::xercesc::DOMElement& e, const EndCanonType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EndCanonType >
_xsd_EndCanonType_type_serializer_init (
  "EndCanonType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GetStatusType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GetStatusType >
_xsd_GetStatusType_type_serializer_init (
  "GetStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const InitCanonType& i)
{
  e << static_cast< const ::CRCLCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InitCanonType >
_xsd_InitCanonType_type_serializer_init (
  "InitCanonType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointDetailsType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointDetailsType >
_xsd_JointDetailsType_type_serializer_init (
  "JointDetailsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointForceTorqueType& i)
{
  e << static_cast< const ::JointDetailsType& > (i);

  // Setting
  //
  if (i.Setting ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_decimal(*i.Setting ());
  }

  // ChangeRate
  //
  if (i.ChangeRate ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ChangeRate",
        e));

    s << ::xml_schema::as_decimal(*i.ChangeRate ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointForceTorqueType >
_xsd_JointForceTorqueType_type_serializer_init (
  "JointForceTorqueType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointSpeedAccelType& i)
{
  e << static_cast< const ::JointDetailsType& > (i);

  // JointSpeed
  //
  if (i.JointSpeed ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointSpeed",
        e));

    s << ::xml_schema::as_decimal(*i.JointSpeed ());
  }

  // JointAccel
  //
  if (i.JointAccel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointAccel",
        e));

    s << ::xml_schema::as_decimal(*i.JointAccel ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointSpeedAccelType >
_xsd_JointSpeedAccelType_type_serializer_init (
  "JointSpeedAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MessageType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Message
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MessageType::Message_type& x (i.Message ());
    if (typeid (MessageType::Message_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Message",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Message",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MessageType >
_xsd_MessageType_type_serializer_init (
  "MessageType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveScrewType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // StartPosition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.StartPosition ())
    {
      const MoveScrewType::StartPosition_type& x (*i.StartPosition ());
      if (typeid (MoveScrewType::StartPosition_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StartPosition",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StartPosition",
          "",
          false, true, e, x);
    }
  }

  // AxisPoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AxisPoint ())
    {
      const MoveScrewType::AxisPoint_type& x (*i.AxisPoint ());
      if (typeid (MoveScrewType::AxisPoint_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisPoint",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AxisPoint",
          "",
          false, true, e, x);
    }
  }

  // AxialDistanceFree
  //
  if (i.AxialDistanceFree ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AxialDistanceFree",
        e));

    s << ::xml_schema::as_decimal(*i.AxialDistanceFree ());
  }

  // AxialDistanceScrew
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AxialDistanceScrew",
        e));

    s << ::xml_schema::as_decimal(i.AxialDistanceScrew ());
  }

  // Turn
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Turn",
        e));

    s << ::xml_schema::as_decimal(i.Turn ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveScrewType >
_xsd_MoveScrewType_type_serializer_init (
  "MoveScrewType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveThroughToType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // MoveStraight
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveStraight",
        e));

    s << i.MoveStraight ();
  }

  // Waypoint
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (MoveThroughToType::Waypoint_const_iterator
         b (i.Waypoint ().begin ()), n (i.Waypoint ().end ());
         b != n; ++b)
    {
      if (typeid (MoveThroughToType::Waypoint_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Waypoint",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Waypoint",
          "",
          false, true, e, *b);
    }
  }

  // NumPositions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NumPositions",
        e));

    s << i.NumPositions ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveThroughToType >
_xsd_MoveThroughToType_type_serializer_init (
  "MoveThroughToType",
  "");


void
operator<< (::xercesc::DOMElement& e, const MoveToType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // MoveStraight
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveStraight",
        e));

    s << i.MoveStraight ();
  }

  // EndPosition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const MoveToType::EndPosition_type& x (i.EndPosition ());
    if (typeid (MoveToType::EndPosition_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EndPosition",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "EndPosition",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MoveToType >
_xsd_MoveToType_type_serializer_init (
  "MoveToType",
  "");


void
operator<< (::xercesc::DOMElement& e, const OpenToolChangerType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OpenToolChangerType >
_xsd_OpenToolChangerType_type_serializer_init (
  "OpenToolChangerType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParameterSettingType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // ParameterName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ParameterSettingType::ParameterName_type& x (i.ParameterName ());
    if (typeid (ParameterSettingType::ParameterName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ParameterName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ParameterName",
        "",
        false, true, e, x);
  }

  // ParameterValue
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ParameterSettingType::ParameterValue_type& x (i.ParameterValue ());
    if (typeid (ParameterSettingType::ParameterValue_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ParameterValue",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ParameterValue",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParameterSettingType >
_xsd_ParameterSettingType_type_serializer_init (
  "ParameterSettingType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseAndSetType& i)
{
  e << static_cast< const ::PoseType& > (i);

  // Coordinated
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Coordinated",
        e));

    s << i.Coordinated ();
  }

  // TransSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransSpeed ())
    {
      const PoseAndSetType::TransSpeed_type& x (*i.TransSpeed ());
      if (typeid (PoseAndSetType::TransSpeed_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransSpeed",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransSpeed",
          "",
          false, true, e, x);
    }
  }

  // RotSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotSpeed ())
    {
      const PoseAndSetType::RotSpeed_type& x (*i.RotSpeed ());
      if (typeid (PoseAndSetType::RotSpeed_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotSpeed",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotSpeed",
          "",
          false, true, e, x);
    }
  }

  // TransAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransAccel ())
    {
      const PoseAndSetType::TransAccel_type& x (*i.TransAccel ());
      if (typeid (PoseAndSetType::TransAccel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransAccel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransAccel",
          "",
          false, true, e, x);
    }
  }

  // RotAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotAccel ())
    {
      const PoseAndSetType::RotAccel_type& x (*i.RotAccel ());
      if (typeid (PoseAndSetType::RotAccel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotAccel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotAccel",
          "",
          false, true, e, x);
    }
  }

  // Tolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Tolerance ())
    {
      const PoseAndSetType::Tolerance_type& x (*i.Tolerance ());
      if (typeid (PoseAndSetType::Tolerance_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Tolerance",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Tolerance",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseAndSetType >
_xsd_PoseAndSetType_type_serializer_init (
  "PoseAndSetType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseToleranceType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // XPointTolerance
  //
  if (i.XPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "XPointTolerance",
        e));

    s << ::xml_schema::as_decimal(*i.XPointTolerance ());
  }

  // YPointTolerance
  //
  if (i.YPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "YPointTolerance",
        e));

    s << ::xml_schema::as_decimal(*i.YPointTolerance ());
  }

  // ZPointTolerance
  //
  if (i.ZPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ZPointTolerance",
        e));

    s << ::xml_schema::as_decimal(*i.ZPointTolerance ());
  }

  // XAxisTolerance
  //
  if (i.XAxisTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "XAxisTolerance",
        e));

    s << ::xml_schema::as_decimal(*i.XAxisTolerance ());
  }

  // ZAxisTolerance
  //
  if (i.ZAxisTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ZAxisTolerance",
        e));

    s << ::xml_schema::as_decimal(*i.ZAxisTolerance ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseToleranceType >
_xsd_PoseToleranceType_type_serializer_init (
  "PoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelType >
_xsd_RotAccelType_type_serializer_init (
  "RotAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelAbsoluteType& i)
{
  e << static_cast< const ::RotAccelType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_decimal(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelAbsoluteType >
_xsd_RotAccelAbsoluteType_type_serializer_init (
  "RotAccelAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelRelativeType& i)
{
  e << static_cast< const ::RotAccelType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RotAccelRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (RotAccelRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelRelativeType >
_xsd_RotAccelRelativeType_type_serializer_init (
  "RotAccelRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedType >
_xsd_RotSpeedType_type_serializer_init (
  "RotSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedAbsoluteType& i)
{
  e << static_cast< const ::RotSpeedType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_decimal(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedAbsoluteType >
_xsd_RotSpeedAbsoluteType_type_serializer_init (
  "RotSpeedAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedRelativeType& i)
{
  e << static_cast< const ::RotSpeedType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RotSpeedRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (RotSpeedRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedRelativeType >
_xsd_RotSpeedRelativeType_type_serializer_init (
  "RotSpeedRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RunProgramType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ProgramText
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RunProgramType::ProgramText_type& x (i.ProgramText ());
    if (typeid (RunProgramType::ProgramText_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProgramText",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ProgramText",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunProgramType >
_xsd_RunProgramType_type_serializer_init (
  "RunProgramType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetAngleUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetAngleUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetAngleUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetAngleUnitsType >
_xsd_SetAngleUnitsType_type_serializer_init (
  "SetAngleUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndEffectorParametersType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SetEndEffectorParametersType::ParameterSetting_const_iterator
         b (i.ParameterSetting ().begin ()), n (i.ParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SetEndEffectorParametersType::ParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ParameterSetting",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndEffectorParametersType >
_xsd_SetEndEffectorParametersType_type_serializer_init (
  "SetEndEffectorParametersType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndEffectorType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Setting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetEndEffectorType::Setting_type& x (i.Setting ());
    if (typeid (SetEndEffectorType::Setting_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Setting",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Setting",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndEffectorType >
_xsd_SetEndEffectorType_type_serializer_init (
  "SetEndEffectorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetEndPoseToleranceType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Tolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetEndPoseToleranceType::Tolerance_type& x (i.Tolerance ());
    if (typeid (SetEndPoseToleranceType::Tolerance_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tolerance",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Tolerance",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetEndPoseToleranceType >
_xsd_SetEndPoseToleranceType_type_serializer_init (
  "SetEndPoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetForceUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetForceUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetForceUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetForceUnitsType >
_xsd_SetForceUnitsType_type_serializer_init (
  "SetForceUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetIntermediatePoseToleranceType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Tolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetIntermediatePoseToleranceType::Tolerance_type& x (i.Tolerance ());
    if (typeid (SetIntermediatePoseToleranceType::Tolerance_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Tolerance",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Tolerance",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetIntermediatePoseToleranceType >
_xsd_SetIntermediatePoseToleranceType_type_serializer_init (
  "SetIntermediatePoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetLengthUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetLengthUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetLengthUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetLengthUnitsType >
_xsd_SetLengthUnitsType_type_serializer_init (
  "SetLengthUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetMotionCoordinationType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // Coordinated
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Coordinated",
        e));

    s << i.Coordinated ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetMotionCoordinationType >
_xsd_SetMotionCoordinationType_type_serializer_init (
  "SetMotionCoordinationType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRobotParametersType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // ParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SetRobotParametersType::ParameterSetting_const_iterator
         b (i.ParameterSetting ().begin ()), n (i.ParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SetRobotParametersType::ParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "ParameterSetting",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRobotParametersType >
_xsd_SetRobotParametersType_type_serializer_init (
  "SetRobotParametersType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRotAccelType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RotAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetRotAccelType::RotAccel_type& x (i.RotAccel ());
    if (typeid (SetRotAccelType::RotAccel_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RotAccel",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RotAccel",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRotAccelType >
_xsd_SetRotAccelType_type_serializer_init (
  "SetRotAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetRotSpeedType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // RotSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetRotSpeedType::RotSpeed_type& x (i.RotSpeed ());
    if (typeid (SetRotSpeedType::RotSpeed_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RotSpeed",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "RotSpeed",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRotSpeedType >
_xsd_SetRotSpeedType_type_serializer_init (
  "SetRotSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTorqueUnitsType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // UnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTorqueUnitsType::UnitName_type& x (i.UnitName ());
    if (typeid (SetTorqueUnitsType::UnitName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "UnitName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "UnitName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTorqueUnitsType >
_xsd_SetTorqueUnitsType_type_serializer_init (
  "SetTorqueUnitsType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTransAccelType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // TransAccel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTransAccelType::TransAccel_type& x (i.TransAccel ());
    if (typeid (SetTransAccelType::TransAccel_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TransAccel",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "TransAccel",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTransAccelType >
_xsd_SetTransAccelType_type_serializer_init (
  "SetTransAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SetTransSpeedType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // TransSpeed
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const SetTransSpeedType::TransSpeed_type& x (i.TransSpeed ());
    if (typeid (SetTransSpeedType::TransSpeed_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TransSpeed",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "TransSpeed",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetTransSpeedType >
_xsd_SetTransSpeedType_type_serializer_init (
  "SetTransSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const StopConditionEnumType& i)
{
  e << static_cast< const ::xml_schema::token& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const StopConditionEnumType& i)
{
  a << static_cast< const ::xml_schema::token& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const StopConditionEnumType& i)
{
  l << static_cast< const ::xml_schema::token& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopConditionEnumType >
_xsd_StopConditionEnumType_type_serializer_init (
  "StopConditionEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const StopMotionType& i)
{
  e << static_cast< const ::MiddleCommandType& > (i);

  // StopCondition
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const StopMotionType::StopCondition_type& x (i.StopCondition ());
    if (typeid (StopMotionType::StopCondition_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "StopCondition",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "StopCondition",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopMotionType >
_xsd_StopMotionType_type_serializer_init (
  "StopMotionType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelType >
_xsd_TransAccelType_type_serializer_init (
  "TransAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelAbsoluteType& i)
{
  e << static_cast< const ::TransAccelType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_decimal(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelAbsoluteType >
_xsd_TransAccelAbsoluteType_type_serializer_init (
  "TransAccelAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelRelativeType& i)
{
  e << static_cast< const ::TransAccelType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TransAccelRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (TransAccelRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelRelativeType >
_xsd_TransAccelRelativeType_type_serializer_init (
  "TransAccelRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedType >
_xsd_TransSpeedType_type_serializer_init (
  "TransSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedAbsoluteType& i)
{
  e << static_cast< const ::TransSpeedType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_decimal(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedAbsoluteType >
_xsd_TransSpeedAbsoluteType_type_serializer_init (
  "TransSpeedAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedRelativeType& i)
{
  e << static_cast< const ::TransSpeedType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TransSpeedRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (TransSpeedRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedRelativeType >
_xsd_TransSpeedRelativeType_type_serializer_init (
  "TransSpeedRelativeType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

