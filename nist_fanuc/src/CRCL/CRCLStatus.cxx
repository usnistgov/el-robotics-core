// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CRCLStatus.hxx"

// CommandStateEnumType
// 

CommandStateEnumType::
CommandStateEnumType (value v)
: ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v])
{
}

CommandStateEnumType::
CommandStateEnumType (const char* v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const CommandStateEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CommandStateEnumType& CommandStateEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v]);

  return *this;
}


// CommandStatusType
// 

const CommandStatusType::CommandID_type& CommandStatusType::
CommandID () const
{
  return this->CommandID_.get ();
}

CommandStatusType::CommandID_type& CommandStatusType::
CommandID ()
{
  return this->CommandID_.get ();
}

void CommandStatusType::
CommandID (const CommandID_type& x)
{
  this->CommandID_.set (x);
}

const CommandStatusType::StatusID_type& CommandStatusType::
StatusID () const
{
  return this->StatusID_.get ();
}

CommandStatusType::StatusID_type& CommandStatusType::
StatusID ()
{
  return this->StatusID_.get ();
}

void CommandStatusType::
StatusID (const StatusID_type& x)
{
  this->StatusID_.set (x);
}

const CommandStatusType::CommandState_type& CommandStatusType::
CommandState () const
{
  return this->CommandState_.get ();
}

CommandStatusType::CommandState_type& CommandStatusType::
CommandState ()
{
  return this->CommandState_.get ();
}

void CommandStatusType::
CommandState (const CommandState_type& x)
{
  this->CommandState_.set (x);
}

void CommandStatusType::
CommandState (::std::auto_ptr< CommandState_type > x)
{
  this->CommandState_.set (x);
}

const CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription () const
{
  return this->StateDescription_;
}

CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription ()
{
  return this->StateDescription_;
}

void CommandStatusType::
StateDescription (const StateDescription_type& x)
{
  this->StateDescription_.set (x);
}

void CommandStatusType::
StateDescription (const StateDescription_optional& x)
{
  this->StateDescription_ = x;
}

void CommandStatusType::
StateDescription (::std::auto_ptr< StateDescription_type > x)
{
  this->StateDescription_.set (x);
}


// CRCLStatusType
// 

const CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus () const
{
  return this->CommandStatus_.get ();
}

CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus ()
{
  return this->CommandStatus_.get ();
}

void CRCLStatusType::
CommandStatus (const CommandStatus_type& x)
{
  this->CommandStatus_.set (x);
}

void CRCLStatusType::
CommandStatus (::std::auto_ptr< CommandStatus_type > x)
{
  this->CommandStatus_.set (x);
}

const CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses () const
{
  return this->JointStatuses_;
}

CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses ()
{
  return this->JointStatuses_;
}

void CRCLStatusType::
JointStatuses (const JointStatuses_type& x)
{
  this->JointStatuses_.set (x);
}

void CRCLStatusType::
JointStatuses (const JointStatuses_optional& x)
{
  this->JointStatuses_ = x;
}

void CRCLStatusType::
JointStatuses (::std::auto_ptr< JointStatuses_type > x)
{
  this->JointStatuses_.set (x);
}

const CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus () const
{
  return this->PoseStatus_;
}

CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus ()
{
  return this->PoseStatus_;
}

void CRCLStatusType::
PoseStatus (const PoseStatus_type& x)
{
  this->PoseStatus_.set (x);
}

void CRCLStatusType::
PoseStatus (const PoseStatus_optional& x)
{
  this->PoseStatus_ = x;
}

void CRCLStatusType::
PoseStatus (::std::auto_ptr< PoseStatus_type > x)
{
  this->PoseStatus_.set (x);
}

const CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus () const
{
  return this->GripperStatus_;
}

CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus ()
{
  return this->GripperStatus_;
}

void CRCLStatusType::
GripperStatus (const GripperStatus_type& x)
{
  this->GripperStatus_.set (x);
}

void CRCLStatusType::
GripperStatus (const GripperStatus_optional& x)
{
  this->GripperStatus_ = x;
}

void CRCLStatusType::
GripperStatus (::std::auto_ptr< GripperStatus_type > x)
{
  this->GripperStatus_.set (x);
}


// GripperStatusType
// 

const GripperStatusType::GripperName_type& GripperStatusType::
GripperName () const
{
  return this->GripperName_.get ();
}

GripperStatusType::GripperName_type& GripperStatusType::
GripperName ()
{
  return this->GripperName_.get ();
}

void GripperStatusType::
GripperName (const GripperName_type& x)
{
  this->GripperName_.set (x);
}

void GripperStatusType::
GripperName (::std::auto_ptr< GripperName_type > x)
{
  this->GripperName_.set (x);
}


// JointStatusesType
// 

const JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus () const
{
  return this->JointStatus_;
}

JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus ()
{
  return this->JointStatus_;
}

void JointStatusesType::
JointStatus (const JointStatus_sequence& s)
{
  this->JointStatus_ = s;
}


// JointStatusType
// 

const JointStatusType::JointNumber_type& JointStatusType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

JointStatusType::JointNumber_type& JointStatusType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void JointStatusType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const JointStatusType::JointPosition_optional& JointStatusType::
JointPosition () const
{
  return this->JointPosition_;
}

JointStatusType::JointPosition_optional& JointStatusType::
JointPosition ()
{
  return this->JointPosition_;
}

void JointStatusType::
JointPosition (const JointPosition_type& x)
{
  this->JointPosition_.set (x);
}

void JointStatusType::
JointPosition (const JointPosition_optional& x)
{
  this->JointPosition_ = x;
}

const JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce () const
{
  return this->JointTorqueOrForce_;
}

JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce ()
{
  return this->JointTorqueOrForce_;
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_type& x)
{
  this->JointTorqueOrForce_.set (x);
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_optional& x)
{
  this->JointTorqueOrForce_ = x;
}

const JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity () const
{
  return this->JointVelocity_;
}

JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity ()
{
  return this->JointVelocity_;
}

void JointStatusType::
JointVelocity (const JointVelocity_type& x)
{
  this->JointVelocity_.set (x);
}

void JointStatusType::
JointVelocity (const JointVelocity_optional& x)
{
  this->JointVelocity_ = x;
}


// ParallelGripperStatusType
// 

const ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation () const
{
  return this->Separation_.get ();
}

ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation ()
{
  return this->Separation_.get ();
}

void ParallelGripperStatusType::
Separation (const Separation_type& x)
{
  this->Separation_.set (x);
}


// PoseStatusType
// 

const PoseStatusType::Pose_type& PoseStatusType::
Pose () const
{
  return this->Pose_.get ();
}

PoseStatusType::Pose_type& PoseStatusType::
Pose ()
{
  return this->Pose_.get ();
}

void PoseStatusType::
Pose (const Pose_type& x)
{
  this->Pose_.set (x);
}

void PoseStatusType::
Pose (::std::auto_ptr< Pose_type > x)
{
  this->Pose_.set (x);
}

const PoseStatusType::Twist_optional& PoseStatusType::
Twist () const
{
  return this->Twist_;
}

PoseStatusType::Twist_optional& PoseStatusType::
Twist ()
{
  return this->Twist_;
}

void PoseStatusType::
Twist (const Twist_type& x)
{
  this->Twist_.set (x);
}

void PoseStatusType::
Twist (const Twist_optional& x)
{
  this->Twist_ = x;
}

void PoseStatusType::
Twist (::std::auto_ptr< Twist_type > x)
{
  this->Twist_.set (x);
}

const PoseStatusType::Wrench_optional& PoseStatusType::
Wrench () const
{
  return this->Wrench_;
}

PoseStatusType::Wrench_optional& PoseStatusType::
Wrench ()
{
  return this->Wrench_;
}

void PoseStatusType::
Wrench (const Wrench_type& x)
{
  this->Wrench_.set (x);
}

void PoseStatusType::
Wrench (const Wrench_optional& x)
{
  this->Wrench_ = x;
}

void PoseStatusType::
Wrench (::std::auto_ptr< Wrench_type > x)
{
  this->Wrench_.set (x);
}


// ThreeFingerGripperStatusType
// 

const ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position () const
{
  return this->Finger1Position_;
}

ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position ()
{
  return this->Finger1Position_;
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_type& x)
{
  this->Finger1Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_optional& x)
{
  this->Finger1Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger1Position (::std::auto_ptr< Finger1Position_type > x)
{
  this->Finger1Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position () const
{
  return this->Finger2Position_;
}

ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position ()
{
  return this->Finger2Position_;
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_type& x)
{
  this->Finger2Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_optional& x)
{
  this->Finger2Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger2Position (::std::auto_ptr< Finger2Position_type > x)
{
  this->Finger2Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position () const
{
  return this->Finger3Position_;
}

ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position ()
{
  return this->Finger3Position_;
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_type& x)
{
  this->Finger3Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_optional& x)
{
  this->Finger3Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger3Position (::std::auto_ptr< Finger3Position_type > x)
{
  this->Finger3Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force () const
{
  return this->Finger1Force_;
}

ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force ()
{
  return this->Finger1Force_;
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_type& x)
{
  this->Finger1Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_optional& x)
{
  this->Finger1Force_ = x;
}

const ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force () const
{
  return this->Finger2Force_;
}

ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force ()
{
  return this->Finger2Force_;
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_type& x)
{
  this->Finger2Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_optional& x)
{
  this->Finger2Force_ = x;
}

const ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force () const
{
  return this->Finger3Force_;
}

ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force ()
{
  return this->Finger3Force_;
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_type& x)
{
  this->Finger3Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_optional& x)
{
  this->Finger3Force_ = x;
}


// VacuumGripperStatusType
// 

const VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered () const
{
  return this->IsPowered_.get ();
}

VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered ()
{
  return this->IsPowered_.get ();
}

void VacuumGripperStatusType::
IsPowered (const IsPowered_type& x)
{
  this->IsPowered_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// CommandStateEnumType
//

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType* CommandStateEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStateEnumType (*this, f, c);
}

CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CommandStateEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CommandStateEnumType_indexes_,
                    _xsd_CommandStateEnumType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_CommandStateEnumType_indexes_ + 4 || _xsd_CommandStateEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CommandStateEnumType::
_xsd_CommandStateEnumType_literals_[4] =
{
  "CRCL_Done",
  "CRCL_Error",
  "CRCL_Working",
  "CRCL_Ready"
};

const CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_indexes_[4] =
{
  ::CommandStateEnumType::CRCL_Done,
  ::CommandStateEnumType::CRCL_Error,
  ::CommandStateEnumType::CRCL_Ready,
  ::CommandStateEnumType::CRCL_Working
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_factory_init (
  "CommandStateEnumType",
  "");

// CommandStatusType
//

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   const CommandState_type& CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   ::std::auto_ptr< CommandState_type > CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandID_ (x.CommandID_, f, this),
  StatusID_ (x.StatusID_, f, this),
  CommandState_ (x.CommandState_, f, this),
  StateDescription_ (x.StateDescription_, f, this)
{
}

CommandStatusType::
CommandStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandID_ (this),
  StatusID_ (this),
  CommandState_ (this),
  StateDescription_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CommandStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandID
    //
    if (n.name () == "CommandID" && n.namespace_ ().empty ())
    {
      if (!CommandID_.present ())
      {
        this->CommandID_.set (CommandID_traits::create (i, f, this));
        continue;
      }
    }

    // StatusID
    //
    if (n.name () == "StatusID" && n.namespace_ ().empty ())
    {
      if (!StatusID_.present ())
      {
        this->StatusID_.set (StatusID_traits::create (i, f, this));
        continue;
      }
    }

    // CommandState
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandState",
          "",
          &::xsd::cxx::tree::factory_impl< CommandState_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandState_.present ())
        {
          ::std::auto_ptr< CommandState_type > r (
            dynamic_cast< CommandState_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandState_.set (r);
          continue;
        }
      }
    }

    // StateDescription
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StateDescription",
          "",
          &::xsd::cxx::tree::factory_impl< StateDescription_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->StateDescription_)
        {
          ::std::auto_ptr< StateDescription_type > r (
            dynamic_cast< StateDescription_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StateDescription_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!CommandID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandID",
      "");
  }

  if (!StatusID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "StatusID",
      "");
  }

  if (!CommandState_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandState",
      "");
  }
}

CommandStatusType* CommandStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStatusType (*this, f, c);
}

CommandStatusType& CommandStatusType::
operator= (const CommandStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandID_ = x.CommandID_;
    this->StatusID_ = x.StatusID_;
    this->CommandState_ = x.CommandState_;
    this->StateDescription_ = x.StateDescription_;
  }

  return *this;
}

CommandStatusType::
~CommandStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_factory_init (
  "CommandStatusType",
  "");

// CRCLStatusType
//

CRCLStatusType::
CRCLStatusType (const CommandStatus_type& CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (::std::auto_ptr< CommandStatus_type > CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (const CRCLStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandStatus_ (x.CommandStatus_, f, this),
  JointStatuses_ (x.JointStatuses_, f, this),
  PoseStatus_ (x.PoseStatus_, f, this),
  GripperStatus_ (x.GripperStatus_, f, this)
{
}

CRCLStatusType::
CRCLStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandStatus_ (this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCLStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandStatus",
          "",
          &::xsd::cxx::tree::factory_impl< CommandStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandStatus_.present ())
        {
          ::std::auto_ptr< CommandStatus_type > r (
            dynamic_cast< CommandStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandStatus_.set (r);
          continue;
        }
      }
    }

    // JointStatuses
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatuses",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatuses_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->JointStatuses_)
        {
          ::std::auto_ptr< JointStatuses_type > r (
            dynamic_cast< JointStatuses_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointStatuses_.set (r);
          continue;
        }
      }
    }

    // PoseStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PoseStatus",
          "",
          &::xsd::cxx::tree::factory_impl< PoseStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->PoseStatus_)
        {
          ::std::auto_ptr< PoseStatus_type > r (
            dynamic_cast< PoseStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PoseStatus_.set (r);
          continue;
        }
      }
    }

    // GripperStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperStatus",
          "",
          &::xsd::cxx::tree::factory_impl< GripperStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->GripperStatus_)
        {
          ::std::auto_ptr< GripperStatus_type > r (
            dynamic_cast< GripperStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperStatus_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!CommandStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandStatus",
      "");
  }
}

CRCLStatusType* CRCLStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCLStatusType (*this, f, c);
}

CRCLStatusType& CRCLStatusType::
operator= (const CRCLStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandStatus_ = x.CommandStatus_;
    this->JointStatuses_ = x.JointStatuses_;
    this->PoseStatus_ = x.PoseStatus_;
    this->GripperStatus_ = x.GripperStatus_;
  }

  return *this;
}

CRCLStatusType::
~CRCLStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_factory_init (
  "CRCLStatusType",
  "");

// GripperStatusType
//

GripperStatusType::
GripperStatusType (const GripperName_type& GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this)
{
}

GripperStatusType::
GripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this)
{
}

GripperStatusType::
GripperStatusType (const GripperStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  GripperName_ (x.GripperName_, f, this)
{
}

GripperStatusType::
GripperStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  GripperName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void GripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GripperName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperName",
          "",
          &::xsd::cxx::tree::factory_impl< GripperName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!GripperName_.present ())
        {
          ::std::auto_ptr< GripperName_type > r (
            dynamic_cast< GripperName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperName_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!GripperName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GripperName",
      "");
  }
}

GripperStatusType* GripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GripperStatusType (*this, f, c);
}

GripperStatusType& GripperStatusType::
operator= (const GripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->GripperName_ = x.GripperName_;
  }

  return *this;
}

GripperStatusType::
~GripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_factory_init (
  "GripperStatusType",
  "");

// JointStatusesType
//

JointStatusesType::
JointStatusesType ()
: ::DataThingType (),
  JointStatus_ (this)
{
}

JointStatusesType::
JointStatusesType (const JointStatusesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointStatus_ (x.JointStatus_, f, this)
{
}

JointStatusesType::
JointStatusesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatus",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< JointStatus_type > r (
          dynamic_cast< JointStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->JointStatus_.push_back (r);
        continue;
      }
    }

    break;
  }
}

JointStatusesType* JointStatusesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusesType (*this, f, c);
}

JointStatusesType& JointStatusesType::
operator= (const JointStatusesType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointStatus_ = x.JointStatus_;
  }

  return *this;
}

JointStatusesType::
~JointStatusesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_factory_init (
  "JointStatusesType",
  "");

// JointStatusType
//

JointStatusType::
JointStatusType (const JointNumber_type& JointNumber)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
}

JointStatusType::
JointStatusType (const JointStatusType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointPosition_ (x.JointPosition_, f, this),
  JointTorqueOrForce_ (x.JointTorqueOrForce_, f, this),
  JointVelocity_ (x.JointVelocity_, f, this)
{
}

JointStatusType::
JointStatusType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointPosition
    //
    if (n.name () == "JointPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointPosition_)
      {
        this->JointPosition_.set (JointPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointTorqueOrForce
    //
    if (n.name () == "JointTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!this->JointTorqueOrForce_)
      {
        this->JointTorqueOrForce_.set (JointTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // JointVelocity
    //
    if (n.name () == "JointVelocity" && n.namespace_ ().empty ())
    {
      if (!this->JointVelocity_)
      {
        this->JointVelocity_.set (JointVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }
}

JointStatusType* JointStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusType (*this, f, c);
}

JointStatusType& JointStatusType::
operator= (const JointStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointPosition_ = x.JointPosition_;
    this->JointTorqueOrForce_ = x.JointTorqueOrForce_;
    this->JointVelocity_ = x.JointVelocity_;
  }

  return *this;
}

JointStatusType::
~JointStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_factory_init (
  "JointStatusType",
  "");

// ParallelGripperStatusType
//

ParallelGripperStatusType::
ParallelGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                           const Separation_type& Separation)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const GripperName_type& GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ParallelGripperStatusType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Separation_ (x.Separation_, f, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Separation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParallelGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Separation
    //
    if (n.name () == "Separation" && n.namespace_ ().empty ())
    {
      if (!Separation_.present ())
      {
        this->Separation_.set (Separation_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Separation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Separation",
      "");
  }
}

ParallelGripperStatusType* ParallelGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParallelGripperStatusType (*this, f, c);
}

ParallelGripperStatusType& ParallelGripperStatusType::
operator= (const ParallelGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Separation_ = x.Separation_;
  }

  return *this;
}

ParallelGripperStatusType::
~ParallelGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_factory_init (
  "ParallelGripperStatusType",
  "");

// PoseStatusType
//

PoseStatusType::
PoseStatusType (const Pose_type& Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this)
{
}

PoseStatusType::
PoseStatusType (::std::auto_ptr< Pose_type > Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this)
{
}

PoseStatusType::
PoseStatusType (const PoseStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Pose_ (x.Pose_, f, this),
  Twist_ (x.Twist_, f, this),
  Wrench_ (x.Wrench_, f, this)
{
}

PoseStatusType::
PoseStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Pose_ (this),
  Twist_ (this),
  Wrench_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Pose
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Pose",
          "",
          &::xsd::cxx::tree::factory_impl< Pose_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Pose_.present ())
        {
          ::std::auto_ptr< Pose_type > r (
            dynamic_cast< Pose_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Pose_.set (r);
          continue;
        }
      }
    }

    // Twist
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Twist",
          "",
          &::xsd::cxx::tree::factory_impl< Twist_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Twist_)
        {
          ::std::auto_ptr< Twist_type > r (
            dynamic_cast< Twist_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Twist_.set (r);
          continue;
        }
      }
    }

    // Wrench
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Wrench",
          "",
          &::xsd::cxx::tree::factory_impl< Wrench_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Wrench_)
        {
          ::std::auto_ptr< Wrench_type > r (
            dynamic_cast< Wrench_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Wrench_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Pose_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pose",
      "");
  }
}

PoseStatusType* PoseStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseStatusType (*this, f, c);
}

PoseStatusType& PoseStatusType::
operator= (const PoseStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Pose_ = x.Pose_;
    this->Twist_ = x.Twist_;
    this->Wrench_ = x.Wrench_;
  }

  return *this;
}

PoseStatusType::
~PoseStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_factory_init (
  "PoseStatusType",
  "");

// ThreeFingerGripperStatusType
//

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const GripperName_type& GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ThreeFingerGripperStatusType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Finger1Position_ (x.Finger1Position_, f, this),
  Finger2Position_ (x.Finger2Position_, f, this),
  Finger3Position_ (x.Finger3Position_, f, this),
  Finger1Force_ (x.Finger1Force_, f, this),
  Finger2Force_ (x.Finger2Force_, f, this),
  Finger3Force_ (x.Finger3Force_, f, this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ThreeFingerGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Finger1Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger1Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger1Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger1Position_)
        {
          ::std::auto_ptr< Finger1Position_type > r (
            dynamic_cast< Finger1Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger1Position_.set (r);
          continue;
        }
      }
    }

    // Finger2Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger2Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger2Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger2Position_)
        {
          ::std::auto_ptr< Finger2Position_type > r (
            dynamic_cast< Finger2Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger2Position_.set (r);
          continue;
        }
      }
    }

    // Finger3Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger3Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger3Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger3Position_)
        {
          ::std::auto_ptr< Finger3Position_type > r (
            dynamic_cast< Finger3Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger3Position_.set (r);
          continue;
        }
      }
    }

    // Finger1Force
    //
    if (n.name () == "Finger1Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger1Force_)
      {
        this->Finger1Force_.set (Finger1Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger2Force
    //
    if (n.name () == "Finger2Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger2Force_)
      {
        this->Finger2Force_.set (Finger2Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger3Force
    //
    if (n.name () == "Finger3Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger3Force_)
      {
        this->Finger3Force_.set (Finger3Force_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

ThreeFingerGripperStatusType* ThreeFingerGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ThreeFingerGripperStatusType (*this, f, c);
}

ThreeFingerGripperStatusType& ThreeFingerGripperStatusType::
operator= (const ThreeFingerGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Finger1Position_ = x.Finger1Position_;
    this->Finger2Position_ = x.Finger2Position_;
    this->Finger3Position_ = x.Finger3Position_;
    this->Finger1Force_ = x.Finger1Force_;
    this->Finger2Force_ = x.Finger2Force_;
    this->Finger3Force_ = x.Finger3Force_;
  }

  return *this;
}

ThreeFingerGripperStatusType::
~ThreeFingerGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_factory_init (
  "ThreeFingerGripperStatusType",
  "");

// VacuumGripperStatusType
//

VacuumGripperStatusType::
VacuumGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const GripperName_type& GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const VacuumGripperStatusType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  IsPowered_ (x.IsPowered_, f, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  IsPowered_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VacuumGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IsPowered
    //
    if (n.name () == "IsPowered" && n.namespace_ ().empty ())
    {
      if (!IsPowered_.present ())
      {
        this->IsPowered_.set (IsPowered_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!IsPowered_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IsPowered",
      "");
  }
}

VacuumGripperStatusType* VacuumGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VacuumGripperStatusType (*this, f, c);
}

VacuumGripperStatusType& VacuumGripperStatusType::
operator= (const VacuumGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->IsPowered_ = x.IsPowered_;
  }

  return *this;
}

VacuumGripperStatusType::
~VacuumGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_factory_init (
  "VacuumGripperStatusType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CRCLStatusType > (
      ::CRCLStatus (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::DOMDocument& d,
            const ::CRCLStatusType& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    if (n.name () == "CRCLStatus" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CRCLStatus",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CRCLStatus (const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    d = ::xsd::cxx::xml::dom::serialize< char > (
      "CRCLStatus",
      "",
      m, f);
  }
  else
  {
    d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      m, s, f);
  }

  ::CRCLStatus (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const CommandStateEnumType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const CommandStateEnumType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const CommandStateEnumType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_serializer_init (
  "CommandStateEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CommandStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CommandID",
        e));

    s << i.CommandID ();
  }

  // StatusID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "StatusID",
        e));

    s << i.StatusID ();
  }

  // CommandState
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CommandStatusType::CommandState_type& x (i.CommandState ());
    if (typeid (CommandStatusType::CommandState_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandState",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandState",
        "",
        false, true, e, x);
  }

  // StateDescription
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.StateDescription ())
    {
      const CommandStatusType::StateDescription_type& x (*i.StateDescription ());
      if (typeid (CommandStatusType::StateDescription_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StateDescription",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StateDescription",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_serializer_init (
  "CommandStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CRCLStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CRCLStatusType::CommandStatus_type& x (i.CommandStatus ());
    if (typeid (CRCLStatusType::CommandStatus_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandStatus",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandStatus",
        "",
        false, true, e, x);
  }

  // JointStatuses
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.JointStatuses ())
    {
      const CRCLStatusType::JointStatuses_type& x (*i.JointStatuses ());
      if (typeid (CRCLStatusType::JointStatuses_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatuses",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "JointStatuses",
          "",
          false, true, e, x);
    }
  }

  // PoseStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.PoseStatus ())
    {
      const CRCLStatusType::PoseStatus_type& x (*i.PoseStatus ());
      if (typeid (CRCLStatusType::PoseStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PoseStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PoseStatus",
          "",
          false, true, e, x);
    }
  }

  // GripperStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.GripperStatus ())
    {
      const CRCLStatusType::GripperStatus_type& x (*i.GripperStatus ());
      if (typeid (CRCLStatusType::GripperStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GripperStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "GripperStatus",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_serializer_init (
  "CRCLStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GripperStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // GripperName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const GripperStatusType::GripperName_type& x (i.GripperName ());
    if (typeid (GripperStatusType::GripperName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GripperName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "GripperName",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_serializer_init (
  "GripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusesType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (JointStatusesType::JointStatus_const_iterator
         b (i.JointStatus ().begin ()), n (i.JointStatus ().end ());
         b != n; ++b)
    {
      if (typeid (JointStatusesType::JointStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "JointStatus",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_serializer_init (
  "JointStatusesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointPosition
  //
  if (i.JointPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointPosition",
        e));

    s << ::xml_schema::as_decimal(*i.JointPosition ());
  }

  // JointTorqueOrForce
  //
  if (i.JointTorqueOrForce ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointTorqueOrForce",
        e));

    s << ::xml_schema::as_decimal(*i.JointTorqueOrForce ());
  }

  // JointVelocity
  //
  if (i.JointVelocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointVelocity",
        e));

    s << ::xml_schema::as_decimal(*i.JointVelocity ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_serializer_init (
  "JointStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParallelGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Separation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Separation",
        e));

    s << ::xml_schema::as_decimal(i.Separation ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_serializer_init (
  "ParallelGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Pose
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseStatusType::Pose_type& x (i.Pose ());
    if (typeid (PoseStatusType::Pose_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Pose",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Pose",
        "",
        false, true, e, x);
  }

  // Twist
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Twist ())
    {
      const PoseStatusType::Twist_type& x (*i.Twist ());
      if (typeid (PoseStatusType::Twist_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Twist",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Twist",
          "",
          false, true, e, x);
    }
  }

  // Wrench
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Wrench ())
    {
      const PoseStatusType::Wrench_type& x (*i.Wrench ());
      if (typeid (PoseStatusType::Wrench_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Wrench",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Wrench",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_serializer_init (
  "PoseStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ThreeFingerGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Finger1Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger1Position ())
    {
      const ThreeFingerGripperStatusType::Finger1Position_type& x (*i.Finger1Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger1Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger1Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger1Position",
          "",
          false, true, e, x);
    }
  }

  // Finger2Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger2Position ())
    {
      const ThreeFingerGripperStatusType::Finger2Position_type& x (*i.Finger2Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger2Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger2Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger2Position",
          "",
          false, true, e, x);
    }
  }

  // Finger3Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger3Position ())
    {
      const ThreeFingerGripperStatusType::Finger3Position_type& x (*i.Finger3Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger3Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger3Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger3Position",
          "",
          false, true, e, x);
    }
  }

  // Finger1Force
  //
  if (i.Finger1Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger1Force",
        e));

    s << ::xml_schema::as_decimal(*i.Finger1Force ());
  }

  // Finger2Force
  //
  if (i.Finger2Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger2Force",
        e));

    s << ::xml_schema::as_decimal(*i.Finger2Force ());
  }

  // Finger3Force
  //
  if (i.Finger3Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger3Force",
        e));

    s << ::xml_schema::as_decimal(*i.Finger3Force ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_serializer_init (
  "ThreeFingerGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const VacuumGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // IsPowered
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IsPowered",
        e));

    s << i.IsPowered ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_serializer_init (
  "VacuumGripperStatusType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

