// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataPrimitives.hxx"

// AngleUnitEnumType
// 

AngleUnitEnumType::
AngleUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v])
{
}

AngleUnitEnumType::
AngleUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const AngleUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

AngleUnitEnumType& AngleUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v]);

  return *this;
}


// DataThingType
// 

const DataThingType::Name_optional& DataThingType::
Name () const
{
  return this->Name_;
}

DataThingType::Name_optional& DataThingType::
Name ()
{
  return this->Name_;
}

void DataThingType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DataThingType::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void DataThingType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// ForceUnitEnumType
// 

ForceUnitEnumType::
ForceUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v])
{
}

ForceUnitEnumType::
ForceUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ForceUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

ForceUnitEnumType& ForceUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v]);

  return *this;
}


// FractionType
// 


// LengthUnitEnumType
// 

LengthUnitEnumType::
LengthUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v])
{
}

LengthUnitEnumType::
LengthUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const LengthUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

LengthUnitEnumType& LengthUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v]);

  return *this;
}


// PointType
// 

const PointType::X_type& PointType::
X () const
{
  return this->X_.get ();
}

PointType::X_type& PointType::
X ()
{
  return this->X_.get ();
}

void PointType::
X (const X_type& x)
{
  this->X_.set (x);
}

const PointType::Y_type& PointType::
Y () const
{
  return this->Y_.get ();
}

PointType::Y_type& PointType::
Y ()
{
  return this->Y_.get ();
}

void PointType::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const PointType::Z_type& PointType::
Z () const
{
  return this->Z_.get ();
}

PointType::Z_type& PointType::
Z ()
{
  return this->Z_.get ();
}

void PointType::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// PoseType
// 

const PoseType::Point_type& PoseType::
Point () const
{
  return this->Point_.get ();
}

PoseType::Point_type& PoseType::
Point ()
{
  return this->Point_.get ();
}

void PoseType::
Point (const Point_type& x)
{
  this->Point_.set (x);
}

void PoseType::
Point (::std::auto_ptr< Point_type > x)
{
  this->Point_.set (x);
}

const PoseType::XAxis_type& PoseType::
XAxis () const
{
  return this->XAxis_.get ();
}

PoseType::XAxis_type& PoseType::
XAxis ()
{
  return this->XAxis_.get ();
}

void PoseType::
XAxis (const XAxis_type& x)
{
  this->XAxis_.set (x);
}

void PoseType::
XAxis (::std::auto_ptr< XAxis_type > x)
{
  this->XAxis_.set (x);
}

const PoseType::ZAxis_type& PoseType::
ZAxis () const
{
  return this->ZAxis_.get ();
}

PoseType::ZAxis_type& PoseType::
ZAxis ()
{
  return this->ZAxis_.get ();
}

void PoseType::
ZAxis (const ZAxis_type& x)
{
  this->ZAxis_.set (x);
}

void PoseType::
ZAxis (::std::auto_ptr< ZAxis_type > x)
{
  this->ZAxis_.set (x);
}


// PositiveDecimalType
// 


// TorqueUnitEnumType
// 

TorqueUnitEnumType::
TorqueUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v])
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const TorqueUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

TorqueUnitEnumType& TorqueUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v]);

  return *this;
}


// TwistType
// 

const TwistType::LinearVelocity_type& TwistType::
LinearVelocity () const
{
  return this->LinearVelocity_.get ();
}

TwistType::LinearVelocity_type& TwistType::
LinearVelocity ()
{
  return this->LinearVelocity_.get ();
}

void TwistType::
LinearVelocity (const LinearVelocity_type& x)
{
  this->LinearVelocity_.set (x);
}

void TwistType::
LinearVelocity (::std::auto_ptr< LinearVelocity_type > x)
{
  this->LinearVelocity_.set (x);
}

const TwistType::AngularVelocity_type& TwistType::
AngularVelocity () const
{
  return this->AngularVelocity_.get ();
}

TwistType::AngularVelocity_type& TwistType::
AngularVelocity ()
{
  return this->AngularVelocity_.get ();
}

void TwistType::
AngularVelocity (const AngularVelocity_type& x)
{
  this->AngularVelocity_.set (x);
}

void TwistType::
AngularVelocity (::std::auto_ptr< AngularVelocity_type > x)
{
  this->AngularVelocity_.set (x);
}


// VectorType
// 

const VectorType::I_type& VectorType::
I () const
{
  return this->I_.get ();
}

VectorType::I_type& VectorType::
I ()
{
  return this->I_.get ();
}

void VectorType::
I (const I_type& x)
{
  this->I_.set (x);
}

const VectorType::J_type& VectorType::
J () const
{
  return this->J_.get ();
}

VectorType::J_type& VectorType::
J ()
{
  return this->J_.get ();
}

void VectorType::
J (const J_type& x)
{
  this->J_.set (x);
}

const VectorType::K_type& VectorType::
K () const
{
  return this->K_.get ();
}

VectorType::K_type& VectorType::
K ()
{
  return this->K_.get ();
}

void VectorType::
K (const K_type& x)
{
  this->K_.set (x);
}


// WrenchType
// 

const WrenchType::Force_type& WrenchType::
Force () const
{
  return this->Force_.get ();
}

WrenchType::Force_type& WrenchType::
Force ()
{
  return this->Force_.get ();
}

void WrenchType::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void WrenchType::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}

const WrenchType::Moment_type& WrenchType::
Moment () const
{
  return this->Moment_.get ();
}

WrenchType::Moment_type& WrenchType::
Moment ()
{
  return this->Moment_.get ();
}

void WrenchType::
Moment (const Moment_type& x)
{
  this->Moment_.set (x);
}

void WrenchType::
Moment (::std::auto_ptr< Moment_type > x)
{
  this->Moment_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// AngleUnitEnumType
//

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType* AngleUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AngleUnitEnumType (*this, f, c);
}

AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AngleUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_AngleUnitEnumType_indexes_,
                    _xsd_AngleUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_AngleUnitEnumType_indexes_ + 2 || _xsd_AngleUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const AngleUnitEnumType::
_xsd_AngleUnitEnumType_literals_[2] =
{
  "degree",
  "radian"
};

const AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_indexes_[2] =
{
  ::AngleUnitEnumType::degree,
  ::AngleUnitEnumType::radian
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, AngleUnitEnumType >
_xsd_AngleUnitEnumType_type_factory_init (
  "AngleUnitEnumType",
  "");

// DataThingType
//

DataThingType::
DataThingType ()
: ::xml_schema::type (),
  Name_ (this)
{
}

DataThingType::
DataThingType (const DataThingType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

DataThingType::
DataThingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DataThingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Name",
          "",
          &::xsd::cxx::tree::factory_impl< Name_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Name_)
        {
          ::std::auto_ptr< Name_type > r (
            dynamic_cast< Name_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

DataThingType* DataThingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataThingType (*this, f, c);
}

DataThingType& DataThingType::
operator= (const DataThingType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

DataThingType::
~DataThingType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DataThingType >
_xsd_DataThingType_type_factory_init (
  "DataThingType",
  "");

// ForceUnitEnumType
//

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType* ForceUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceUnitEnumType (*this, f, c);
}

ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceUnitEnumType_indexes_,
                    _xsd_ForceUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ForceUnitEnumType_indexes_ + 3 || _xsd_ForceUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceUnitEnumType::
_xsd_ForceUnitEnumType_literals_[3] =
{
  "newton",
  "pound",
  "ounce"
};

const ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_indexes_[3] =
{
  ::ForceUnitEnumType::newton,
  ::ForceUnitEnumType::ounce,
  ::ForceUnitEnumType::pound
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceUnitEnumType >
_xsd_ForceUnitEnumType_type_factory_init (
  "ForceUnitEnumType",
  "");

// FractionType
//

FractionType::
FractionType (const ::xml_schema::decimal& _xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
{
}

FractionType::
FractionType (const FractionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
{
}

FractionType::
FractionType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
{
}

FractionType* FractionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FractionType (*this, f, c);
}

FractionType::
~FractionType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, FractionType >
_xsd_FractionType_type_factory_init (
  "FractionType",
  "");

// LengthUnitEnumType
//

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType* LengthUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LengthUnitEnumType (*this, f, c);
}

LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LengthUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_LengthUnitEnumType_indexes_,
                    _xsd_LengthUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_LengthUnitEnumType_indexes_ + 3 || _xsd_LengthUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const LengthUnitEnumType::
_xsd_LengthUnitEnumType_literals_[3] =
{
  "meter",
  "millimeter",
  "inch"
};

const LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_indexes_[3] =
{
  ::LengthUnitEnumType::inch,
  ::LengthUnitEnumType::meter,
  ::LengthUnitEnumType::millimeter
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, LengthUnitEnumType >
_xsd_LengthUnitEnumType_type_factory_init (
  "LengthUnitEnumType",
  "");

// PointType
//

PointType::
PointType (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
: ::DataThingType (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

PointType::
PointType (const PointType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

PointType::
PointType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      if (!X_.present ())
      {
        this->X_.set (X_traits::create (i, f, this));
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      if (!Y_.present ())
      {
        this->Y_.set (Y_traits::create (i, f, this));
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      if (!Z_.present ())
      {
        this->Z_.set (Z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Z",
      "");
  }
}

PointType* PointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PointType (*this, f, c);
}

PointType& PointType::
operator= (const PointType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

PointType::
~PointType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointType >
_xsd_PointType_type_factory_init (
  "PointType",
  "");

// PoseType
//

PoseType::
PoseType (const Point_type& Point,
          const XAxis_type& XAxis,
          const ZAxis_type& ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (::std::auto_ptr< Point_type > Point,
          ::std::auto_ptr< XAxis_type > XAxis,
          ::std::auto_ptr< ZAxis_type > ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (const PoseType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Point_ (x.Point_, f, this),
  XAxis_ (x.XAxis_, f, this),
  ZAxis_ (x.ZAxis_, f, this)
{
}

PoseType::
PoseType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Point_ (this),
  XAxis_ (this),
  ZAxis_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Point
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Point",
          "",
          &::xsd::cxx::tree::factory_impl< Point_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Point_.present ())
        {
          ::std::auto_ptr< Point_type > r (
            dynamic_cast< Point_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Point_.set (r);
          continue;
        }
      }
    }

    // XAxis
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAxis",
          "",
          &::xsd::cxx::tree::factory_impl< XAxis_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!XAxis_.present ())
        {
          ::std::auto_ptr< XAxis_type > r (
            dynamic_cast< XAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->XAxis_.set (r);
          continue;
        }
      }
    }

    // ZAxis
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ZAxis",
          "",
          &::xsd::cxx::tree::factory_impl< ZAxis_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ZAxis_.present ())
        {
          ::std::auto_ptr< ZAxis_type > r (
            dynamic_cast< ZAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ZAxis_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Point_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Point",
      "");
  }

  if (!XAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "XAxis",
      "");
  }

  if (!ZAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ZAxis",
      "");
  }
}

PoseType* PoseType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseType (*this, f, c);
}

PoseType& PoseType::
operator= (const PoseType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Point_ = x.Point_;
    this->XAxis_ = x.XAxis_;
    this->ZAxis_ = x.ZAxis_;
  }

  return *this;
}

PoseType::
~PoseType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseType >
_xsd_PoseType_type_factory_init (
  "PoseType",
  "");

// PositiveDecimalType
//

PositiveDecimalType::
PositiveDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
{
}

PositiveDecimalType::
PositiveDecimalType (const PositiveDecimalType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
{
}

PositiveDecimalType* PositiveDecimalType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDecimalType (*this, f, c);
}

PositiveDecimalType::
~PositiveDecimalType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PositiveDecimalType >
_xsd_PositiveDecimalType_type_factory_init (
  "PositiveDecimalType",
  "");

// TorqueUnitEnumType
//

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType* TorqueUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TorqueUnitEnumType (*this, f, c);
}

TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TorqueUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_TorqueUnitEnumType_indexes_,
                    _xsd_TorqueUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_TorqueUnitEnumType_indexes_ + 2 || _xsd_TorqueUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_literals_[2] =
{
  "newtonMeter",
  "footPound"
};

const TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_indexes_[2] =
{
  ::TorqueUnitEnumType::footPound,
  ::TorqueUnitEnumType::newtonMeter
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorqueUnitEnumType >
_xsd_TorqueUnitEnumType_type_factory_init (
  "TorqueUnitEnumType",
  "");

// TwistType
//

TwistType::
TwistType (const LinearVelocity_type& LinearVelocity,
           const AngularVelocity_type& AngularVelocity)
: ::DataThingType (),
  LinearVelocity_ (LinearVelocity, this),
  AngularVelocity_ (AngularVelocity, this)
{
}

TwistType::
TwistType (::std::auto_ptr< LinearVelocity_type > LinearVelocity,
           ::std::auto_ptr< AngularVelocity_type > AngularVelocity)
: ::DataThingType (),
  LinearVelocity_ (LinearVelocity, this),
  AngularVelocity_ (AngularVelocity, this)
{
}

TwistType::
TwistType (const TwistType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  LinearVelocity_ (x.LinearVelocity_, f, this),
  AngularVelocity_ (x.AngularVelocity_, f, this)
{
}

TwistType::
TwistType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  LinearVelocity_ (this),
  AngularVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TwistType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LinearVelocity
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LinearVelocity",
          "",
          &::xsd::cxx::tree::factory_impl< LinearVelocity_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!LinearVelocity_.present ())
        {
          ::std::auto_ptr< LinearVelocity_type > r (
            dynamic_cast< LinearVelocity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LinearVelocity_.set (r);
          continue;
        }
      }
    }

    // AngularVelocity
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AngularVelocity",
          "",
          &::xsd::cxx::tree::factory_impl< AngularVelocity_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!AngularVelocity_.present ())
        {
          ::std::auto_ptr< AngularVelocity_type > r (
            dynamic_cast< AngularVelocity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngularVelocity_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!LinearVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LinearVelocity",
      "");
  }

  if (!AngularVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AngularVelocity",
      "");
  }
}

TwistType* TwistType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TwistType (*this, f, c);
}

TwistType& TwistType::
operator= (const TwistType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->LinearVelocity_ = x.LinearVelocity_;
    this->AngularVelocity_ = x.AngularVelocity_;
  }

  return *this;
}

TwistType::
~TwistType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TwistType >
_xsd_TwistType_type_factory_init (
  "TwistType",
  "");

// VectorType
//

VectorType::
VectorType (const I_type& I,
            const J_type& J,
            const K_type& K)
: ::DataThingType (),
  I_ (I, this),
  J_ (J, this),
  K_ (K, this)
{
}

VectorType::
VectorType (const VectorType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

VectorType::
VectorType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  I_ (this),
  J_ (this),
  K_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VectorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // I
    //
    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      if (!I_.present ())
      {
        this->I_.set (I_traits::create (i, f, this));
        continue;
      }
    }

    // J
    //
    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      if (!J_.present ())
      {
        this->J_.set (J_traits::create (i, f, this));
        continue;
      }
    }

    // K
    //
    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      if (!K_.present ())
      {
        this->K_.set (K_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!I_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I",
      "");
  }

  if (!J_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "J",
      "");
  }

  if (!K_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "K",
      "");
  }
}

VectorType* VectorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VectorType (*this, f, c);
}

VectorType& VectorType::
operator= (const VectorType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->I_ = x.I_;
    this->J_ = x.J_;
    this->K_ = x.K_;
  }

  return *this;
}

VectorType::
~VectorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, VectorType >
_xsd_VectorType_type_factory_init (
  "VectorType",
  "");

// WrenchType
//

WrenchType::
WrenchType (const Force_type& Force,
            const Moment_type& Moment)
: ::DataThingType (),
  Force_ (Force, this),
  Moment_ (Moment, this)
{
}

WrenchType::
WrenchType (::std::auto_ptr< Force_type > Force,
            ::std::auto_ptr< Moment_type > Moment)
: ::DataThingType (),
  Force_ (Force, this),
  Moment_ (Moment, this)
{
}

WrenchType::
WrenchType (const WrenchType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Force_ (x.Force_, f, this),
  Moment_ (x.Moment_, f, this)
{
}

WrenchType::
WrenchType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Force_ (this),
  Moment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void WrenchType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Force
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Force",
          "",
          &::xsd::cxx::tree::factory_impl< Force_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Force_.present ())
        {
          ::std::auto_ptr< Force_type > r (
            dynamic_cast< Force_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Force_.set (r);
          continue;
        }
      }
    }

    // Moment
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Moment",
          "",
          &::xsd::cxx::tree::factory_impl< Moment_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Moment_.present ())
        {
          ::std::auto_ptr< Moment_type > r (
            dynamic_cast< Moment_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Moment_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Force",
      "");
  }

  if (!Moment_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Moment",
      "");
  }
}

WrenchType* WrenchType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class WrenchType (*this, f, c);
}

WrenchType& WrenchType::
operator= (const WrenchType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Force_ = x.Force_;
    this->Moment_ = x.Moment_;
  }

  return *this;
}

WrenchType::
~WrenchType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, WrenchType >
_xsd_WrenchType_type_factory_init (
  "WrenchType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const AngleUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AngleUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AngleUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AngleUnitEnumType >
_xsd_AngleUnitEnumType_type_serializer_init (
  "AngleUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DataThingType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Name ())
    {
      const DataThingType::Name_type& x (*i.Name ());
      if (typeid (DataThingType::Name_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Name",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DataThingType >
_xsd_DataThingType_type_serializer_init (
  "DataThingType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ForceUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceUnitEnumType >
_xsd_ForceUnitEnumType_type_serializer_init (
  "ForceUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const FractionType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FractionType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FractionType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FractionType >
_xsd_FractionType_type_serializer_init (
  "FractionType",
  "");


void
operator<< (::xercesc::DOMElement& e, const LengthUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const LengthUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const LengthUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LengthUnitEnumType >
_xsd_LengthUnitEnumType_type_serializer_init (
  "LengthUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PointType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // X
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X",
        e));

    s << ::xml_schema::as_decimal(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Y",
        e));

    s << ::xml_schema::as_decimal(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Z",
        e));

    s << ::xml_schema::as_decimal(i.Z ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointType >
_xsd_PointType_type_serializer_init (
  "PointType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Point
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::Point_type& x (i.Point ());
    if (typeid (PoseType::Point_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Point",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Point",
        "",
        false, true, e, x);
  }

  // XAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::XAxis_type& x (i.XAxis ());
    if (typeid (PoseType::XAxis_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "XAxis",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "XAxis",
        "",
        false, true, e, x);
  }

  // ZAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::ZAxis_type& x (i.ZAxis ());
    if (typeid (PoseType::ZAxis_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ZAxis",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ZAxis",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseType >
_xsd_PoseType_type_serializer_init (
  "PoseType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PositiveDecimalType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PositiveDecimalType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PositiveDecimalType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PositiveDecimalType >
_xsd_PositiveDecimalType_type_serializer_init (
  "PositiveDecimalType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TorqueUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const TorqueUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const TorqueUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorqueUnitEnumType >
_xsd_TorqueUnitEnumType_type_serializer_init (
  "TorqueUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TwistType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // LinearVelocity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TwistType::LinearVelocity_type& x (i.LinearVelocity ());
    if (typeid (TwistType::LinearVelocity_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LinearVelocity",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "LinearVelocity",
        "",
        false, true, e, x);
  }

  // AngularVelocity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TwistType::AngularVelocity_type& x (i.AngularVelocity ());
    if (typeid (TwistType::AngularVelocity_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AngularVelocity",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "AngularVelocity",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TwistType >
_xsd_TwistType_type_serializer_init (
  "TwistType",
  "");


void
operator<< (::xercesc::DOMElement& e, const VectorType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // I
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "I",
        e));

    s << ::xml_schema::as_decimal(i.I ());
  }

  // J
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "J",
        e));

    s << ::xml_schema::as_decimal(i.J ());
  }

  // K
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "K",
        e));

    s << ::xml_schema::as_decimal(i.K ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VectorType >
_xsd_VectorType_type_serializer_init (
  "VectorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const WrenchType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Force
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const WrenchType::Force_type& x (i.Force ());
    if (typeid (WrenchType::Force_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Force",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Force",
        "",
        false, true, e, x);
  }

  // Moment
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const WrenchType::Moment_type& x (i.Moment ());
    if (typeid (WrenchType::Moment_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Moment",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Moment",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WrenchType >
_xsd_WrenchType_type_serializer_init (
  "WrenchType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

