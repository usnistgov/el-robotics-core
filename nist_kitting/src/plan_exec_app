#!/usr/bin/python

import sys, time, getopt, string, threading, re, socket, ConfigParser, StringIO, xml.etree.ElementTree as ET, random, subprocess, shlex

from crcl import *

import MySQLdb

xmldec = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
uri = "http://www.w3.org/2001/XMLSchema-instance"
xsi = "{" + uri + "}"
dict = {"xmlns:xsi" : uri}

INIFILE = ""
PLANFILE = ""
ROBOT_PORT = ""
ROBOT_HOST = ""
GRIPPER_PORT = ""
GRIPPER_HOST = ""
DEBUG = False
PERIOD = 0.5

# the global subordinate statuses

RobotCommandID = 0
RobotCommandState = CommandStateType.READY

GripperCommandID = 0
GripperCommandState = CommandStateType.READY

XAXIS = VectorType(1, 0, 0)
ZAXIS = VectorType(0, 0, 1)

# the MySQL database query cursor
db_cursor = None

def robot_reader(conn):
    global DEBUG, RobotCommandID, RobotCommandState
    size = 1024
    while True:
        try: data = conn.recv(size)
        except: break
        if not data: break
        if DEBUG: print data
        try:
            tree = ET.parse(StringIO.StringIO(data))
            root = tree.getroot()
            if root.tag == "CRCLStatus":
                for child in root:
                    if child.tag == "CommandStatus":
                        t = child.findtext("CommandID")
                        if (t != None) and (t != ""): RobotCommandID = int(t)
                        t = child.findtext("CommandState")
                        if (t != None) and (t != ""): RobotCommandState = toCommandStateType(t)
                        # else Pose, GripperStatus, etc.
            if DEBUG: print "Robot", RobotCommandID, RobotCommandState
        except: pass
    conn.close()

def gripper_reader(conn):
    global DEBUG, GripperCommandID, GripperCommandState
    size = 1024
    while True:
        try: data = conn.recv(size)
        except: break
        if not data: break
        if DEBUG: print data
        try:
            tree = ET.parse(StringIO.StringIO(data))
            root = tree.getroot()
            if root.tag == "CRCLStatus":
                for child in root:
                    if child.tag == "CommandStatus":
                        t = child.findtext("CommandID")
                        if (t != None) and (t != ""): GripperCommandID = int(t)
                        t = child.findtext("CommandState")
                        if (t != None) and (t != ""): GripperCommandState = toCommandStateType(t)
                        # else Pose, GripperStatus, etc.
            if DEBUG: print "Gripper", GripperCommandID, GripperCommandState
        except: pass
    conn.close()

def robot_poll(cid, tm):
    global DEBUG, PERIOD, RobotCommandID, RobotCommandState
    end = time.time() + tm
    while True:
        if (RobotCommandID == cid) and (RobotCommandState != CommandStateType.WORKING): return RobotCommandState
        elif time.time() > end: return CommandStateType.TIMEOUT
        time.sleep(PERIOD)

def gripper_poll(cid, tm):
    global DEBUG, PERIOD, GripperCommandID, GripperCommandState
    end = time.time() + tm
    while True:
        if (GripperCommandID == cid) and (GripperCommandState != CommandStateType.WORKING): return GripperCommandState
        elif time.time() > end: return CommandStateType.TIMEOUT
        time.sleep(PERIOD)

# --- Handler functions for PDDL commands ---

def Attach_Endeffector(toks, robot_port, gripper_port):
    # (attach-endeffector robot_1 part_gripper part_gripper_holder changing_station_1 part_gripper_holder_slot)
    print toks
    return True

def Create_Kit(toks, robot_port, gripper_port):
    # (create-kit kit_s2m1l1 kit_tray_1 work_table_1)
    print toks
    return True

def Detach_Endeffector(toks, robot_port, gripper_port):
    # (detach-endeffector robot_1 part_gripper part_gripper_holder part_gripper_holder_slot changing_station_1)
    print toks
    return True

def Look_For_Endeffector_In_Endeffectorholder(toks, robot_port, gripper_port):
    # (look-for-endeffector-in-endeffectorholder robot_1 part_gripper part_gripper_holder part_gripper_holder_slot changing_station_1)
    print toks
    return True

def Look_For_Part(toks, robot_port, gripper_port):
    # (look-for-part robot_1 part_vex36_1 stock_keeping_unit_part_vex36 kit_s2m1l1 part_gripper)
    print toks
    return True

def Look_For_Slot_In_Kit(toks, robot_port, gripper_port):
    # (look-for-slot-in-kit robot_1 part_vex36_1 stock_keeping_unit_part_vex36 kit_s2m1l1 kit_s2m1l1_slot_vex36_1 part_gripper)
    print toks
    return True

def Look_For_Slot_In_Lbwk(toks, robot_port, gripper_port):
    # (look-for-slot-in-lbwk robot_1 lbwk_slot_0 finished_kit_receiver kit_s2m1l1 tray_gripper)
    print toks
    return True

def Look_For_Slot_On_Worksurface_Kittray(toks, robot_port, gripper_port):
    # (look-for-slot-on-worksurface-kittray robot_1 worksurface-slot-for-kittray work_table_1 kit_tray_1 tray_gripper)
    print toks
    return True

def Place_Kit(toks, robot_port, gripper_port):
    # (place-kit robot_1 kit_s2m1l1 tray_gripper lbwk_slot_0 finished_kit_receiver)
    print toks
    return True

def Place_Kittray(toks, robot_port, gripper_port):
    # (place-kittray robot_1 kit_tray_1 work_table_1 worksurface-slot-for-kittray tray_gripper)
    print toks
    return True

def Place_Part(toks, robot_port, gripper_port):
    # (place-part robot_1 part_vex36_1 stock_keeping_unit_part_vex36 kit_s2m1l1 kit_s2m1l1_slot_vex36_1 part_gripper)
    global db_cursor, PERIOD, DEBUG
    if len(toks) < 7: return False
    if DEBUG: print toks[0], "using", toks[1], "for part", toks[2], "of SKU", toks[3], "to location", toks[4], "using", toks[5], "if on", toks[6], "and", toks[7]

    # command ids for robot and gripper subordinates
    robot_cid = 100
    gripper_cid = 200

    # //! Configure gripper for pre-grasp
    # pm.demo->Decouple(curtool);
    gripper_cid += 1
    m = OpenToolChangerType(gripper_cid)
    gripper_port.send(str(m))
    if gripper_poll(gripper_cid, 3) != CommandStateType.DONE:
        print "error on", str(m)
        return False

    # pm.demo->Couple(curtool);
    gripper_cid += 1
    m = CloseToolChangerType(gripper_cid)
    gripper_port.send(str(m))
    if gripper_poll(gripper_cid, 3) != CommandStateType.DONE: return False

    # //! Open gripper
    # pm.demo->SetTool (0.9);
    gripper_cid += 1
    m = SetEndEffectorParametersType(gripper_cid, ParameterSettingType("set", 0.9))
    gripper_port.send(str(m))
    if gripper_poll(gripper_cid, 3) != CommandStateType.DONE: return False

    # //! Move over part at z position
    # pm.demo->MoveTo (poseMe)
    robot_cid += 1
    # FIXME -- replace the echo with the call to look up a pose name
    x = 0
    y = 0
    if db_cursor != None:
        try:
            db_cursor.execute("select X,Y,Z from DirectPose where name = " + "\"" + toks[3] + "\"")
            for row in db_cursor.fetchall():
                x = row[0]
                y = row[1]
                print "GOT ONE FOR", toks[3]
        except:
            print "COULDN'T FIND", toks[3]
    m = MoveThroughToType(robot_cid, False, [PoseOnlyLocationType(PointType(x, y, 0), XAXIS, ZAXIS)])
    robot_port.send(str(m))
    if robot_poll(robot_cid, 10) != CommandStateType.DONE: return False

    # //! Grasp part
    # pm.demo->SetTool (0.1);
    gripper_cid += 1
    m = SetEndEffectorParametersType(gripper_cid, ParameterSettingType("set", 0.1))
    gripper_port.send(str(m))
    if gripper_poll(gripper_cid, 3) != CommandStateType.DONE: return False

    # //! Move over the part at z position
    # pm.demo->MoveTo (poseMe)
    robot_cid += 1
    # FIXME -- replace these randoms with the subprocess call, as above
    m = MoveThroughToType(robot_cid, False, [PoseOnlyLocationType(PointType(random.random(),random.random(),random.random()), XAXIS, ZAXIS)])
    robot_port.send(str(m))
    if robot_poll(robot_cid, 10) != CommandStateType.DONE: return False

    # else we did it all OK
    return True

def Set_Grasp(toks, robot_port, gripper_port):
    # (set-grasp robot_1 part_vex36_1 stock_keeping_unit_part_vex36 part_gripper)
    print toks
    return True

def Take_Kit(toks, robot_port, gripper_port):
    # (take-kit robot_1 kit_s2m1l1 kit_tray_1 work_table_1 stock_keeping_unit_kit_tray tray_gripper)
    print toks
    return True

def Take_Kittray(toks, robot_port, gripper_port):
    # (take-kittray robot_1 kit_tray_1 empty_kit_tray_supply tray_gripper stock_keeping_unit_kit_tray)
    print toks
    return True

def Take_Part(toks, robot_port, gripper_port):
    # (take-part robot_1 part_vex36_1 stock_keeping_unit_part_vex36 part_vex36_tray part_gripper kit_s2m1l1)
    if len(toks) < 7: return
    print toks[0], "using", toks[1], "for part", toks[2], "of SKU", toks[3], "from location", toks[4], "using", toks[5], "if", toks[6], "exists"
    # //! Configure gripper for pre-grasp
    # pm.demo->Decouple(curtool);
    # pm.demo->Couple(curtool);
    # //! Open gripper
    # pm.demo->SetTool (0.9);
    # //! Move over part at z position
    # pm.demo->MoveTo (poseMe)
    # //! Grasp part
    # pm.demo->SetTool (0.1);
    # //! Move over the part at z position
    # pm.demo->MoveTo (poseMe)
    return True

# --- the dictionary associating PDDL commands with handler functions ---

funcdict = {
    "attach-endeffector" : Attach_Endeffector,
    "create-kit" : Create_Kit,
    "detach-endeffector" : Detach_Endeffector,
    "look-for-endeffector-in-endeffectorholder" : Look_For_Endeffector_In_Endeffectorholder,
    "look-for-part" : Look_For_Part,
    "look-for-slot-in-kit" : Look_For_Slot_In_Kit,
    "look-for-slot-in-lbwk" : Look_For_Slot_In_Lbwk,
    "look-for-slot-on-worksurface-kittray" : Look_For_Slot_On_Worksurface_Kittray,
    "place-kit" : Place_Kit,
    "place-kittray" : Place_Kittray,
    "place-part" : Place_Part,
    "set-grasp" : Set_Grasp,
    "take-kit" : Take_Kit,
    "take-kittray" : Take_Kittray,
    "take-part" : Take_Part
    }

# parseLine looks up the handler functions and calls them with
# the line and the socket ports to the robot and gripper subordinates

def parseLine(line, robot_socket, gripper_socket):

    toks = str.split(line)
    num = len(toks)
    if num == 0: return False

    func = funcdict.get(toks[0], None)
    if (func != None): return func(toks, robot_socket, gripper_socket)

    print "unknown command", toks[0]
    return False

# --- Main ---

try:
    opts, args = getopt.getopt(sys.argv[1:], "i:f:r:R:g:G:t:d", ["inifile=", "file=", "robot=", "robothost=", "gripper=", "gripperhost=", "period="])
except getopt.GetoptError, err:
    print "plan_exec_app:", str(err)
    sys.exit(1)

for o, a in opts:
    if o in ("-i", "--inifile"):
        INIFILE = a
    elif o in ("-f", "--file"):
        PLANFILE = a
    elif o in ("-r", "--robot"):
        ROBOT_PORT = a
    elif o in ("-R", "--robothost"):
        ROBOT_HOST = a
    elif o in ("-g", "--gripper"):
        GRIPPER_PORT = a
    elif o in ("-G", "--gripperhost"):
        GRIPPER_HOST = a
    elif o in ("-t", "--period"):
        PERIOD = float(a)
    elif o in ("-d"):
        DEBUG = True

defdict = {"directory" : "",
           "file" : "",
           "port" : "",
           "host" : ""}

if INIFILE != "":
    try:
        with open(INIFILE, "rb") as f:
            config = ConfigParser.ConfigParser(defdict)
            config.read(INIFILE)
            if PLANFILE == "":
                PATH_TO_FINAL_PLAN = config.get("final_plan", "directory")
                FINAL_PLAN_FILE = config.get("final_plan", "file")
                PLANFILE = PATH_TO_FINAL_PLAN + FINAL_PLAN_FILE
            if ROBOT_PORT == "":
                ROBOT_PORT = config.get("robot_prim", "port")
            if ROBOT_HOST == "":
                ROBOT_HOST = config.get("robot_prim", "host")
            if GRIPPER_PORT == "":
                GRIPPER_PORT = config.get("gripper_prim", "port")
            if GRIPPER_HOST == "":
                GRIPPER_HOST = config.get("gripper_prim", "host")
    except IOError as err:
        print "robot_prim: open inifile:", str(err)
        sys.exit(1)
    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError) as err:
        print "robot_prim: read inifile:", str(err)
    except:
        print "robot_prim: inifile error"
        sys.exit(1)

if PLANFILE == "":
    print "plan_exec_app: no plan file specified"
    sys.exit(1)

if ROBOT_PORT == "":
    print "plan_exec_app: no robot port provided"
    sys.exit(1)

if ROBOT_HOST == "": ROBOT_HOST = "localhost"

if GRIPPER_PORT == "":
    print "plan_exec_app: no gripper port provided"
    sys.exit(1)

if GRIPPER_HOST == "": GRIPPER_HOST = "localhost"

if DEBUG:
    print "plan_exec_app: plan file:", PLANFILE
    print "plan_exec_app: robot host:", ROBOT_HOST, ", port:", ROBOT_PORT
    print "plan_exec_app: gripper host:", GRIPPER_HOST, ", port:", GRIPPER_PORT

# 
# Connect to MySQL database
# 
try:
    db = MySQLdb.connect(host="aprs-dev", user="wills", passwd="ElsaIsdDb!", db="aprs-dev")
    db_cursor = db.cursor()
except:
    print "plan_exec_app: can't connect to database, simulating"
    db_cursor = None

try:
    robot_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    robot_socket.connect((ROBOT_HOST, int(ROBOT_PORT)))
except IOError as err:
    print "plan_exec_app: can't connect to robot controller", ROBOT_HOST, "on port", ROBOT_PORT, ":", str(err)
    sys.exit(1)

rt = threading.Thread(target=robot_reader, args=(robot_socket,))
rt.daemon = True
rt.start()

try:
    gripper_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    gripper_socket.connect((GRIPPER_HOST, int(GRIPPER_PORT)))
except IOError as err:
    print "plan_exec_app: can't connect to gripper controller", GRIPPER_HOST, "on port", GRIPPER_PORT, ":", str(err)
    sys.exit(1)

gt = threading.Thread(target=gripper_reader, args=(gripper_socket,))
gt.daemon = True
gt.start()

try:
    f = open(PLANFILE, "rb")
except IOError as err:
    print "plan_exec_app: can't open", PLANFILE, ":", str(err)
    sys.exit(1)

for line in f:
    # this means match zero or more chars, then a literal '(',
    # then set up a target with () enclosing a match of anything,
    # then match a literal ')', then anything
    m = re.match(".*\((.*)\).*", line)
    if m != None:
        if DEBUG: print "plan_exec_app: parsing line", m.group(1)
        retval = parseLine(m.group(1), robot_socket, gripper_socket)
        if retval == False:
            print "plan_exec_app: warning: ignoring", m.group(1)

sys.exit(0)
