#!/usr/bin/python

import sys, getopt, re, StringIO, xml.etree.ElementTree as ET

from crcl import *

ver = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
uri = "http://www.w3.org/2001/XMLSchema-instance"
xsi = "{" + uri + "}"
dict = {"xmlns:xsi" : uri}

PLANFILE = "plan.plan"
DEBUG = False

def Attach_Endeffector(toks):
    # print toks
    pass

def Create_Kit(toks):
    # print toks
    pass

def Detach_Endeffector(toks):
    # print toks
    pass

def Look_For_Part(toks):
    # print toks
    pass

def Move_Over_Kit(toks):
    # print toks
    pass

def Move_Over_Kittray(toks):
    # print toks
    pass

def Move_Over_Part(toks):
    # print toks
    pass

def Place_Kit(toks):
    # print toks
    pass

def Place_Kittray(toks):
    # print toks
    pass

def Place_Part(toks):
    # (place-part robot_1 gearbox_base_1 stock_keeping_unit_gearbox_base kit_gearbox part_gripper work_table_1 shaft_tray)
    if len(toks) < 8: return
    print toks[0], "using", toks[1], "for part", toks[2], "of SKU", toks[3], "to location", toks[4], "using", toks[5], "if on", toks[6], "and", toks[7]
    # //! Configure gripper for pre-grasp
    # pm.demo->Decouple(curtool);
    m = SetEndEffectorParametersType({"decouple" : "gear"})
    # pm.demo->Couple(curtool);
    # //! Open gripper
    # pm.demo->SetTool (0.9);
    # //! Move over part at z position
    # pm.demo->MoveTo (poseMe)
    # //! Grasp part
    # pm.demo->SetTool (0.1);
    # //! Move over the part at z position
    # pm.demo->MoveTo (poseMe)


def Take_Kit(toks):
    # print toks
    pass

def Take_Kittray(toks):
    # print toks
    pass

def Take_Part(toks):
    # (take-part robot_1 gearbox_base_1 stock_keeping_unit_gearbox_base gearbox_base_tray part_gripper kit_gearbox)
    if len(toks) < 7: return
    print toks[0], "using", toks[1], "for part", toks[2], "of SKU", toks[3], "from location", toks[4], "using", toks[5], "if", toks[6], "exists"
    # //! Configure gripper for pre-grasp
    # pm.demo->Decouple(curtool);
    # pm.demo->Couple(curtool);
    # //! Open gripper
    # pm.demo->SetTool (0.9);
    # //! Move over part at z position
    # pm.demo->MoveTo (poseMe)
    # //! Grasp part
    # pm.demo->SetTool (0.1);
    # //! Move over the part at z position
    # pm.demo->MoveTo (poseMe)

funcdict = {
    "attach-endeffector" : Attach_Endeffector,
    "create-kit" : Create_Kit,
    "detach-endeffector" : Detach_Endeffector,
    "look-for-part" : Look_For_Part,
    "move-over-kit" : Move_Over_Kit,
    "move-over-kittray" : Move_Over_Kittray,
    "move-over-part" : Move_Over_Part,
    "place-kit" : Place_Kit,
    "place-kittray" : Place_Kittray,
    "place-part" : Place_Part,
    "take-kit" : Take_Kit,
    "take-kittray" : Take_Kittray,
    "take-part" : Take_Part
}

def parseLine(x):

    toks = str.split(x)
    num = len(toks)
    if num == 0: return

    func = funcdict.get(toks[0], None)
    if (func != None):
        func(toks)
    else:
        print "unknown command", toks[0]

# ---

try:
    opts, args = getopt.getopt(sys.argv[1:], "f:d", ["file="])
except getopt.GetoptError, err:
    print "plan_exec_app:", str(err)
    sys.exit(1)

for o, a in opts:
    if o in ("-f", "--file"):
        PLANFILE = a
    elif o in ("-d"):
        DEBUG = True

if DEBUG:
    print "plan_exec_app: plan file:", PLANFILE

try:
    with open(PLANFILE, "rb") as f:
        for line in f:
            # this means match zero or more chars, then a literal '(',
            # then set up a target with () enclosing a match of anything,
            # then match a literal ')', then anything
            m = re.match(".*\((.*)\).*", line)
            if m != None:
                parseLine(m.group(1))

except IOError as err:
    print "plan_exec_app:", str(err)
    sys.exit(1)

m = MoveThroughToType(17)

print m.CommandID, m.NumPositions

m.add(PoseOnlyLocationType())
m.add(PoseOnlyLocationType())
m.add(PoseOnlyLocationType())

print m.CommandID, m.NumPositions

print m

s = CRCLStatusType(CommandStatusType(), JointStatusesType(), PoseOnlyLocationType(), GripperStatusType())

print s.Name, s.CommandStatus.CommandState

print s

sys.exit(0)
