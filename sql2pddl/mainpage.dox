/**
 *\mainpage SQL2PDDL.cpp
 *
 *@brief <b>Main driver that writes a PDDL problem file</b><BR>
 *
 * @details Input and Output:
 *
 * - Needs connection to SQL database and mapping.txt file
 * - Need to set environment variables for SQL connection
 * - writes PDDL problem file to problem-[name of problem].pddl
 *
 * The code queries the SQL database by calling Database/DAO.cpp, which is part of the autogenerated C++ suite.
 *
 * Input mapping.txt file is filled only with entries that look like:
 * 
 * @code
 * (kit-has-kitTray ?kit - Kit ?kittray - KitTray)
 * ∀ Kit : ( ∃ hasKit_KitTray ) print _NAME hasKit_KitTray
 * @endcode
 *
 * The first line is copied from the domain file, listing the predicate or function prototype,
 * and the second line describes where this information lies in the database. There must be a blank
 * line between each pair of content lines - this is hard-coded into the parser currently. It uses set theory syntax -
 * for example, this example would be read "for all rows in the Kit table, such that the attribute hasKit_KitTray
 * exists, print _NAME and hasKit_KitTray". Note that currently the exists filter only supports checking the
 * existence of attributes in the main table (next to the "for each")
 * 
 * Another example that looks like this:
 *
 * @code
 * (endEffector-has-no-heldObject ?endeffector - EndEffector)
 * ∀ EndEffector : ( _NAME ! ∈ SolidObject/hadByHeldObject_EndEffector ) print _NAME
 * @endcode
 *
 * This would be read as "For all rows in EndEffector such that _NAME is not a member of the set queried from 
 * SolidObject/hadByHeldObject_EndEffector, print _NAME". This filter supports is a member of and is not a member of.
 * The most complicated supported input  looks like:
 *
 * @code
 * (kit-has-physicalLocation-refObject-lbwk ?kit - Kit ?largeboxwithkits - LargeBoxWithKits)
 * ∀ PhysicalLocation : ( _NAME > SolidObject/hasSolidObject_PrimaryLocation : SolidObject/_NAME ∈ Kit/_NAME ) && ( hasPhysicalLocation_RefObject ∈ LargeBoxWithKits/_NAME ) print SolidObject/_NAME hasPhysicalLocation_RefObject
 * @endcode
 *
 * As one can see, the parser also supports the operator "&&", where it filters entries using both statements around it.
 * Additionally, note the first statement, which includes the ">" operator. The entire statement can be read as
 * "for all rows in PhysicalLocation, such that (_NAME contains the same string as an entry in SolidObject/hasSolidObject_PrimaryLocation
 * in the same row as a SolidObject/_NAME entry which is a member of Kit/_NAME) AND (that same row in PhysicalLocation has for the 
 * attribute hasPhysicalLocation_RefObject a member of the set LargeBoxWithKits/_NAME), print SolidObject/_NAME and PhysicalLocation/ hasPhysicalLocation_RefObject".
 * If a table and forward slash are left off the path to an attribute, the default table is the main table
 *
 * @author Christopher Lawler
 * @version 1.0
 * @date 3 Jun 2014
 *
 */