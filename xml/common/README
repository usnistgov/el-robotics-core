xml2owl README - last updated 2013Jan16

This directory contains source code and a Makefile for six executable
utilities. No executables or object code files are included. To make
the object code and the executables give the following commands
from this common directory.

  make bin/xml2owlGenerator
  make bin/xmlInstanceParserGenerator
  make bin/xmlSchemaOwlClassGenerator
  make bin/xmlSchemaParser
  make bin/compactOwl
  make bin/compareOwl

xml2owlGenerator
----------------

The xml2owlGenerator reads an XML schema and writes C++ software for a
utility called the owlXXXPrinter that will translate an XML instance
file conforming to the XML schema into an OWL instance file conforming
to the OWL class file generated from the XML schema by the
xmlSchemaOwlClassGenerator.  The user gives the actual value of XXX
when calling the xml2owlGenerator.

The software this writes includes:
1. a C++ driver file named owlXXXPrinter.cc
2. a C++ class header file named owlXXXClasses.hh
3. a C++ code file named owlXXXClasses.cc

The three code files are compiled and linked with
1. owlInstancePrinter.o (C++ domain-independent code for OWL instances)
2. xmlSchemaInstance.o (C++ domain-independent code for XML data types)
3. XXXYACC.o (from XXX.y, which is generated by xmlInstanceParserGenerator)
4. XXXLex.o (from XXX.lex, which is generated by xmlInstanceParserGenerator)

To run the xml2owlGenerator, use a command of the form

  xml2owlGenerator schemaFileName outputBaseName

Example:

  xml2owlGenerator kittingPlan.xsd kittingPlan

With that command, the xml2owlGenerator will generate the files:
owlKittingPlanPrinter.cc
owlKittingPlanClasses.hh
owlKittingPlanClasses.cc

xmlInstanceParserGenerator
--------------------------

The xmlInstanceParserGenerator reads an XML schema file Xxx.xsd in
canonical format and stores the meaning of the contents of the file in
a parse tree in terms of the xmlSchemaClasses. Then it uses the parse
tree for writing the following files (in the same directory as
Xxx.xsd):

1. XxxClasses.hh - a C++ header file defining classes to represent instance
   files corresponding to the schema.
2. XxxClasses.cc - a C++ code file implementing the classes
3. Xxx.y - a YACC file for parsing an instance file corresponding to the
   schema and storing the instances in terms of the C++ classes.
4. Xxx.lex - a Lex file containing the lexical scanner used by Xxx.y
5. XxxParser.cc - a C++ file containing a main function that reads, stores,
   and reprints an XML instance file corresponding to the schema.

If the XML schema includes other XML schemas files with the same
namespace, this also generates C++ header and code files for those
schema files, but not YACC, Lex, or parser files. The parser built for
Xxx.xsd will be able to parse everything defined in the other schema
files.

If the XML schema does not start with an element, this prints only the
C++ header and code files.

Because the xmlInstanceParserGenerator generates Lex and YACC files, the
software is about three times as long as that for the other generators.

To run the xmlInstanceParserGenerator, use a command of the form:

  xmlInstanceParserGenerator [-h header] [-p prefix] -x schema

[...] denotes optional command arguments

header is a header file generated previously (from an earlier version of
the same schema) in which changes have been made manually. If the changes
are made at the ends of class declarations and are preceded by comments,
they will be transcribed into the newly generated header file.

prefix is the prefix to use in YACC and Lex files (default is yy).

Example 1: xmlInstanceParserGenerator -x plan.xsd
Example 2: xmlInstanceParserGenerator -p yypl -x plan.xsd
Example 3: xmlInstanceParserGenerator -x plan.xsd -h planClasses.hh

All three examples would produce the following five files:
planClasses.hh
planClasses.cc
plan.y
play.lex
planParser.cc


xmlSchemaOwlClassGenerator
--------------------------

The xmlSchemaOwlClassGenerator reads an XML schema and writes an
equivalent OWL file defining classes in OWL functional syntax. The
usage of the XML schema language in the input file is highly
constrained.

To run the xmlSchemaOwlClassGenerator, use a command of the form

  xmlSchemaOwlClassGenerator <schema file name> <URL>

Example:

xmlSchemaOwlClassGenerator kittingPlan.xsd http://www.nist.gov/el/ontologies/kittingPlanClasses.owl

The URL appears in the output file both as the name of the Ontology
and in a Prefix statement.

The name of the output file is the same as the name of the input file
except that the .xsd suffix is replaced by .owl

xmlSchemaParser
---------------

The xmlSchemaParser reads an XML schema and reprints it if it is
syntactically valid. The name of the output file is the same as the
name of the input file with "echo" added. The xmlSchemaParser has an
option for whether it saves and reprints comments. There are also
four choices for printing documentation nodes:
 - none (documentation nodes are removed along with the enclosing
         annotation nodes)
 - asIs (formatted exactly as in the input file)
 - left (all unnecessary white space is removed, and white space needed to
         separate words is reduced to a single space)
 - indent (re-typeset the text of documentation nodes so that the
           lines are not too long and are indented appropriately)

To run the xmlSchemaParser, use a command of the form:

  xmlSchemaParser [-d docPrint] [-c] schema

[...] denotes optional command arguments

-c means to print comments; the default is not to print comments.
docPrint, if used, must be asIs, indent, left, or none; default is asIs.

Example:

  xmlSchemaParser -d asIs -c kittingPlan.xsd

compactOwl and compareOwl
-------------------------

There is no need to read this section unless you are interested in
comparing two OWL files that are intended to have the same statements
but possibly:
 - in a different order
 - formatted with white space differently
 - with different comments.

These utilities assume that the format of the input follows some
conventions. If the format used by an input file does not follow those
conventions, the comparison may fail.

The compactOwl utility compacts an OWL instance file by:
1. removing all occurrences of one or two blank lines. The blank lines
   must not contain spaces or tabs.
2. removing comments. The comments must have // as the first two
   characters on the line.
3. combining each OWL statement written on two or more lines so it is
   all on one line. The first non-space character on the second line
   must be a colon (:) or a double quote (").
4. rewriting numbers with decimal points so there are exactly six decimal
   places. Such numbers must have at least one digit on each side of the
   decimal point in the input file.
5. putting the DifferentIndividuals inside DifferentIndividuals statements
   into alphabetical order.

To run compactOwl use a command of the form:

    bin/compactOwl < owlFileIn > owlFileOut

where owlFileIn and owlFileOut are file names.

Example:

  compactOwl < kittingPlanClasses.owl > junk.owl

The compareOwl utility compares two files that are expected to have
the same lines, but in a different order, such as an automatically
generated OWL file and a hand-written OWL file. If it finds two lines
that do not match, it prints the line from the first file followed by
the line from the second file. If all lines match, that is reported.

To run compareOwl, use a command of the form:

bin/compareOwl firstOwlFile secondOwlFile

where firstOwlFile and secondOwlFile are the names of compacted OWL
files.

