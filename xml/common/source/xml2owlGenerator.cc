/*

********************************************************************

This generator reads an XML schema and writes C++ software for a
utility called the owlXXXPrinter that will translate an XML instance
file conforming to the XML schema into an OWL instance file conforming
to the OWL class file generated from the XML schema by the
xmlSchemaOwlClassGenerator.  The user gives the actual value of XXX
when calling this generator.

The software this writes includes:
1. a C++ driver file named owlXXXPrinter.cc
2. a C++ class header file named owlXXXClasses.hh
3. a C++ code file named owlXXXClasses.cc

The three code files are compiled and linked with
1. owlInstancePrinter.o (C++ domain-independent code for OWL instances)
2. xmlSchemaInstance.o (C++ domain-independent code for XML data types)
3. XXXYACC.o (from XXX.y, generated by the xmlInstanceParserGenerator)
4. XXXLex.o (from XXX.lex, generated by the xmlInstanceParserGenerator)

The Makefile for making an executable from the seven object files is
currently hand written. The Makefile must use -DOWL when it compiles
the XXXYACC.cc and XXXLex.o files. 

The usage of the XML schema language in the input file is constrained.

When the top level element in the schema is YYY, a YYYFile class and
a YYYFileHeader class for which there is no equivalent in the schema are
generated. The YACC file relies on these.

XML Schema Usage Rules
----------------------

1. The names of all types in the XML schema must end with "Type".

2. All complex types must have a name.

3. The XML schema must not have any XML Attributes (i.e., only elements
are used).

4. The XML schema must be in venetian blind format so that all type
definitions are at the top level.

5. All complexTypes must have a Name element of type xs:ID.

Limitations
-----------

This does not handle the following XML schema constructs:
  attribute
  choice
  complex restriction
  fixed
  keyref
  maxLength
  maxOccurs of sequence
  minLength
  minOccurs of sequence
  pattern
  ref
  simpleList
  substitutionGroup
  unique


*/

#include <stdio.h>   // fprintf
#include <string.h>  // strlen
#include <stdlib.h>  // exit
#include "xmlSchemaClasses.hh"
#include "xml2owlGenerator.hh"
#define XMLSCHEMAINSTANCEBASE "XmlSchemaInstanceBase"

/********************************************************************/

extern XmlSchemaFile * xmlSchemaFile;
extern char * globalOwlPrefix;
extern FILE * yyin;
extern int yyparse();

/********************************************************************/

/*

Declare and set static variables of the XmlSchemaFile class.
Those variables are not used in this system.

*/

int XmlSchemaFile::printDoc = 0;
bool XmlSchemaFile::printComments = false;

/********************************************************************/

/* xml2owlGenerator::allCaps

Returned Value: none

Called By:  xml2owlGenerator::printHeader

This copies lowerName into upperName, changing any lower case letters
to upper case letters.

*/

void xml2owlGenerator::allCaps( /* ARGUMENTS                         */
 char * lowerName,              /* name to convert to all upper case */
 char * upperName)              /* name converted to all upper case  */
{
  int length;
  int n;

  length = strlen(lowerName);
  for (n = 0; n < length; n++)
    upperName[n] = toupper(lowerName[n]);
  upperName[n] = 0;
}

/********************************************************************/

/* xml2owlGenerator::buildClasses

Returned Value: none

Called By: xml2owlGenerator::readSchema

This goes through the contents2 list of the most recently read schema.
For each item on the list:
1. If the item is a complex type or simple type, it is placed on the
   classes list.
2. If the item is the first item and is an XmlElementRefable, it is
   handled as described below.
3. If the item is not the first item and is an XmlElementRefable, or if
   the item is an XmlAttributeLoner, or if the item is an XmlAttributeGroup,
   this prints an error message and exits.

The classes are the top-level complexTypes and the top-level simpleTypes.

The top level element (which must be XmlElementRefable) must have a
non-zero typ and must have a zero typeDef. This checks for that. If the
check fails, this prints an error message and exits.

*/

void xml2owlGenerator::buildClasses( /* ARGUMENTS                          */
 bool isTop)                         /* true=first schema, false=not first */
{
  std::list<XmlSchemaContent2 *>::iterator iter;
  XmlComplexType * complx;
  XmlSimpleType * simple;
  
  iter = contents2->begin();
  if (isTop && iter != contents2->end())
    {
      if ((topElement = dynamic_cast<XmlElementRefable *>(*iter)))
	{
	  if (topElement->typeDef || (topElement->typ == 0))
	    {
	      fprintf(stderr, "top element must have a typ and no typeDef\n");
	      exit(1);
	    }
	  else // top element is OK; skip it
	    iter++;
	}
      else
	{
	  fprintf(stderr,
		  "first item in top schema contents must be root element\n");
	  exit(1);
	}
    }
  for ( ; iter != contents2->end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	{
	  enterClass(complx);
	}
      else if ((simple = dynamic_cast<XmlSimpleType *>(*iter)))
	{
	  enterClass(simple);
	}
      else if (((dynamic_cast<XmlElementRefable *>(*iter)))        ||
	       ((dynamic_cast<XmlAttributeLonerRefable *>(*iter))) ||
	       ((dynamic_cast<XmlAttributeGroupRefable *>(*iter))))
	{
	  fprintf(stderr, "cannot handle refables in buildClasses\n");
	  exit(1);
	}
      else
	{
	  fprintf(stderr, "unknown XmlSchemaContent2 type in buildClasses\n");
	  exit(1);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::checkBaseArgs

Returned Value: none

Called By:
  xml2owlGenerator::checkBaseArgs (recursive)
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printHeaderComplexExtend

This looks through the base class to see if it has a non-empty
sequence. If a non-empty sequence is found, hasSequence is set to 1.
If the base class is derived, this calls itself recursively to look
through the base class of the base class.

*/ 

void xml2owlGenerator::checkBaseArgs( /* ARGUMENTS                */
 char * baseName,                     /* name of base class       */
 int * hasSequence)                   /* 1=has a sequence, 0=not  */  
{
  XmlComplexType * complx;
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * extend;
  XmlSequence * sequence;

  complx = findComplexClass(baseName);
  if (complx == 0)
    {
      fprintf(stderr, "base class %s not found in checkBaseArgs\n",
	      baseName);
      exit(1);
    }
  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)) &&
	  sequence->items && sequence->items->size())
	*hasSequence = 1;
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
    {
      if ((extend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	{
	  if ((sequence = dynamic_cast<XmlSequence *>(extend->item))
	       && sequence->items && sequence->items->size())
	    *hasSequence = 1;
	  if (*hasSequence == 0)
	    checkBaseArgs(extend->base, hasSequence);
	}
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex restriction\n");
	  exit(1);
	}
    }
  else if (dynamic_cast<XmlSimpleContent *>(complx->item))
    {
      fprintf(stderr, "complex extension may not have simple content base\n");
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::checkClasses

Returned Value: none

Called By:  main

This checks the classes list for complex types that cannot be handled
and for items in complex types that cannot be handled. It prints an
error message and exits if anything is found that cannot be handled.

This is allowing a choice, but choice is disallowed later.

*/

void xml2owlGenerator::checkClasses()/* NO ARGUMENTS */
{
  XmlComplexType * complx;
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * extend;
  XmlSequence * sequence;
  XmlChoice * choice;
  XmlElementLocal * elementLocal;
  std::list<XmlType *>::iterator iter;
  std::list<XmlChoSeqItem *> * items;
  std::list<XmlChoSeqItem *>::iterator ator;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	{
	  items = 0;
	  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
	    {
	      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
		items = sequence->items;
	      else if ((choice = dynamic_cast<XmlChoice *>(other->base)))
		items = choice->items;
	    }
	  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
	    {
	      if ((extend = dynamic_cast<XmlComplexExtension *>(comp->item)))
		{
		  if ((sequence = dynamic_cast<XmlSequence *>(extend->item)))
		    items = sequence->items;
		}
	      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
		{
		  fprintf(stderr, "cannot handle complex restriction\n");
		  exit(1);
		}
	      else
		{
		  fprintf(stderr, "unknown type of XML complex content item\n");
		  exit(1);
		}
	    }
	  if (!items)
	    continue;
	  for (ator = items->begin(); ator != items->end(); ator++)
	    {
	      if ((elementLocal = dynamic_cast<XmlElementLocal *>(*ator)))
		{
		  if (elementLocal->ref)
		    {
		      fprintf(stderr, "cannot handle referenced element\n");
		      exit(1);
		    }
		  else if (elementLocal->newTyp == 0)
		    {
		      fprintf(stderr, "element %s has no type\n",
			      elementLocal->name);
		      exit(1);
		    }
		}
	    }
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::checkNumberRestrictions

Returned Value: none

Called By:
  xml2owlGenerator::printHeaderRestrictNumber

This goes through the restrictions on an XML list of numbers and
checks that there are not two XmlMaxExclusive restrictions, two
XmlMinExclusive restrictions, two XmlMaxInclusive restrictions, or two
XmlMinInclusive restrictions. It also checks that there are no other
types of restrictions.

If an error is found, this prints an error message and exits.

*/

void xml2owlGenerator::checkNumberRestrictions(  /* ARGUMENTS    */
 std::list<XmlRestrictionType *> * restrictions) /* restrictions */
{
  XmlMaxExclusive * maxEx = 0;
  XmlMaxInclusive * maxIn = 0;
  XmlMinExclusive * minEx = 0;
  XmlMinInclusive * minIn = 0;
  std::list<XmlRestrictionType *>::iterator iter;
  
  for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
    {
      if ((maxEx == 0) &&
	  (maxEx = dynamic_cast<XmlMaxExclusive *>(*iter)));
      else if ((maxEx = dynamic_cast<XmlMaxExclusive *>(*iter)))
	{
	  fprintf(stderr,
		  "number must not have two maxExclusive restrictions\n");
	  exit(1);
	}
      else if ((maxIn == 0) &&
	       (maxIn = dynamic_cast<XmlMaxInclusive *>(*iter)));
      else if ((maxIn = dynamic_cast<XmlMaxInclusive *>(*iter)))
	{
	  fprintf(stderr,
		  "number must not have two maxInclusive restrictions\n");
	  exit(1);
	}
      else if ((minEx == 0) &&
	  (minEx = dynamic_cast<XmlMinExclusive *>(*iter)));
      else if ((minEx = dynamic_cast<XmlMinExclusive *>(*iter)))
	{
	  fprintf(stderr,
		  "number must not have two minExclusive restrictions\n");
	  exit(1);
	}
      else if ((minIn == 0) &&
	       (minIn = dynamic_cast<XmlMinInclusive *>(*iter)));
      else if ((minIn = dynamic_cast<XmlMinInclusive *>(*iter)))
	{
	  fprintf(stderr,
		  "number must not have two minInclusive restrictions\n");
	  exit(1);
	}
      else
	{
	  fprintf(stderr, "bad number restriction type\n");
	  exit(1);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::deNameName

Returned Value: none

Called By:
 xml2owlGenerator::printCodePrintElementMulti
 xml2owlGenerator::printCodePrintElementSingle

This checks that the name ends in "Name". If so, it copies the name into
the buffer with "Name" removed. If not, it prints an error message and
exits.

*/

void xml2owlGenerator::deNameName( /* ARGUMENTS                           */
 char * name,                      /* name that ends in "Name"            */
 char * buffer)                    /* buffer for name copy without "Name" */
{
  int nameSize;

  nameSize = strlen(name);
  if ((nameSize > 4) && (nameSize < NAMESIZE) && 
      (strcmp((name + nameSize - 4), "Name") == 0))
    {
      strncpy(buffer, name, NAMESIZE);
      buffer[nameSize - 4] = 0;
    }
  else
    {
      fprintf(stderr, "name %s must end in \"Name\" but does not\n", name);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::deTypeName

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodePrintIndividuals
  xml2owlGenerator::printCodePrintParentItems
  xml2owlGenerator::printCodeSequence

This checks that the name ends in "Type". If so, it copies the name into
the buffer with "Type" removed. If not, it prints an error message and
exits.

*/

void xml2owlGenerator::deTypeName( /* ARGUMENTS                           */
 char * name,                      /* name that ends in "Type"            */
 char * buffer)                    /* buffer for name copy without "Type" */
{
  int nameSize;

  nameSize = strlen(name);
  if ((nameSize > 4) && (nameSize < NAMESIZE) && 
      (strcmp((name + nameSize - 4), "Type") == 0))
    {
      strncpy(buffer, name, NAMESIZE);
      buffer[nameSize - 4] = 0;
    }
  else
    {
      fprintf(stderr, "name %s must end in \"Type\" but does not\n", name);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::enterClass

Returned Value: none

Called By:  xml2owlGenerator::buildClasses

This inserts aClass in the classes list in alphabetical order (by newName).
If a duplicate class name is found, this prints an error message and exits.

*/

void xml2owlGenerator::enterClass( /* ARGUMENTS                 */
 XmlType * aClass)                 /* class to put into classes */
{
  std::list<XmlType *>::iterator iter;
  XmlSimpleType * simple;
  XmlComplexType * complx;
  char * newName;
  int result;

  if ((complx = dynamic_cast<XmlComplexType *>(aClass)))
    newName = complx->newName;
  else if ((simple = dynamic_cast<XmlSimpleType *>(aClass)))
    newName = simple->newName;
  else
    {
      fprintf(stderr, "bug: class not XmlSimpleType or XmlComplexType\n");
      exit(1);
    }
  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	{
	  result = strcmp(newName, complx->newName);
	  if (result < 0)
	    {
	      classes.insert(iter, aClass);
	      break;
	    }
	  else if (result == 0)
	    {
	      fprintf(stderr, "duplicate class name %s. Exiting\n", newName);
	      exit(1);
	    }
	}
      else if ((simple = dynamic_cast<XmlSimpleType *>(*iter)))
	{
	  result = strcmp(newName, simple->newName);
	  if (result < 0)
	    {
	      classes.insert(iter, aClass);
	      break;
	    }
	  else if (result == 0)
	    {
	      fprintf(stderr, "duplicate class name %s. Exiting\n", newName);
	      exit(1);
	    }
	}
    }
  if (iter == classes.end())
    classes.push_back(aClass);
}

/********************************************************************/

/* xml2owlGenerator::enterKid

Returned Value: none

Called By:  xml2owlGenerator::enterKids

This enters the kid type in the extensions of the parent type if it is
not already there. The extensions list of an XmlComplexType is not
kept in any particular order. If the kid is already entered in the
extensions of the parent type, an error message is printed, and this
exits.

*/

void xml2owlGenerator::enterKid( /* ARGUMENTS                          */
 XmlComplexType * parent,        /* parent type for which to enter kid */
 XmlComplexType * kid)           /* kid type                           */
{
  std::list<XmlComplexType *> * extensions;
  std::list<XmlComplexType *>::iterator iter;
  
  extensions = parent->extensions;
  if (extensions)
    {
      for (iter = extensions->begin(); iter != extensions->end(); iter++)
	{
	  if (*iter == kid)
	    {
	      fprintf(stderr, "duplicate extension for %s\n", kid->name);
	      exit(1);
	    }
	}
      extensions->push_back(kid); // kid not already on list, so add kid
    }
  else
    {
      parent->extensions = new std::list<XmlComplexType *>;
      parent->extensions->push_back(kid);
    }
}

/********************************************************************/

/* xml2owlGenerator::enterKids

Returned Value: none

Called By:  main

This builds the extensions list of each class. If a named parent is not
found, this prints an error message and exits.

*/

void xml2owlGenerator::enterKids() /* NO ARGUMENTS */
{
  XmlComplexType * parent;
  XmlComplexType * kid;
  XmlComplexContent * comp;
  XmlComplexExtension * extend;
  std::list<XmlType *>::iterator iter;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if (((kid = dynamic_cast<XmlComplexType *>(*iter))) &&
	  ((comp = dynamic_cast<XmlComplexContent *>(kid->item))) &&
	  ((extend = dynamic_cast<XmlComplexExtension *>(comp->item))))
	{
	  parent = findComplexClass(extend->base);
	  if (parent == 0)
	    {
	      fprintf(stderr, "base type %s not found\n", extend->base);
	      exit(1);
	    }
	  enterKid(parent, kid);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::findComplexClass

Returned Value: XmlComplexType *
  This looks through the classes and returns the complex class with the
  given name, or null if it is not found.

Called By:
  xml2owlGenerator::checkBaseArgs
  xml2owlGenerator::enterKids
  xml2owlGenerator::printCodeBaseArgs
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodePrintElement
  xml2owlGenerator::printCodePrintParentItems
  xml2owlGenerator::printHeaderBaseArgs
  xml2owlGenerator::printHeaderSchemaClassComplex

*/

XmlComplexType * xml2owlGenerator::findComplexClass( /* ARGUMENTS             */
 char * name)                                        /* name of class to find */
{
  std::list<XmlType *>::iterator iter;
  XmlComplexType * complx;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)) &&
	  (strcmp(name, complx->newName) == 0))
	break;
    }
  return ((iter == classes.end()) ? 0 : complx);
}

/********************************************************************/

/* xml2owlGenerator::findCppTypeName

Returned Value: none

Called By:
  xml2owlGenerator::printCodePrintElementMulti
  xml2owlGenerator::printCodePrintElementSingle
  xml2owlGenerator::printCodeSimple
  xml2owlGenerator::printHeaderSequenceArgs
  xml2owlGenerator::printHeaderSequenceItems
  xml2owlGenerator::printHeaderSimple

This finds the C++ type name corresponding to the wg3 type name and
copies it into the cppTypeName. All such names are formed by writing
the prefix "Xml" followed by the wg3TypeName with the first letter in
upper case.

The names copied into cppTypeName are all the names of C++
classes. Where the cppTypeName is used in the caller, a "*" will be
added to change the type to a pointer. Using pointers makes it easy to
handle optional items (as null pointers).

*/

void xml2owlGenerator::findCppTypeName( /* ARGUMENTS                     */
 char * wg3TypeName,                    /* name of XML type              */
 char * cppTypeName)                    /* array to put C++ type name in */
{
  snprintf(cppTypeName, NAMESIZE, "Xml%c%s", toupper(wg3TypeName[0]),
	   wg3TypeName+1);
}

/********************************************************************/

/* xml2owlGenerator::findRootXmlType

Returned Value: none

Called By:
  xml2owlGenerator::findRootXmlType (recursively)
  xml2owlGenerator::printCodeSimple
  xml2owlGenerator::printHeaderSimple

If "simple" is a restriction, this finds the XML root type of simple.
It puts the name of the XML root type into the rootXmlTypeName array.
It calls itself recursively if necessary to handle a restriction of a
restriction. If simple is a list or an unknown type, this prints an
error message and exits.

*/

void xml2owlGenerator::findRootXmlType( /* ARGUMENTS                         */
 XmlSimpleType * simple,                /* simple type to find root type for */
 char * rootXmlTypeName)                /* array in which to put the answer  */
{
  XmlSimpleRestriction * restrict;

  if (simple == 0)
    {
      fprintf(stderr, "null simple type in findRootXmlType\n");
      exit(1);
    }
  if (dynamic_cast<XmlSimpleList *>(simple->item))
    {
      fprintf(stderr, "cannot handle %s list in findRootXmlType\n",
	      simple->name);
      exit(1);
    }
  else if ((restrict = dynamic_cast<XmlSimpleRestriction *>(simple->item)))
    {
      if (restrict->basePrefix &&
	  (strcmp(restrict->basePrefix, XmlCppBase::wg3Prefix) == 0))
	{
	  strcpy(rootXmlTypeName, restrict->base);
	}
       else
	findRootXmlType(findSimpleClass(restrict->newBase), rootXmlTypeName);
    }
  else
    {
      fprintf(stderr, "cannot find basic type for %s\n", simple->name);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::findSimpleClass

Returned Value: XmlSimpleType *
  This returns the simple class with the given name.

Called By:
  xml2owlGenerator::findRootXmlType
  xml2owlGenerator::printCodePrintElement
  xml2owlGenerator::printCodeSimple
  xml2owlGenerator::printHeaderSchemaClassSimple
  xml2owlGenerator::printHeaderSimple

*/

XmlSimpleType * xml2owlGenerator::findSimpleClass( /* ARGUMENTS             */
 char * name)                                      /* name of class to find */
{
  std::list<XmlType *>::iterator iter;
  XmlSimpleType * simple;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((simple = dynamic_cast<XmlSimpleType *>(*iter)) &&
	  (strcmp(name, simple->newName) == 0))
	break;
    }
  return ((iter == classes.end()) ? 0 : simple);
}

/********************************************************************/

/* xml2owlGenerator::isNumber

Returned Value: bool
  This returns true if the typeName is one of those listed in the function.
  Otherwise, this returns false.

Called By:
  xml2owlGenerator::printHeaderSimple
  xml2owlGenerator::printCodeSimple

*/

bool xml2owlGenerator::isNumber( /* ARGUMENTS             */
 char * typeName)                /* name of type to check */
{
  return ((strcmp(typeName, "XmlDecimal")            == 0) ||
	  (strcmp(typeName, "XmlDouble")             == 0) ||
	  (strcmp(typeName, "XmlFloat")              == 0) ||
	  (strcmp(typeName, "XmlInt")                == 0) ||
	  (strcmp(typeName, "XmlInteger")            == 0) ||
	  (strcmp(typeName, "XmlLong")               == 0) ||
	  (strcmp(typeName, "XmlNonNegativeInteger") == 0) ||
	  (strcmp(typeName, "XmlPositiveInteger")    == 0) ||
	  (strcmp(typeName, "XmlShort")              == 0) ||
	  (strcmp(typeName, "XmlUnsignedInt")        == 0) ||
	  (strcmp(typeName, "XmlUnsignedLong")       == 0) ||
	  (strcmp(typeName, "XmlUnsignedShort")      == 0));
}

/********************************************************************/

/* xml2owlGenerator::isStringy

Returned Value: bool
  This returns true if the typeName is one of those listed in the function.
  Otherwise, this returns false.

Called By:
  xml2owlGenerator::printCodeSimple
  xml2owlGenerator::printHeaderSimple

*/

bool xml2owlGenerator::isStringy( /* ARGUMENTS             */
 char * typeName)                 /* name of type to check */
{
  return ((strcmp(typeName, "XmlString") == 0)  ||
	  (strcmp(typeName, "XmlNMTOKEN") == 0) ||
          (strcmp(typeName, "XmlToken") == 0)   ||
	  (strcmp(typeName, "XmlID") == 0)      ||
	  (strcmp(typeName, "XmlIDREF") == 0));
}

/********************************************************************/

/* xml2owlGenerator::printCode

Returned Value: none

Called By: main

This prints the C++ code file.

The code file is generated from a set of classes that represent an
XML schema in canonical form.  The code file is printed in the same
directory as the schema file.

If the base name is Xxx , the code file name is "owlXxxClasses.cc".

If the code file cannot be opened, this prints an error message and exits.

*/

void xml2owlGenerator::printCode( /* ARGUMENTS        */
 char * baseName)                 /* base name to use */
{
  sprintf(nameBuffer, "owl%sClasses.cc", baseName);
  ccFile = fopen(nameBuffer, "w");
  if (ccFile == 0)
    {
      fprintf(stderr, "could not open file %s for writing\n", nameBuffer);
      exit(1);
    }
  hhFile = ccFile; // need this since header printers called by code printers
  printCodeStart(baseName);
  printCodeSchemaClasses();
  printCodeEnd();
  fclose(ccFile);
  ccFile = 0;
  hhFile = 0;
}

/********************************************************************/

/* xml2owlGenerator::printCodeBaseArgs

Returned Value: none

Called By:
  xml2owlGenerator::printCodeBaseArgs (recursively)
  xml2owlGenerator::printCodeComplexExtend

This prints in the C++ code file the arguments to the constructor of
an extension that exist because the base type has them.

This calls itself recursively to handle extension depths greater than one.

If the base class with the given baseName cannot be found, or if a
complex restriction is encountered, this prints an error message and exits.

*/

void xml2owlGenerator::printCodeBaseArgs( /* ARGUMENTS                      */
 char * baseName,                         /* name of base class             */
 int * comma)                             /* non-zero = start with a comma  */
{
  XmlComplexType * complx;
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * extend;
  XmlSequence * sequence;

  complx = findComplexClass(baseName);
  if (complx == 0)
    {
      fprintf(stderr, "base class %s not found in printCodeBaseArgs\n",
	      baseName);
      exit(1);
    }
  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
	{
	  printCodeSequenceArgs(sequence->items, comma);
	}
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
    {
      if ((extend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	{
	  printCodeBaseArgs(extend->base, comma);
	  if ((sequence = dynamic_cast<XmlSequence *>(extend->item)))
	    {
	      printCodeSequenceArgs(sequence->items, comma);
	    }
	}
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex restriction\n");
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeComplex

Returned Value: none

Called By:  xml2owlGenerator::printCodeSchemaClasses

This prints in the C++ code file the code for a class derived from
an XmlComplexType.

When a complex type has no content (which may happen if, for example,
the type is an abstract parent type), complex->item is set in
xmlSchema.y to an XmlOtherContent that has no base. Here that is
handled by printCodeOtherMinimal.

If a choice, a complex restriction, or an unknown type of complex
content is encountered, this prints an error message and exits.

*/

void xml2owlGenerator::printCodeComplex( /* ARGUMENTS                        */
 XmlComplexType * complx)                /* XmlComplexType to print code for */
{
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * compExtend;
  XmlSequence * sequence;

  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
	printCodeSequence(sequence, complx);
      else if (dynamic_cast<XmlChoice *>(other->base))
	{
	  fprintf(stderr, "cannot handle choice\n");
	  exit(1);
	}
      else
        printCodeOtherMinimal(complx->newName);
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
    {
      if ((compExtend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	printCodeComplexExtend(compExtend, complx, complx->newName);
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex restriction\n");
	  exit(1);
	}
      else
	{
	  fprintf(stderr, "bad complex content type in printCodeComplex\n");
	  exit(1);
	}
    }
  else
    {
      fprintf(stderr, "cannot handle content of complex type %s\n",
	      complx->name);
      exit(1); 
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeComplexExtend

Returned Value: none

Called By: xml2owlGenerator::printCodeComplex

This prints in the C++ code file the implementation of a class derived from
an XmlComplexExtension.

It prints the definitions of 1 or 2 constructors.
1. A constructor taking no arguments.
2. If the extension has a sequence or any part of its base has a sequence,
   a constructor taking arguments corresponding to the sequence items.
If the complex type is not abstract, this also prints a PrintOwl function.

This also prints the definition of a printOwl function.

The sequence variable is the elements added to the type by the extension.

The arguments to the constructor taking all C++ attributes must include
the names of all the C++ attributes of the base type from which the
extension is derived. This is accomplished by calling printHeaderBaseArgs.

Note that the code this prints uses the Name of each instance of every
type. All XML types must have a Name element in order that this works.

If the base class for extend cannot be found, this prints an error message
and exits.

*/

void xml2owlGenerator::printCodeComplexExtend( /* ARGUMENTS                 */
 XmlComplexExtension * extend,    /* XmlComplexExtension to print class for */
 XmlComplexType * complx,         /* complex (the type being extended)      */
 char * newName)                  /* newName of complx                      */
{
  char noTypeName[NAMESIZE];
  XmlSequence * sequence;
  std::list<XmlChoSeqItem *> * items = 0;
  XmlComplexType * baseType;
  int comma = 0;
  int hasSequence;

  baseType = findComplexClass(extend->base);
  if (baseType == 0)
    {
      fprintf(stderr, "base type %s not found\n", extend->base);
      exit(1);
    }
  sequence = dynamic_cast<XmlSequence *>(extend->item);
  hasSequence = ((sequence && sequence->items->size()) ? 1 : 0);
  if (hasSequence == 0) 
    checkBaseArgs(extend->base, &hasSequence);
  fprintf(ccFile, "%s::%s() {}\n", newName, newName);
  fprintf(ccFile, "\n");
  if (hasSequence)
    { // print constructor with arguments for sequence items

      fprintf(ccFile, "%s::%s(", newName, newName);
      printHeaderBaseArgs(extend->base, &comma, "");
      if (sequence)
	{
	  items = sequence->items;
	  printHeaderSequenceArgs(items, &comma, "");
	}
      fprintf(ccFile, ") :\n");
      fprintf(ccFile, "  %s(", extend->base);
      comma = 0;
      printCodeBaseArgs(extend->base, &comma);
      fprintf(ccFile, ")\n");
      fprintf(ccFile, "{\n");
      if (items)
	printCodeSequenceSettings(items);
      fprintf(ccFile, "}\n");
      fprintf(ccFile, "\n");
    }
  fprintf(ccFile, "%s::~%s() {}\n", newName, newName);
  if (!complx->abstract)
    {
      fprintf(ccFile, "\n");
      fprintf(ccFile, "void %s::printOwl(FILE * outFile)\n", newName);
      fprintf(ccFile, "{\n");
      if (hasSequence)
	{
	  deTypeName(newName, noTypeName);
	  fprintf(ccFile, "  printer.startIndi(Name, \"%s:%s\", outFile);\n",
		  complx->owlPrefix, noTypeName);
	  printCodePrintParentItems(baseType);
	  if (items)
	    printCodePrintItems(items, noTypeName, complx->owlPrefix);
	  fprintf(ccFile, "  printer.endIndi(\"%s:%s\", outFile);\n",
		  complx->owlPrefix, noTypeName);
	}
      fprintf(ccFile, "  individuals.insert(Name->val);\n");
      fprintf(ccFile, "}\n");
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeEnd

Returned Value: none

Called By: xml2owlGenerator::printCode

This prints the XmlHeaderForXXX class. 

*/

void xml2owlGenerator::printCodeEnd() /* NO ARGUMENTS */
{
  char * topName;

  topName = topElement->newName;
  fprintf(ccFile, "/* class XmlHeaderFor%s\n", topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "*/\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "XmlHeaderFor%s::XmlHeaderFor%s() {}\n", topName, topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "XmlHeaderFor%s::XmlHeaderFor%s(\n", topName, topName);
  fprintf(ccFile, "  SchemaLocation * locationIn)\n");
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  location = locationIn;\n");
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "XmlHeaderFor%s::~XmlHeaderFor%s() {}\n", topName, topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "void XmlHeaderFor%s::printOwl(\n", topName);
  fprintf(ccFile, "  FILE * outFile)\n");
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "}\n");
  printStarLine(ccFile, true, true);
}

/********************************************************************/

/* xml2owlGenerator::printCodeOtherMinimal

Returned Value: none

Called By: xml2owlGenerator::printCodeComplex

This prints constructor and destructor definitions for an empty complex
type. The constructor and destructor do nothing.

printHeaderOtherMinimal prints the definitions of printSelf and printOwl
functions that do nothing, so they do not appear here.

*/

void xml2owlGenerator::printCodeOtherMinimal(/* ARGUMENTS                    */
 char * newName)                             /* newName of an XmlComplexType */
{
  fprintf(ccFile, "%s::%s() {}\n", newName, newName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::~%s() {}\n", newName, newName);
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintElement

Returned Value: none

Called By: xml2owlGenerator::printCodePrintItems

This prints in the code file the part of a printSelf function that
prints an XML element.

For maxOccurs, a value of -1 means unbounded. A value less than -1 
means no maxOccurs was given.

If minOccurs is 0 and maxOccurs is 1 either by default or explicit
assignment, printing the value occurs only if the element occurs.
If minOccurs is 0 and maxOccurs allows for a list, no special action
is taken since nothing will be printed if the list is empty.

Nothing is printed if maxOccurs is zero.

If the type of the element is apparently complex but no type of the
given name can be found, this prints an error message and exits. 

*/

void xml2owlGenerator::printCodePrintElement( /* ARGUMENTS                  */
 XmlElementLocal * element,                /* element to print              */
 char * haserName,                         /* deTyped name of element owner */
 char * owlPrefix)                         /* owlPrefix to use              */
{
  XmlSimpleType * simple;
  bool isBasic;

  if (element->newTyp == 0)
    {
      fprintf(stderr, "element %s must have a type\n", element->name);
      exit(1);
    }
  simple = findSimpleClass(element->newTyp);
  isBasic = (element->typPrefix &&
	     (strcmp(element->typPrefix, XmlCppBase::wg3Prefix) == 0));
  if (!simple && !isBasic && !findComplexClass(element->newTyp))
    {
      fprintf(stderr, "complex class not found in printCodePrintElement");
      exit(1);
    }
  if ((element->maxOccurs == -1) || (element->maxOccurs > 1))
    { // multiple elements are allowed, need list, (-1 means unbounded)
      printCodePrintElementMulti(element, haserName,
				 owlPrefix, simple, isBasic);
    }
  else if ((element->maxOccurs == 1) || (element->maxOccurs < -1))
    { // only one element allowed (maxOccurs < -1 means maxOccurs not used)
      printCodePrintElementSingle(element, haserName,
				  owlPrefix, simple, isBasic);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintElementMulti

Returned Value: none

Called By: xml2owlGenerator::printCodePrintElement

This prints code for translating an element to OWL if zero to many
instances of the element are allowed. If there are zero, it is
expected that a list will exist but be empty.

*/

void xml2owlGenerator::printCodePrintElementMulti( /* ARGUMENTS             */
 XmlElementLocal * element,                /* element to print              */
 char * haserName,                         /* deTyped name of element owner */
 char * owlPrefix,                         /* owlPrefix to use              */
 XmlSimpleType * simple,                   /* null if not simple            */
 bool isBasic)                             /* true if basic, else false     */
{
  static char typeName[NAMESIZE];
  static char nameName[NAMESIZE];
  int n;

  fprintf(ccFile, "  {\n");
  if (simple)
    {
      strncpy(typeName, element->newTyp, NAMESIZE);
      fprintf(ccFile, "    std::list<%s *>::iterator iter;\n", typeName);
      fprintf(ccFile, "    for (iter = %s->begin();\n", element->newName);
      fprintf(ccFile, "         iter != %s->end(); iter++)\n",
	      element->newName);
      fprintf(ccFile, "      {\n");
      fprintf(ccFile, "        (*iter)->printProp(\"%s:has%s_%s\",\n",
	      owlPrefix, haserName, element->name);
      fprintf(ccFile, "                           Name, outFile);\n");
      fprintf(ccFile, "      }\n");
    }
  else if (strcmp(element->newTyp, "IDREF") == 0)
    { // isBasic is true in this case
      findCppTypeName(element->newTyp, typeName);
      deNameName(element->newName, nameName);
      fprintf(ccFile, "    std::list<%s *>::iterator iter;\n", typeName);
      fprintf(ccFile, "    for (iter = %s->begin();\n", element->newName);
      fprintf(ccFile, "         iter != %s->end(); iter++)\n",
	      element->newName);
      fprintf(ccFile, "      {\n");
      fprintf(ccFile, "        printer.printObjRefProp(\"%s:has%s_%s\",\n",
	      owlPrefix, haserName, nameName);
      fprintf(ccFile,
	      "                                Name, *iter, outFile);\n");
      fprintf(ccFile, "      }\n");
    }
  else if (isBasic)
    {
      findCppTypeName(element->newTyp, typeName);
      fprintf(ccFile, "    std::list<%s *>::iterator iter;\n", typeName);
      fprintf(ccFile, "    for (iter = %s->begin();\n", element->newName);
      fprintf(ccFile,  "        iter != %s->end(); iter++)\n",
	      element->newName);
      fprintf(ccFile, "      {\n");
      fprintf(ccFile, "        printer.print%sProp(\"%s:has%s_%s\",\n",
	      typeName, owlPrefix, haserName, element->name);
      for (n = (26 + strlen(typeName)); n > 0; n--)
	fprintf(ccFile, " ");
      fprintf(ccFile, "Name, *iter, outFile);\n");
      fprintf(ccFile, "      }\n");
    }
  else // must be complex
    {
      fprintf(ccFile, "    std::list<%s *>::iterator iter;\n", element->newTyp);
      fprintf(ccFile, "    for (iter = %s->begin();\n", element->newName);
      fprintf(ccFile, "         iter != %s->end(); iter++)\n",
	      element->newName);
      fprintf(ccFile, "      {\n");
      fprintf(ccFile,
	      "        printer.printObjProp(\"%s:has%s_%s\",\n",
	      owlPrefix, haserName, element->name);
      fprintf(ccFile,
	      "                             Name, (*iter)->Name, outFile);\n");
      fprintf(ccFile, "        (*iter)->printOwl(outFile);\n");
      fprintf(ccFile, "      }\n");
    }
  fprintf(ccFile, "  }\n");
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintElementSingle

Returned Value: none

Called By: xml2owlGenerator::printCodePrintElement

This prints code for translating an element to OWL if zero or one
instance of the element is allowed.

*/

void xml2owlGenerator::printCodePrintElementSingle( /* ARGUMENTS            */
 XmlElementLocal * element,                /* element to print              */
 char * haserName,                         /* deTyped name of element owner */
 char * owlPrefix,                         /* owlPrefix to use              */
 XmlSimpleType * simple,                   /* null if not simple            */
 bool isBasic)                             /* true if basic, else false     */
{
  static char typeName[NAMESIZE];
  static char nameName[NAMESIZE];
  static const char * space2 = "  ";
  static const char * space6 = "      ";
  const char * space;
  int n;

  if (element->minOccurs == 0)
    { // element is optional and may be 0
      fprintf(ccFile, "  if (%s)\n", element->newName);
      fprintf(ccFile, "    {\n");
      space = space6;
    }
  else
    space = space2;
  if (simple)
    {
      fprintf(ccFile, "%s%s->printProp(\"%s:has%s_%s\",\n",
	      space, element->newName, owlPrefix, haserName, element->name);
      for (n = (12 + strlen(space) + strlen(element->newName)); n > 0; n--)
	fprintf(ccFile, " ");
      fprintf(ccFile, "Name, outFile);\n");
    }
  else if (strcmp(element->newTyp, "IDREF") == 0)
    { // isBasic is true in this case
      deNameName(element->newName, nameName);
      fprintf(ccFile, "%sprinter.printObjRefProp(\"%s:has%s_%s\",\n",
	      space, owlPrefix, haserName, nameName);
      fprintf(ccFile, "%s                        Name, %s, outFile);\n",
	      space, element->name);
    }
  else if (isBasic)
    {
      findCppTypeName(element->newTyp, typeName);
      fprintf(ccFile, "%sprinter.print%sProp(\"%s:has%s_%s\",\n",
	      space, typeName, owlPrefix, haserName, element->newName);
      for (n = (18 + strlen(space) + strlen(typeName)); n > 0; n--)
	fprintf(ccFile, " ");
      fprintf(ccFile, "Name, %s, outFile);\n", element->name);
    }
  else // must be complex
    {
      fprintf(ccFile, "%sprinter.printObjProp(\"%s:has%s_%s\",\n",
	      space, owlPrefix, haserName, element->name);
      fprintf(ccFile, "%s                     Name, %s->Name, outFile);\n",
	      space, element->name);
      fprintf(ccFile, "%s%s->printOwl(outFile);\n", space, element->newName);
    }
  if (element->minOccurs == 0)
    fprintf(ccFile, "    }\n");
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintIndividuals

Returned Value: none

Called By: xml2owlGenerator::printCodeStart

This prints code for printing OWL lists of different individuals.

*/

void xml2owlGenerator::printCodePrintIndividuals() /* NO ARGUMENTS */
{
  std::list<XmlType *>::iterator iter;
  XmlComplexType * complx;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)) &&
	  (!(complx->abstract)))
	{
	  deTypeName(complx->newName, nameBuffer);
	  fprintf(ccFile, "  if (%s::individuals.size() > 1)\n",
		  complx->newName);
	  fprintf(ccFile, "    printer.printIndividuals(\"%s:%s\",\n",
		  complx->owlPrefix, nameBuffer);
	  fprintf(ccFile, "       &%s::individuals, outFile);\n",
		  complx->newName);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintItems

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodePrintParentItems
  xml2owlGenerator::printCodeSequence

This prints in the C++ code file some or all of the body of the
printOwl function. Any element named "Name" is not printed (for the
usual reason that names are implicit in OWL but explicit in XML schema).

*/

void xml2owlGenerator::printCodePrintItems( /* ARGUMENTS                  */
 std::list<XmlChoSeqItem *> * items,        /* items to print from        */
 char * haserName,                          /* deTyped name of owner type */
 char * owlPrefix)                          /* owlPrefix to use           */
{
  std::list<XmlChoSeqItem *>::iterator iter;
  XmlElementLocal * element;
  
  for (iter = items->begin(); iter != items->end(); iter++)
    {
      if ((element = dynamic_cast<XmlElementLocal *>(*iter)) &&
	  strcmp(element->name, "Name"))
	printCodePrintElement(element, haserName, owlPrefix);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodePrintParentItems

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodePrintParentItems (recursively)

This prints the lines of a printOwl function for an XmlComplexExtension that
represent inherited elements.

This calls itself recursively to handle extension depths greater than one.
The recursive calls print before the function prints since the XML elements
of a parent occur before those of the extension.

If the baseClass is 0, or if a complex restriction is encountered,
this prints an error message and exits.

*/

void xml2owlGenerator::printCodePrintParentItems( /* ARGUMENTS  */
 XmlComplexType * baseClass)                      /* base class */
{
  char noTypeName[NAMESIZE];
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * extend;
  XmlComplexType * parent;
  XmlSequence * sequence;

  if (baseClass == 0)
    {
      fprintf(stderr,
	      "base class %s not found in printCodePrintParentItems\n",
	      baseClass->name);
      exit(1);
    }
  deTypeName(baseClass->name, noTypeName);
  if ((other = dynamic_cast<XmlOtherContent *>(baseClass->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
	{
	  printCodePrintItems(sequence->items, noTypeName,
			      baseClass->owlPrefix);
	}
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(baseClass->item)))
    {
      if ((extend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	{
	  parent = findComplexClass(extend->base);
	  printCodePrintParentItems(parent);
	  if ((sequence = dynamic_cast<XmlSequence *>(extend->item)))
	    {
	      printCodePrintItems(sequence->items, noTypeName,
				  baseClass->owlPrefix);
	    }
	}
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex restriction\n");
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeRestrictEnum

Returned Value: none

Called By:  xml2owlGenerator::printCodeRestrictString

This prints in the C++ code file the implementation of a class derived
from an XmlSimpleRestriction whose base in an XML string. The
restriction must all be XmlEnumerations. If any restriction is not
an enumeration, this prints an error message and exits.

The restrictions list should not be null, but it may be empty.

*/

void xml2owlGenerator::printCodeRestrictEnum(    /*  ARGUMENTS               */
 char * newName,                                 /* name for class           */
 char * parentName,                              /* name of parent class     */
 char * rootCppTypeName,                         /* name of root C++ class   */
 char * rootXmlTypeName,                         /* name of root XML datatype*/
 std::list<XmlRestrictionType *> * restrictions) /* restrictions giving enum */
{
  XmlEnumeration * enumer;
  std::list<XmlRestrictionType *>::iterator iter;
  
  fprintf(ccFile, "%s::%s() :\n", newName, newName);
  fprintf(ccFile, "  %s() {}\n", parentName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::%s(\n", newName, newName);
  fprintf(ccFile, " char * valIn) :\n");
  fprintf(ccFile, "  %s(valIn)\n", parentName);
  fprintf(ccFile, "{");
  if (restrictions->size())
    {
      fprintf(ccFile, "\n");
      fprintf(ccFile, "  if (!bad)\n");
      fprintf(ccFile, "    bad = (");
      for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
	{
	  enumer = dynamic_cast<XmlEnumeration *>(*iter);
	  if (!enumer)
	    {
	      fprintf(stderr, "all restrictions must be enumerations\n");
	      exit(1);
	    }
	  fprintf(ccFile, "strcmp(val.c_str(), \"%s\"%s", enumer->value,
		  ((*iter == restrictions->back()) ? "));\n" :
		   ") &&\n           "));
	}
    }
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::~%s() {}\n", newName, newName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "bool %s::%sIsBad()\n", newName, newName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  return (");
  if (restrictions->size() == 0)
    {
      fprintf(ccFile, "false);\n");
    }
  else
    {
      for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
	{
	  enumer = dynamic_cast<XmlEnumeration *>(*iter);
	  if (!enumer)
	    {
	      fprintf(stderr, "all restrictions must be enumerations\n");
	      exit(1);
	    }
	  fprintf(ccFile, "strcmp(val.c_str(), \"%s\"%s", enumer->value,
		  ((*iter == restrictions->back()) ? "));\n" :
		   ") &&\n          "));
	}
    }
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "void %s::printOwl(FILE * outFile)\n", newName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  if (%sIsBad())\n", newName);
  fprintf(ccFile, "    {\n");
  fprintf(ccFile, "      fprintf(stderr, \"bad %s value, \");\n", newName);
  fprintf(ccFile, "      %s::printSelf(stderr);\n", rootCppTypeName);
  fprintf(ccFile, "      fprintf(stderr, \" exiting\\n\");\n");
  fprintf(ccFile, "      exit(1);\n");
  fprintf(ccFile, "    }\n");
  fprintf(ccFile, "  %s::printSelf(outFile);\n", rootCppTypeName);
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "void %s::printProp(\n", newName);
  fprintf(ccFile, " const char * property,\n");
  fprintf(ccFile, " XmlID * Name,\n");
  fprintf(ccFile, " FILE * outFile)\n");
  fprintf(ccFile, "{\n");
  fprintf(ccFile,
	  "  fprintf(outFile, \"DataPropertyAssertion(%%s :\", property);\n");
  fprintf(ccFile, "  Name->printSelf(outFile);\n");
  fprintf(ccFile, "  fprintf(outFile, \"\\n\");\n");
  fprintf(ccFile, "  fprintf(outFile, \"                      \\\"\");\n");
  fprintf(ccFile, "  printOwl(outFile);\n");
  fprintf(ccFile, "  fprintf(outFile, \"\\\"^^xsd:%s)\\n\");\n",
	  rootXmlTypeName);
  fprintf(ccFile, "}\n");
}

/********************************************************************/

/* xml2owlGenerator::printCodeRestrictNumber

Returned Value: none

Called By: xml2owlGenerator::printCodeSimple

This prints in the C++ code file the implementation of a class derived from
an XmlSimpleRestriction whose base is a number, specifically:
decimal
double
float
int
integer
nonNegativeInteger
positiveInteger
long
short
unsignedInt
unsignedLong
unsignedShort

The restrictions list should not be null, but it may be empty.

*/

void xml2owlGenerator::printCodeRestrictNumber(  /* ARGUMENTS                */
 char * newName,                                 /* class name               */
 char * parentName,                    /* name of C++ class being restricted */
 char * rootCppTypeName,                         /* name of root C++ class   */
 char * rootXmlTypeName,                         /* name of root XML datatype*/
 std::list<XmlRestrictionType *> * restrictions) /* restrictions             */
{
  XmlMaxExclusive * maxEx;
  XmlMaxInclusive * maxIn;
  XmlMinExclusive * minEx;
  XmlMinInclusive * minIn;
  std::list<XmlRestrictionType *>::iterator iter;
  
  fprintf(ccFile, "%s::%s() :\n", newName, newName);
  fprintf(ccFile, "  %s() {}\n", parentName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::%s(\n", newName, newName);
  fprintf(ccFile, " char * valIn) : %s(valIn)\n", parentName);
  fprintf(ccFile, "{");
  if (restrictions->size())
    {
      fprintf(ccFile, "\n");
      fprintf(ccFile, "  if (!bad)\n");
      fprintf(ccFile, "    bad = (");
      for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
	{
	  if ((maxEx = dynamic_cast<XmlMaxExclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val >= %s)", maxEx->value);
	    }
	  else if ((maxIn = dynamic_cast<XmlMaxInclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val > %s)", maxIn->value);
	    }
	  else if ((minEx = dynamic_cast<XmlMinExclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val <= %s)", minEx->value);
	    }
	  else if ((minIn = dynamic_cast<XmlMinInclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val < %s)", minIn->value);
	    }
	  else
	    {
	      fprintf(stderr, "bad integer restriction type\n");
	      exit(1);
	    }
	  fprintf(ccFile, "%s", ((*iter == restrictions->back()) ? ");\n" :
				 " ||\n          "));
	}
    }
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::~%s() {}\n", newName, newName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "bool %s::%sIsBad()\n", newName, newName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  if (%sIsBad())\n", parentName);
  fprintf(ccFile, "    return true;\n");
  if (restrictions->size() == 0)
    fprintf(ccFile, "  return false;\n");
  else
    {
      fprintf(ccFile, "  return (");
      for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
	{
	  if ((maxEx = dynamic_cast<XmlMaxExclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val >= %s)", maxEx->value);
	    }
	  else if ((maxIn = dynamic_cast<XmlMaxInclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val > %s)", maxIn->value);
	    }
	  else if ((minEx = dynamic_cast<XmlMinExclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val <= %s)", minEx->value);
	    }
	  else if ((minIn = dynamic_cast<XmlMinInclusive *>(*iter)))
	    {
	      fprintf(ccFile, "(val < %s)", minIn->value);
	    }
	  else
	    {
	      fprintf(stderr, "bad integer restriction type\n");
	      exit(1);
	    }
	  fprintf(ccFile, "%s",
	      ((*iter == restrictions->back()) ? ");\n" : " ||\n          "));
	}
    }
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "void %s::printOwl(FILE * outFile)\n", newName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  if (%sIsBad())\n", newName);
  fprintf(ccFile, "    {\n");
  fprintf(ccFile, "      fprintf(stderr, \"bad %s value, \");\n", newName);
  fprintf(ccFile, "      %s::printSelf(stderr);\n", rootCppTypeName);
  fprintf(ccFile, "      fprintf(stderr, \" exiting\\n\");\n");
  fprintf(ccFile, "      exit(1);\n");
  fprintf(ccFile, "    }\n");
  fprintf(ccFile, "  %s::printSelf(outFile);\n", rootCppTypeName);
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "void %s::printProp(\n", newName);
  fprintf(ccFile, " const char * property,\n");
  fprintf(ccFile, " XmlID * Name,\n");
  fprintf(ccFile, " FILE * outFile)\n");
  fprintf(ccFile, "{\n");
  fprintf(ccFile,
	  "  fprintf(outFile, \"DataPropertyAssertion(%%s :\", property);\n");
  fprintf(ccFile, "  Name->printSelf(outFile);\n");
  fprintf(ccFile, "  fprintf(outFile, \"\\n\");\n");
  fprintf(ccFile, "  fprintf(outFile, \"                      \\\"\");\n");
  fprintf(ccFile, "  printOwl(outFile);\n");
  fprintf(ccFile, "  fprintf(outFile, \"\\\"^^xsd:%s)\\n\");\n",
	  rootXmlTypeName);
  fprintf(ccFile, "}\n");
}

/********************************************************************/

/* xml2owlGenerator::printCodeRestrictString

Returned Value: none

Called By: xml2owlGenerator::printCodeSimple

The restrictions list should not be null, but it may be empty.

This is called if the rootType of the newName class is a string
type (xs:ID, xs:IDREF, xs:string, xs:NMTOKEN, xs:token).

Currently, the only restrictions handled are enumerations. If any
restriction is not an enumeration, this prints an error message and exits.

*/

void xml2owlGenerator::printCodeRestrictString(  /*  ARGUMENTS               */
 char * newName,                                 /* name for class           */
 char * newBase,                                 /* name for parent          */
 char * rootCppTypeName,                         /* name of root basic type  */
 char * rootXmlTypeName,                         /* name of root XML datatype*/
 std::list<XmlRestrictionType *> * restrictions) /* restrictions             */
{
  if ((restrictions->size() == 0) ||
      (dynamic_cast<XmlEnumeration *>(restrictions->front())))
    printCodeRestrictEnum(newName,  newBase, rootCppTypeName,
			  rootXmlTypeName, restrictions);
  else
    {
      fprintf(stderr, "cannot handle string restrictions for %s\n", newName);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSchemaClasses

Returned Value: none

Called By:  xml2owlGenerator::printCode

This prints in the C++ code file the implementations of all the classes
other than XXXFile and XmlHeaderForXXX.

If any class is neither simple nor complex, this prints an error message
and exits.

*/

void xml2owlGenerator::printCodeSchemaClasses() /* NO ARGUMENTS */
{
  XmlComplexType * complx;
  XmlSimpleType * simple;
  std::list<XmlType *>::iterator iter;
  
  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	{
	  fprintf(ccFile, "/* class %s\n", complx->newName);
	  fprintf(ccFile, "\n");
	  fprintf(ccFile, "*/\n");
	  fprintf(ccFile, "\n");
	  printCodeComplex(complx);
	}
      else if ((simple = dynamic_cast<XmlSimpleType *>(*iter)))
	{
	  fprintf(ccFile, "/* class %s\n", simple->newName);
	  fprintf(ccFile, "\n");
	  fprintf(ccFile, "*/\n");
	  fprintf(ccFile, "\n");
	  printCodeSimple(simple);
	}
      else
	{
	  fprintf(stderr, "bad class type in printCodeSchemaClasses\n");
	  exit(1);
	}
      printStarLine(ccFile, true, true);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSequence

Returned Value: none

Called By:  xml2owlGenerator::printCodeComplex

This prints in the C++ code file the implementation of a class
for an XmlOtherContent that is not derived from another complexType
and contains an XmlSequence. The C++ class for such a complexType is
derived from XMLSCHEMAINSTANCEBASE and must have a Name element.

This prints 1 or 2 constructors.
1. A constructor is always defined that takes no arguments.
2. If the sequence is not empty, a constructor is defined that takes
   arguments from only the sequence.

If the complex type that contains the sequence is not abstract, this
also prints a PrintOwl function.

*/

void xml2owlGenerator::printCodeSequence( /* ARGUMENTS                        */
 XmlSequence * sequence,                  /* XmlSequence to print class for   */
 XmlComplexType * complx)                 /* XmlComplexType to print code for */
{
  char noTypeName[NAMESIZE];
  int comma = 0;
  std::list<XmlChoSeqItem *> * items;
  char * newName;                      // newName of complex type
  
  newName = complx->newName;
  items = sequence->items;
  fprintf(ccFile, "%s::%s() {", newName, newName);
  fprintf(ccFile, "}\n");
  if (items && items->size())
    {
      fprintf(ccFile, "\n");
      fprintf(ccFile, "%s::%s(", newName, newName);
      printHeaderSequenceArgs(items, &comma, "");
      fprintf(ccFile, ")\n");
      fprintf(ccFile, "{\n");
      printCodeSequenceSettings(items);
      fprintf(ccFile, "}\n");
    }
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%s::~%s() {}\n", newName, newName);
  if (!complx->abstract)
    {
      fprintf(ccFile, "\n");
      fprintf(ccFile, "void %s::printOwl(FILE * outFile)\n", newName);
      fprintf(ccFile, "{\n");
      deTypeName(newName, noTypeName);
      fprintf(ccFile, "  printer.startIndi(Name, \"%s:%s\", outFile);\n",
	      complx->owlPrefix, noTypeName);
      if (sequence->items)
	printCodePrintItems(sequence->items, noTypeName, complx->owlPrefix);
      fprintf(ccFile, "  printer.endIndi(\"%s:%s\", outFile);\n",
	      complx->owlPrefix, noTypeName);
      fprintf(ccFile, "  individuals.insert(Name->val);\n");
      fprintf(ccFile, "}\n");
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSequenceArgs

Returned Value: none

Called By:  xml2owlGenerator::printCodeBaseArgs

This prints in the C++ code some arguments of the base type
constructor called in a child type constructor. The child is an
extension of the base type. The arguments are those corresponding to
elements in a sequence in the base type. This prints only the argument
names, not the types.  Each argument is on a separate line.

The value of comma will be 0 if no other argument has been printed
yet, and in this case a newline and the argument are printed.  The
value of comma will be 1 if an argument has been printed previously,
and in this case a comma, a newline, and the argument are printed. If
this prints one or more arguments, the value of comma is set to 1.

If any item on the items list is not an element (for example if it is
a choice), this prints an error message and exits.

*/

void xml2owlGenerator::printCodeSequenceArgs(/* ARGUMENTS                     */
 std::list<XmlChoSeqItem *> * items,         /* list of items to print        */
 int * comma)                                /* non-zero = start with a comma */
{
  std::list<XmlChoSeqItem *>::iterator iter;
  XmlElementLocal * element;

  for (iter = items->begin(); iter != items->end(); iter++)
    {
      if ((element = dynamic_cast<XmlElementLocal *>(*iter)))
	{
	  fprintf(ccFile, "%s\n", (*comma ? "," : ""));
	  fprintf(ccFile, "    %sIn", element->newName);
	  *comma = 1;
	}
      else
	{
	  fprintf(stderr, "printCodeSequenceArgs cannot handle non-element\n");
	  exit(1);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSequenceSettings

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodeSequence

This prints in the C++ code file the statements of the body of the
constructor taking arguments, all of which are of the form:
 foo = fooIn;

*/

void xml2owlGenerator::printCodeSequenceSettings( /* ARGUMENTS              */
 std::list<XmlChoSeqItem *> * items)              /* list of items to print */
{
  std::list<XmlChoSeqItem *>::iterator iter;
  XmlElementLocal * element;
  
  for (iter = items->begin(); iter != items->end(); iter++)
    {
      if ((element = dynamic_cast<XmlElementLocal *>(*iter)))
	fprintf(ccFile, "  %s = %sIn;\n", element->newName, element->newName);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSetsOfIndividuals

Returned Value: none

Called By: xml2owlGenerator::printCodeStart

This prints the declarations of the sets of individuals in the C++ code file.

*/

void xml2owlGenerator::printCodeSetsOfIndividuals()
{
  std::list<XmlType *>::iterator iter;
  XmlComplexType * complx;

  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)) &&
	  (!(complx->abstract)))
	{
	  fprintf(ccFile, "std::set<std::string> %s::individuals;\n",
		  complx->newName);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeSimple

Returned Value: none

Called By: xml2owlGenerator::printCodeSchemaClasses

This prints in the C++ code file the implementation of a C++ class
equivalent to an XML type derived by restriction from an XmlSimpleType
or an XML basic type.

If the item in the simple type is a list or an unknown item type, this
prints an error message and exits.

*/

void xml2owlGenerator::printCodeSimple( /* ARGUMENTS                     */
 XmlSimpleType * simple)                /* simple type to print class for */
{
  XmlSimpleRestriction * restrict;
  XmlSimpleType * restricted;
  std::list<XmlRestrictionType *> * rests;
  static char baseCppTypeName[NAMESIZE];
  static char rootCppTypeName[NAMESIZE];
  static char rootXmlTypeName[NAMESIZE];

  if ((restrict = dynamic_cast<XmlSimpleRestriction *>(simple->item)))
    {
      rests = restrict->restrictions;
      findRootXmlType(simple, rootXmlTypeName);
      findCppTypeName(rootXmlTypeName, rootCppTypeName);
      if (restrict->basePrefix &&
	  (strcmp(restrict->basePrefix, XmlCppBase::wg3Prefix) == 0))
	findCppTypeName(restrict->newBase, baseCppTypeName);
      else
	strncpy(baseCppTypeName, restrict->newBase, NAMESIZE);
      if ((restricted = findSimpleClass(restrict->newBase)) &&
	  (dynamic_cast<XmlSimpleList *>(restricted->item)))
	{ // restriction of a list
	  fprintf(stderr, "cannot handle simple list %s\n", simple->name);
	  exit(1);
	}
      else if (isStringy(rootCppTypeName))
	printCodeRestrictString(simple->newName, baseCppTypeName,
				rootCppTypeName, rootXmlTypeName, rests);
      else if (isNumber(rootCppTypeName))
	printCodeRestrictNumber(simple->newName, baseCppTypeName,
				rootCppTypeName, rootXmlTypeName, rests);
      else
	{
	  fprintf(stderr, "cannot handle %s, which restricts %s\n",
		  simple->name, restrict->base);
	  exit(1);
	}
    }
  else if (dynamic_cast<XmlSimpleList *>(simple->item))
    { // restriction of a list
      fprintf(stderr, "cannot handle simple list %s\n", simple->name);
      exit(1);
    }
  else
    {
      fprintf(stderr, "cannot handle simple type %s\n", simple->name);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printCodeStart

Returned Value: none

Called By: xml2owlGenerator::printCode

This prints in the C++ code file:
  - seven includes
  - an extern declaration
  - declarations of sets of individuals
  - the implementation of xxxFile, which contains:
    * two constructors
    * a destructor
    * a printOwl function that prints the whole OWL instance file

The name of the root element is in the top-level element; that element has
already been checked, so this does not recheck it.

*/

void xml2owlGenerator::printCodeStart( /* ARGUMENTS        */
 char * baseName)                      /* base name to use */
{
  char * topName;

  topName = topElement->newName;
  printStarLine(ccFile, false, true);
  fprintf(ccFile, "#include <stdio.h>             // for printf, etc.\n");
  fprintf(ccFile, "#include <string.h>            // for strdup\n");
  fprintf(ccFile, "#include <stdlib.h>            // for exit\n");
  fprintf(ccFile, "#include <list>\n");
  fprintf(ccFile, "#include \"xmlSchemaInstance.hh\"\n");
  fprintf(ccFile, "#include \"owlInstancePrinter.hh\"\n");
  fprintf(ccFile, "#include \"owl%sClasses.hh\"\n", baseName);
  printStarLine(ccFile, true, false);
  printStarLine(ccFile, false, true);
  fprintf(ccFile, "extern OwlInstancePrinter printer;\n");
  fprintf(ccFile, "\n");
  printCodeSetsOfIndividuals();
  printStarLine(ccFile, true, true);
  fprintf(ccFile, "/* class %sFile\n", topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "*/\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%sFile::%sFile() {}\n", topName, topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%sFile::%sFile(\n", topName, topName);
  fprintf(ccFile, "  XmlVersion * versionIn,\n");
  fprintf(ccFile, "  XmlHeaderFor%s * headerIn,\n", topName);
  fprintf(ccFile, "  %s * %sIn)\n", topElement->newTyp, topName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  version = versionIn;\n");
  fprintf(ccFile, "  header = headerIn;\n");
  fprintf(ccFile, "  %s = %sIn;\n", topName, topName);
  fprintf(ccFile, "}\n");
  fprintf(ccFile, "\n");
  fprintf(ccFile, "%sFile::~%sFile() {}\n", topName, topName);
  fprintf(ccFile, "\n");
  fprintf(ccFile,"void %sFile::printOwl(FILE * outFile)\n", topName);
  fprintf(ccFile, "{\n");
  fprintf(ccFile, "  std::set<std::string>::iterator iter;\n");
  fprintf(ccFile, "  %s->printOwl(outFile);\n",  topName);
  fprintf(ccFile, "\n");
  printCodePrintIndividuals();
  fprintf(ccFile, "\n");
  fprintf(ccFile, "  fprintf(outFile, \")\\n\");\n");
  fprintf(ccFile, "}\n");
  printStarLine(ccFile, true, true);
}

/********************************************************************/

/* xml2owlGenerator::printDriver

Returned Value: none

Called By: main

This prints the driver file for the instance file translator.

If the driver file cannot be opened, this prints an error message and exits.
This is assuming that the names of the schema files in the haveRead list
all end with .xsd

The main function this prints opens the outFile (for OWL) prints the
OWL header items in the OWL file, and then calls XXXTree->printOwl to
print the rest of the OWL file.

*/

void xml2owlGenerator::printDriver( /* ARGUMENTS                   */
 char * importName,                 /* base name of file to import */
 char * baseName,                   /* base name to use            */
 char * treeName)                   /* base of tree name to use    */
{
  char * driverFileName;
  FILE * driverFile;
  int nameLength;
  std::list<char *>::iterator iter;
  std::list<char *>::iterator ator;

  nameLength = strlen(baseName);
  driverFileName = new char[nameLength + 15];
  snprintf(driverFileName, (nameLength + 14), "owl%sPrinter.cc", baseName);
  driverFile = fopen(driverFileName, "w");
  if (driverFile == 0)
    {
      fprintf(stderr, "unable to open file %s for writing\n", driverFileName);
      exit(1);
    }
  fprintf(driverFile, "#include <stdio.h>   // fprintf\n");
  fprintf(driverFile, "#include <string.h>  // strlen\n");
  fprintf(driverFile, "#include <stdlib.h>  // exit\n");
  fprintf(driverFile, "#include \"owlInstancePrinter.hh\"\n");
  fprintf(driverFile, "#include \"owl%sClasses.hh\"\n", baseName);
  fprintf(driverFile, "\n");
  fprintf(driverFile, "extern %sFile * %sTree;\n", treeName, treeName);
  fprintf(driverFile, "extern FILE * yyin;\n");
  fprintf(driverFile, "extern int yyparse();\n");
  fprintf(driverFile,
"\n"
"OwlInstancePrinter printer;\n"
"\n"
"int main(       /* ARGUMENTS                                      */\n"
" int argc,      /* one more than the number of command arguments  */\n"
" char * argv[]) /* array of executable name and command arguments */\n"
"{\n"
"  FILE * outFile;\n"
"  int n;          // for finding beginning of file name\n"
"\n"
"  if (argc != 4)\n"
"    {\n"
"      fprintf(stderr, \"Usage: %%s <xmlInstance> <owlInstance> <uri>\\n\",\n"
"              argv[0]);\n"
"      fprintf(stderr, \"xmlInstance = path to XML instance file to read\\n\");\n"
"      fprintf(stderr, \"owlInstance = name of OWL instance file to write\\n\");\n"
"      fprintf(stderr, \"uri = URI to put in header\\n\");\n"
"      fprintf(stderr, \"example: %%s data/abc.xml abc.owl http://ont\\n\",\n"
"              argv[0]);\n"
"      exit(1);\n"
"    }\n"
"  n = (strlen(argv[1]) - 4);\n"
"  if (strcmp(argv[1] + n, \".xml\"))\n"
"    {\n"
"      fprintf(stderr, \"file name %%s must end with .xml\\n\", argv[1]);\n"
"      exit(1);\n"
"    }\n"
"  yyin = fopen(argv[1], \"r\");\n"
"  if (yyin == 0)\n"
"    {\n"
"      fprintf(stderr, \"unable to open file %%s for reading\\n\", argv[1]);\n"
"      exit(1);\n"
"    }\n"
"  yyparse();\n"
"  fclose(yyin);\n"
"  outFile = fopen(argv[2], \"w\");\n"
"  if (outFile == 0)\n"
"    {\n"
"      fprintf(stderr, \"unable to open file %%s for writing\\n\", argv[2]);\n"
"      exit(1);\n"
"    }\n"
"  fprintf(outFile,\"Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)\\n\"\n"
"	  \"Prefix(owl:=<http://www.w3.org/2002/07/owl#>)\\n\"\n"
"	  \"Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)\\n\"\n"
"	  \"Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)\\n\"\n"
"	  \"Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)\\n\");\n"
"  fprintf(outFile, \"Prefix(:=<%%s/%%s#>)\\n\", argv[3], argv[2]);\n");
  for (iter = prefixes.begin(), ator = haveRead.begin();
       ((iter != prefixes.end()) && (ator != haveRead.end()));
       iter++, ator++)
    {
      (*ator)[strlen(*ator)- 4] = 0;
      fprintf(driverFile,
"  fprintf(outFile, \"Prefix(%s:=<%%s/%sClasses.owl#>)\\n\", argv[3]);\n",
	      *iter, *ator);
    }
  fprintf(driverFile,
	  "  fprintf(outFile, \"Ontology(<%%s/%%s>\\n\", argv[3], argv[2]);\n");
  fprintf(driverFile,
	  "  fprintf(outFile, \"Import(<file:%sClasses.owl>)\\n\");\n",
	  importName);
  fprintf(driverFile, "  %sTree->printOwl(outFile);\n", treeName);
  fprintf(driverFile, "  fclose(outFile);\n");
  fprintf(driverFile, "  return 0;\n");
  fprintf(driverFile, "}\n");
  fclose(driverFile);
  driverFile = 0;
  delete driverFileName;
}

/********************************************************************/

/* xml2owlGenerator::printHeader

Returned Value: none

Called By: main

This prints the C++ header file.

If the base name is Xxx , the header file name is "owlXxxClasses.hh".

If the header file cannot be opened, this prints an error message and exits.

*/

void xml2owlGenerator::printHeader( /* ARGUMENTS        */
 char * baseName)                   /* base name to use */
{
  static char buffer[NAMESIZE];
  int n;

  sprintf(buffer, "owl%sClasses.hh", baseName);
  hhFile = fopen(buffer, "w");
  if (hhFile == 0)
    {
      fprintf(stderr, "could not open file %s for writing\n", buffer);
      exit(1);
    }
  allCaps(baseName, buffer);
  for(n = 0; buffer[n]; n++)
    {
      if (buffer[n] == '-')
	buffer[n] = '_';
    }
  printStarLine(hhFile, false, true);
  fprintf(hhFile, "#ifndef %s_OWL_HH\n", buffer);
  fprintf(hhFile, "#define %s_OWL_HH\n", buffer);
  printHeaderStart();
  printHeaderSchemaClasses();
  printHeaderEnd();
  fprintf(hhFile, "#endif // %s_OWL_HH\n", buffer);
  fclose(hhFile);
  hhFile = 0;
}

/********************************************************************/

/* xml2owlGenerator::printHeaderBaseArgs

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printHeaderBaseArgs (recursively)
  xml2owlGenerator::printHeaderComplexExtend

This prints in the C++ header or code file the arguments to the
constructor of an extension that exist because the base type has them.

This calls itself recursively to handle extension depths greater than
one. The arguments for the parent type get printed before those for
the child type.

Note that this starts out by printing either a comma and a newline or
just a newline. Thus, the caller should not put a newline on the
preceding line.

If any of the following occurs, this prints an error message and exits:
- The complex type with the given baseName cannot be found.
- A complex restriction is encountered.
- The complex type has simple content (must be adding attributes).
- The complex type has complex content with an unknown item type.

*/

void xml2owlGenerator::printHeaderBaseArgs( /* ARGUMENTS                     */
 char * baseName,                           /* name of base class            */
 int * comma,                               /* non-zero = start with a comma */
 const char * space)                        /* extra space at start of line  */
{
  XmlComplexType * complx;
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * compExtend;
  XmlSequence * sequence;

  complx = findComplexClass(baseName);
  if (complx == 0)
    {
      fprintf(stderr, "base class %s not found in printHeaderBaseArgs\n",
	      baseName);
      exit(1);
    }
  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
	{
	  printHeaderSequenceArgs(sequence->items, comma, space);
	}
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
    {
      if ((compExtend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	{
	  printHeaderBaseArgs(compExtend->base, comma, space);
	  if ((sequence = dynamic_cast<XmlSequence *>(compExtend->item)))
	    {
	      printHeaderSequenceArgs(sequence->items, comma, space);
	    }
	}
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex restriction\n");
	  exit(1);
	}
      else
	{
	  fprintf(stderr, "bad complex content type\n");
	  exit(1);
	}
    }
  else if (dynamic_cast<XmlSimpleContent *>(complx->item))
    {
      fprintf(stderr, "cannot handle simple content in complex type\n");
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderComplex

Returned Value: none

Called By: xml2owlGenerator::printHeaderSchemaClassComplex

This prints in the C++ header file the definition of a class derived from
an XmlComplexType.

When a complex type has no content except possibly attributes
(which may happen if, for example, the type is an abstract parent
type), complex->item is set in xmlSchema.y to an XmlOtherContent that
has no base and may or may not have attributes. Here that is handled
by printHeaderOtherMinimal.

If any of the following occurs, this prints an error message and exits:
- The complex type has other content with a base that is a choice.
- The complex type has simple or unknown content.
- The complex type has complex content with an item that is a restriction
- The complex type has complex content with an item of unknown type.

*/

void xml2owlGenerator::printHeaderComplex( /* ARGUMENTS                     */
  XmlComplexType * complx)             /* XmlComplexType to print class for */
{
  XmlOtherContent * other;
  XmlComplexContent * comp;
  XmlComplexExtension * compExtend;
  XmlSequence * sequence;

  if ((other = dynamic_cast<XmlOtherContent *>(complx->item)))
    {
      if ((sequence = dynamic_cast<XmlSequence *>(other->base)))
	printHeaderSequence(sequence, complx->newName, complx->abstract);
      else if (dynamic_cast<XmlChoice *>(other->base))
	{
	  fprintf(stderr, "cannot handle choice\n");
	  exit(1);
	}
      else
        printHeaderOtherMinimal(complx->newName);
    }
  else if ((comp = dynamic_cast<XmlComplexContent *>(complx->item)))
    {
      if ((compExtend = dynamic_cast<XmlComplexExtension *>(comp->item)))
	printHeaderComplexExtend(compExtend, complx->newName, complx->abstract);
      else if ((dynamic_cast<XmlComplexRestriction *>(comp->item)))
	{
	  fprintf(stderr, "cannot handle complex content restriction\n");
	  exit(1);
	}
      else
	{
	  fprintf(stderr, "bad complex content type in printHeaderComplex\n");
	  exit(1);
	}
    }
  else
    {
      fprintf(stderr, "cannot handle content of complex type %s\n",
	      complx->name);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderComplexExtend

Returned Value: none

Called By: xml2owlGenerator::printHeaderComplex

This prints in the C++ header file the definition of a class derived from
an XmlComplexExtension.

If the class is not abstract, this prints the declaration of printOwl.
 
This also prints 1 or 2 constructors.
1. A constructor taking no arguments.
2. If the extension has a sequence or any part of its base has a sequence,
   a constructor taking arguments corresponding to the sequence items.

This also prints the declaration of a printTypp data member. This is
needed only because the YACC file for parsing the XML instance file
(which is generated for multiple uses) needs it.

This also prints the declaration of the "individuals" data member, which
is a list of strings (to be populated with the names of individuals).

The sequence variable is the elements added to the type by the extension.

The arguments to the constructor taking all C++ attributes must include
the names of all the C++ attributes of the base type from which the
extension is derived. This is accomplished by calling printHeaderBaseArgs.

*/

void xml2owlGenerator::printHeaderComplexExtend( /* ARGUMENTS               */
 XmlComplexExtension * extend,    /* XmlComplexExtension to print class for */
 char * newName,                  /* newName of complex type                */
 bool abstract)                   /* true=abstract complex type, false=not  */
{
  XmlSequence * sequence;
  int comma;
  int hasSequence = 0;

  if (dynamic_cast<XmlChoice *>(extend->item))
    {
      fprintf(stderr,
	      "cannot handle choice in the extension in %s\n", newName);
      exit(1);
    }
  sequence = dynamic_cast<XmlSequence *>(extend->item);
  if (sequence && sequence->items->size())
    hasSequence = 1;
  if (hasSequence == 0) 
    checkBaseArgs(extend->base, &hasSequence);
  fprintf(hhFile, "class %s :\n", newName);
  fprintf(hhFile, "  public %s\n", extend->base);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", newName);
  if (hasSequence)
    {
      comma = 0;
      fprintf(hhFile, "  %s(", newName);
      printHeaderBaseArgs(extend->base, &comma, "   ");
      if (sequence && sequence->items->size())
	{
	  printHeaderSequenceArgs(sequence->items, &comma, "   ");
	}
      fprintf(hhFile, ");\n");
    }
  fprintf(hhFile, "  ~%s();\n", newName);
  if (!abstract)
    {
      fprintf(hhFile, "  void printOwl(FILE * outFile);\n");
    }
  if (sequence || !abstract)
    fprintf(hhFile, "\n");
  if (sequence)
    {
      printHeaderSequenceItems(sequence->items);
    }
  if (!abstract)
    {
      fprintf(hhFile, "  static std::set<std::string> individuals;\n");
    }
  fprintf(hhFile, "\n");
  fprintf(hhFile, "  bool printTypp;\n");
  fprintf(hhFile, "};\n");
}

/********************************************************************/

/* xml2owlGenerator::printHeaderEnd

Returned Value: none

Called By: xml2owlGenerator::printHeader

This prints the XmlHeaderForXXX class declaration. The XmlHeaderForXXX
is not used for anything when an OWL instance file is created from an
XML instance file, but the YACC file (which is shared by the three
generators) expects the OWL and XML classes to have the same constructors.

*/

void xml2owlGenerator::printHeaderEnd() /* NO ARGUMENTS    */
{
  fprintf(hhFile, "class XmlHeaderFor%s\n", topElement->newName);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  XmlHeaderFor%s();\n", topElement->newName);
  fprintf(hhFile, "  XmlHeaderFor%s(\n", topElement->newName);
  fprintf(hhFile, "    SchemaLocation * locationIn);\n");
  fprintf(hhFile, "  ~XmlHeaderFor%s();\n", topElement->newName);
  fprintf(hhFile, "  void printOwl(FILE * outFile);\n");
  fprintf(hhFile, "\n");
  fprintf(hhFile, "  SchemaLocation * location;\n");
  fprintf(hhFile, "};\n");
  printStarLine(hhFile, true, true);
}

/********************************************************************/

/* xml2owlGenerator::printHeaderOtherMinimal

Returned Value: none

Called By: xml2owlGenerator::printHeaderComplex

This prints in the C++ header file the definition of a class derived
from an XmlOtherContent that is not derived from another complexType
and does not contain an XmlSequence. The C++ classes for such
complexTypes are derived from XMLSCHEMAINSTANCEBASE.

This prints a constructor that takes no arguments.

This prints printSelf and printOwl functions that do nothing. That
might not be necessary, but at one time having no printSelf function
caused a compiler error.

*/

void xml2owlGenerator::printHeaderOtherMinimal( /* ARGUMENTS               */
 char * newName)                                /* newName of complex type */
{
  fprintf(hhFile, "class %s :\n", newName);
  fprintf(hhFile, "  public %s\n", XMLSCHEMAINSTANCEBASE);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", newName);
  fprintf(hhFile, "  ~%s();\n", newName);
  fprintf(hhFile, "  void printSelf(FILE * outFile) {}\n");
  fprintf(hhFile, "  virtual void printOwl(FILE * outFile) {}\n");
  fprintf(hhFile, "};\n");
}

/********************************************************************/

/* xml2owlGenerator::printHeaderRestrictEnum

Returned Value: none

Called By: xml2owlGenerator::printHeaderRestrictString

This prints in the C++ header file the definition of a class derived from
an XmlSimpleRestriction of a stringy type.

When this is called, it is known that either the restrictions list is
empty or the first item on the restrictions list is an XmlEnumeration.
In the second case, all the items should be XmlEnumerations.  This
checks that all the items are XmlEnumerations and then prints the body
of the class declaration.

The restrictions list may not be null, but it may be empty.

If any restriction is not an enumeration, this prints an error message
and exits.

*/

void xml2owlGenerator::printHeaderRestrictEnum(  /* ARGUMENTS                */
 char * newName,                                 /* class name               */
 char * parentName,                    /* name of C++ class being restricted */
 std::list<XmlRestrictionType *> * restrictions) /* restrictions             */
{
  XmlEnumeration * enumer;
  std::list<XmlRestrictionType *>::iterator iter;
  
  for (iter = restrictions->begin(); iter != restrictions->end(); iter++)
    {
      enumer = dynamic_cast<XmlEnumeration *>(*iter);
      if (!enumer)
	{
	  fprintf(stderr, "all restrictions must be enumerations\n");
	  exit(1);
	}
    }
  fprintf(hhFile, "  public %s\n", parentName);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", newName);
  fprintf(hhFile, "  %s(\n", newName);
  fprintf(hhFile, "    char * valIn);\n");
  fprintf(hhFile, "  ~%s();\n", newName);
  fprintf(hhFile, "  bool %sIsBad();\n", newName);
  fprintf(hhFile,
"  void printOwl(FILE * outFile);\n"
"  void printProp(const char * property, XmlID * Name, FILE * outFile);\n");
}

/********************************************************************/

/* xml2owlGenerator::printHeaderRestrictNumber

Returned Value: none

Called By: xml2owlGenerator::printHeaderSimple

This prints in the C++ header file the definition of a class derived from
an XmlSimpleRestriction when the base type is a number type.

Each restriction must be one of the following, and there may be at
most one of each:
  XmlMaxExclusive
  XmlMaxInclusive
  XmlMinExclusive
  XmlMinInclusive
  
This checks that all the conditions above are satisfied and then prints the
body of the class declaration.

The restrictions list may not be null, but it may be empty.

*/

void xml2owlGenerator::printHeaderRestrictNumber( /* ARGUMENTS               */
 char * newName,                                  /* name of class           */
 char * parentName,                    /* name of C++ class being restricted */
 std::list<XmlRestrictionType *> * restrictions)  /* restrictions            */
{
  checkNumberRestrictions(restrictions);
  fprintf(hhFile, "  public %s\n", parentName);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", newName);
  fprintf(hhFile, "  %s(\n", newName);
  fprintf(hhFile, "    char * valIn);\n");
  fprintf(hhFile, "  ~%s();\n", newName);
  fprintf(hhFile, "  bool %sIsBad();\n", newName);
  fprintf(hhFile,
"  void printOwl(FILE * outFile);\n"
"  void printProp(const char * property, XmlID * Name, FILE * outFile);\n");
}

/********************************************************************/

/*  xml2owlGenerator::printHeaderRestrictString

Returned Value: none

Called By:  xml2owlGenerator::printHeaderSimple

The restrictions list may not be null, but it may be empty.

This is called if the root type of the newName class is a string
type (xs:ID, xs:IDREF, xs:string, xs:NMTOKEN, xs:token).

Currently, the only restrictions handled are enumerations. If one of the
restrictions is not an enumeration, this prints an error message and exits.

*/

void  xml2owlGenerator::printHeaderRestrictString( /* ARGUMENTS               */
 char * newName,                                   /* class name              */
 char * parentName,                     /* name of C++ class being restricted */
 std::list<XmlRestrictionType *> * restrictions)   /* restrictions            */
{
  if ((restrictions->size() == 0) ||
      (dynamic_cast<XmlEnumeration *>(restrictions->front())))
    printHeaderRestrictEnum(newName, parentName, restrictions);
  else
    {
      fprintf(stderr, "cannot handle string restrictions for %s\n", newName);
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSchemaClassComplex

Returned Value: none

Called By: xml2owlGenerator::printHeaderSchemaClasses

If a complex type has a base class, this checks whether the base class
has been printed already. If not, this does not print anything. If so,
this prints the class and any attribute classes. If a class is
printed, totalPrinted is increased by 1 and progress is set to 1.

If a class is not found that has been named as a base class or if the
complex type has simple content (which implies it is an extension with
attributes), this prints an error message and exits.

*/

void xml2owlGenerator::printHeaderSchemaClassComplex(/* ARGUMENTS           */
 XmlComplexType * complx,              /* XmlComplexType to print class for */
 unsigned int * totalPrinted,          /* number of classes printed         */
 int * progress)                       /* set to 1 if something is printed  */
{
  XmlComplexContent * cont = 0;
  XmlSimpleContent * simple = 0;
  XmlComplexType * comp = 0;
  XmlComplexExtension * compExtend = 0;
  bool printIt;

  if ((cont = dynamic_cast<XmlComplexContent *>(complx->item)) &&
      (compExtend = dynamic_cast<XmlComplexExtension *>(cont->item)))
    {
      comp = findComplexClass(compExtend->base);
      if (comp == 0)
	{
	  fprintf(stderr, "base class %s not found in "
		  "printHeaderSchemaClasses\n", compExtend->base);
	  exit(1);
	}
      printIt = comp->hhPrinted;
    }
  else if ((simple = dynamic_cast<XmlSimpleContent *>(complx->item)))
    {
      fprintf(stderr, "Cannot handle complex extension of simple type\n");
      exit(1);
    }
  else
    printIt = true;
  if (printIt)
    {
      printHeaderComplex(complx);
      printStarLine(hhFile, true, true);
      (*totalPrinted)++;
      *progress = 1;
      complx->hhPrinted = true;
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSchemaClasses

Returned Value: none

Called By: xml2owlGenerator::printHeader

This prints in the C++ header file the definitions of classes derived
from the XmlComplexTypes and the XmlSimpleTypes in an XML Schema.
It does this by going through the "classes" list repeatedly.
Each time it prints the ones that have not yet been printed and
are ready to print.

The C++ class for an XmlComplexExtension has the C++ class for the
base of the extension as a parent type. In a C++ header file, a parent
type must appear before any of its child types. Therefore, this makes
sure that parent classes get printed before child classes. Whenever an
XmlComplexExtension is found, this prints the class for it only if the
base class has been printed.

If two or more XmlComplexExtensions form a loop (e.g., B extends A, C
extends B, and A extends C), which is illegal, the classes for them
will never get printed. To check for that, this checks that when nothing
more can be printed (indicated by "progress" being false), the total
number of classes printed (excluding the attribute classes) is the same
as the number of entries in the "classes" list. If that is not the case,
this prints an error message and exits.

If a type is neither simple nor complex, this prints an error message
and exits.

*/

void xml2owlGenerator::printHeaderSchemaClasses() /* NO ARGUMENTS */
{
  XmlComplexType * complx;
  XmlSimpleType * simple;
  std::list<XmlType *>::iterator iter;
  int progress = 1;
  unsigned int totalPrinted = 0;
  
  while (progress)
    {
      progress = 0;
      for (iter = classes.begin(); iter != classes.end(); iter++)
	{
	  if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	    {
	      if (complx->hhPrinted == true)
		continue;
	      printHeaderSchemaClassComplex(complx, &totalPrinted, &progress);
	    }
	  else if ((simple = dynamic_cast<XmlSimpleType *>(*iter)))
	    {
	      if (simple->hhPrinted == true)
		continue;
	      printHeaderSchemaClassSimple(simple, &totalPrinted, &progress);
	    }
	  else
	    {
	      fprintf(stderr, "bad class type in printHeaderSchemaClasses\n");
	      exit(1);
	    }
	}
    }
  if (totalPrinted < classes.size())
    {
      fprintf(stderr, "schema contains circular definitions; exiting\n");
      exit(1);
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSchemaClassNames

Returned Value: none

Called By: xml2owlGenerator::printHeaderStart

This prints in the C++ header file the declarations of classes derived
from types in the XML schema.

A class name is printed for each class in the classes list.

If a type is neither simple nor complex, this prints an error message
and exits.

*/

void xml2owlGenerator::printHeaderSchemaClassNames() /*NO ARGUMENTS*/
{
  XmlComplexType * complx;
  XmlSimpleType * simple;
  std::list<XmlType *>::iterator iter;
  
  for (iter = classes.begin(); iter != classes.end(); iter++)
    {
      if ((complx = dynamic_cast<XmlComplexType *>(*iter)))
	{
	  fprintf(hhFile, "class %s;\n", complx->newName);
	}
      else if ((simple = dynamic_cast<XmlSimpleType *>(*iter)))
	{
	  fprintf(hhFile, "class %s;\n", simple->newName);
	}
      else
	{
	  fprintf(stderr, "bad class type\n");
	  exit(1);
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSchemaClassSimple

Returned Value: none

Called By: xml2owlGenerator::printHeaderSchemaClasses

If a simple type has a base class, this checks whether the base class
has been printed already. If not, this does not print anything. If so,
this prints the class.  If a class is printed, totalPrinted is
increased by 1 and progress is set to 1.

If a list type or unknown simple type is encountered, this prints an
error message and exits.

*/

void xml2owlGenerator::printHeaderSchemaClassSimple(/* ARGUMENTS           */
 XmlSimpleType * simple,               /* XmlSimpleType to print class for */
 unsigned int * totalPrinted,          /* number of classes printed        */
 int * progress)                       /* set to 1 if something is printed */
{
  XmlSimpleRestriction * restrict;
  XmlSimpleType * simp = 0;
  XmlSimpleList * aList;
  bool printIt;

  if ((restrict = dynamic_cast<XmlSimpleRestriction *>(simple->item)))
    {
      if (restrict->basePrefix &&
	  (strcmp(restrict->basePrefix, XmlCppBase::wg3Prefix) == 0))
	{
	  printIt = true;
	}
      else if ((simp = findSimpleClass(restrict->newBase)))
	{
	  printIt = simp->hhPrinted;
	}
    }
  else if ((aList = dynamic_cast<XmlSimpleList *>(simple->item)))
    {
      fprintf(stderr, "cannot handle list type %s\n", simple->name);
      exit(1);
    }
  else
    {
      fprintf(stderr, "cannot handle simple type %s\n", simple->name);
      exit(1);
    }
  if (printIt)
    {
      printHeaderSimple(simple);
      printStarLine(hhFile, true, true);
      (*totalPrinted)++;
      *progress = 1;
      simple->hhPrinted = true;
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSequence

Returned Value: none

Called By: xml2owlGenerator::printHeaderComplex

This prints in the C++ header file the definition of a class derived
from an XmlOtherContent that is not derived from another complexType
and contains an XmlSequence. The C++ classes for such complexTypes are
derived from XMLSCHEMAINSTANCEBASE. 

This prints declarations of 1 or 2 constructors.
1. A constructor is always declared that takes no arguments.
2. If the sequence is not empty, a constructor is declared that takes
   arguments from only the sequence.

This prints a printSelf function that does nothing (having no
printSelf function causes a compiler error). It also prints a virtual
printOwl function that does nothing.

*/

void xml2owlGenerator::printHeaderSequence(   /* ARGUMENTS                   */
 XmlSequence * sequence,            /* XmlSequence to print class for        */
 char * newName,                    /* newName of complex type               */
 bool abstract)                     /* true=abstract complex type, false=not */
{
  int comma;

  fprintf(hhFile, "class %s :\n", newName);
  fprintf(hhFile, "  public %s\n", XMLSCHEMAINSTANCEBASE);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", newName);
  if (sequence->items->size())
    {
      comma = 0;
      fprintf(hhFile, "  %s(", newName);
      printHeaderSequenceArgs(sequence->items, &comma, "   ");
      fprintf(hhFile, ");\n");
    }
  fprintf(hhFile, "  ~%s();\n", newName);
  fprintf(hhFile, "  void printSelf(FILE * outFile) {}\n");
  if (abstract)
    fprintf(hhFile, "  virtual void printOwl(FILE * outFile) {}\n");
  else
    fprintf(hhFile, "  void printOwl(FILE * outFile);\n");
  fprintf(hhFile, "\n");
  printHeaderSequenceItems(sequence->items);
  if (!abstract)
    {
      fprintf(hhFile, "  static std::set<std::string> individuals;\n");
    }
  fprintf(hhFile, "};\n");
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSequenceArgs

Returned Value: none

Called By:
  xml2owlGenerator::printCodeComplexExtend
  xml2owlGenerator::printCodeSequence
  xml2owlGenerator::printHeaderBaseArgs
  xml2owlGenerator::printHeaderComplexExtend
  xml2owlGenerator::printHeaderSequence

This prints in the C++ header or code file the arguments to the class
constructor taking arguments when the class represents an XML schema
complexType containing an XML schema sequence.

The value of comma will be 0 if no other argument has been printed
yet, and in this case a newline is printed followed by the argument.
The value of comma will be 1 if an argument has been printed previously,
and in this case a comma and a newline are printed followed by
the argument. If this prints one or more arguments, the value of comma
is set to 1.

The space argument is needed since the code printers use a different
amount of space at the beginning of the line (one space) than the
header printers (four spaces).

If the type of an element in the sequence is an XmlComplexType or
XmlSimpleType, then the type of the argument is the name of the type.

This function works only if each element has a typ (i.e., only if the
schema is in canonical form).

If a sequence contains something that is not an element (i.e. a choice
or a sequence), this prints an error message and exits.

*/

void xml2owlGenerator::printHeaderSequenceArgs( /* ARGUMENTS                 */
 std::list<XmlChoSeqItem *> * items,        /* list of items to print        */
 int * comma,                               /* non-zero = start with a comma */
 const char * space)                        /* extra space at start of line  */
{
  std::list<XmlChoSeqItem *>::iterator iter;
  XmlElementLocal * element;
  char typeName[NAMESIZE];
  bool isBasic;

  for (iter = items->begin(); iter != items->end(); iter++)
    {
      if ((element = dynamic_cast<XmlElementLocal *>(*iter)))
	{
	  isBasic = (element->typPrefix &&
		     (strcmp(element->typPrefix, XmlCppBase::wg3Prefix) == 0));
	  if ((element->maxOccurs == -1) || (element->maxOccurs > 1))
	    { // multiple elements are allowed, need list
	      if (element->newTyp)
		{
		  fprintf(hhFile, "%s\n", (*comma ? "," : ""));
		  if (isBasic)
		    {
		      findCppTypeName(element->newTyp, typeName);
		      fprintf(hhFile, "%s std::list<%s *> * %sIn",
			      space, typeName, element->newName);
		    }
		  else
		    {
		      fprintf(hhFile, "%s std::list<%s *> * %sIn",
			      space, element->newTyp, element->newName);
		    }
		  *comma = 1;
		}
	    }
	  else if ((element->maxOccurs == 1) || (element->maxOccurs < -1))
	    { // only one element allowed
	      if (element->newTyp)
		{
		  fprintf(hhFile, "%s\n", (*comma ? "," : ""));
		  if (isBasic)
		    {
		      findCppTypeName(element->newTyp, typeName);
		      fprintf(hhFile, "%s %s * %sIn",
			      space, typeName, element->newName);
		    }
		  else
		    {
		      fprintf(hhFile, "%s %s * %sIn",
			      space, element->newTyp, element->newName);
		    }
		  *comma = 1;
		}
	    }
	  else; // maxOccurs is 0, so print nothing
	}
      else
	{
	  fprintf(stderr,
		  "printHeaderSequenceArgs cannot handle non-element\n");
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSequenceItems

Returned Value: none

Called By:
  xml2owlGenerator::printHeaderComplexExtend
  xml2owlGenerator::printHeaderSequence

This prints in the C++ header file the C++ attributes of a class when the
class contains an XML schema sequence.

If the type of an element in the sequence is an XmlComplexType or
an XmlSimpleType, then the type of the C++ attribute is the name of
the type.

If a sequence contains something that is not an element (i.e. a choice
or a sequence), this prints an error message and exits.

*/

void xml2owlGenerator::printHeaderSequenceItems( /* ARGUMENTS              */
 std::list<XmlChoSeqItem *> * items)             /* list of items to print */
{
  std::list<XmlChoSeqItem *>::iterator iter;
  XmlElementLocal * element;
  char typeName[NAMESIZE];
  bool isBasic;

  for (iter = items->begin(); iter != items->end(); iter++)
    {
      if ((element = dynamic_cast<XmlElementLocal *>(*iter)))
	{
	  isBasic = (element->typPrefix &&
		     (strcmp(element->typPrefix, XmlCppBase::wg3Prefix) == 0));
	  if ((element->maxOccurs == -1) || (element->maxOccurs > 1))
	    { // multiple elements are allowed, need list
	      if (element->newTyp)
		{
		  if (isBasic)
		    {
		      findCppTypeName(element->newTyp, typeName);
		      fprintf(hhFile, "  std::list<%s *> * %s;\n",
			      typeName, element->newName);
		    }
		  else
		    {
		      fprintf(hhFile, "  std::list<%s *> * %s;\n",
			      element->newTyp, element->newName);
		    }
		}
	    }
	  else if ((element->maxOccurs == 1) || (element->maxOccurs < -1))
	    { // only one element allowed
	      if (element->newTyp)
		{
		  if (isBasic)
		    {
		      findCppTypeName(element->newTyp, typeName);
		      fprintf(hhFile, "  %s * %s;\n",
			      typeName, element->newName);
		    }
		  else
		    {
		      fprintf(hhFile, "  %s * %s;\n",
			      element->newTyp, element->newName);
		    }
		}
	    }
	}
      else
	{
	  fprintf(stderr,
		  "printHeaderSequenceItems cannot handle non-element\n");
	  
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::printHeaderSimple

Returned Value: none

Called By: xml2owlGenerator::printHeaderSchemaClassSimple

This prints in the C++ header file the definition of a C++ class
equivalent to an XML type derived by restriction or listing from an
XmlSimpleType or an XML built-in type.

This handles restrictions of the XML built-in types listed below and
restrictions of those types.

decimal
double
float
ID
IDREF
int
integer
long
NMTOKEN
nonNegativeInteger
positiveInteger
short
string
token
unsignedInt
unsignedLong
unsignedShort

If any other type of restriction is encountered (such as a restriction
of a boolean), or if a simple list is encountered, or if an unknown
simple type is encountered, this prints an error message and exits.

*/

void xml2owlGenerator::printHeaderSimple( /* ARGUMENTS                     */
 XmlSimpleType * simple)               /* XmlSimpleType to print class for */
{
  XmlSimpleRestriction * restrict; // the simple type 
  XmlSimpleType * restricted;
  std::list<XmlRestrictionType *> * rests;
  static char baseCppTypeName[NAMESIZE];
  static char rootCppTypeName[NAMESIZE];
  static char rootXmlTypeName[NAMESIZE];
  char * base;

  fprintf(hhFile, "class %s :\n", simple->newName);
  if ((restrict = dynamic_cast<XmlSimpleRestriction *>(simple->item)))
    {
      rests = restrict->restrictions;
      findRootXmlType(simple, rootXmlTypeName);
      findCppTypeName(rootXmlTypeName, rootCppTypeName);
      base = restrict->base;
      if (restrict->basePrefix &&
	  (strcmp(restrict->basePrefix, XmlCppBase::wg3Prefix) == 0))
	findCppTypeName(restrict->newBase, baseCppTypeName);
      else
	strncpy(baseCppTypeName, restrict->newBase, NAMESIZE);
      if ((restricted = findSimpleClass(restrict->newBase)) &&
	  (dynamic_cast<XmlSimpleList *>(restricted->item)))
	{ // restriction of a list
	  fprintf(stderr, "cannot handle list %s in printHeaderSimple\n",
		  simple->name);
	  exit(1);
	}
      else if (isStringy(rootCppTypeName))
	printHeaderRestrictString(simple->newName, baseCppTypeName, rests);
      else if (isNumber(rootCppTypeName))
	printHeaderRestrictNumber(simple->newName, baseCppTypeName, rests);
      else
	{
	  fprintf(stderr, "cannot handle %s, which restricts %s\n",
		  simple->name, base);
	  exit(1);
	}
    }
  else if (dynamic_cast<XmlSimpleList *>(simple->item))
    {
      fprintf(stderr, "cannot handle list in printHeaderSimple\n");
      exit(1);
    }
  else
    {
      fprintf(stderr, "cannot handle simple type %s\n", simple->name);
      exit(1);
    }
  fprintf(hhFile, "};\n");
}

/********************************************************************/

/* xml2owlGenerator::printHeaderStart

Returned Value: none

Called By: xml2owlGenerator::printHeader

This prints in the C++ header file:
  - three includes
  - the declaration of the XXXFile class needed in every header file
    derived from an XML schema (if the input file is not an included file)
  - the declarations of C++ classes derived from types in the XML schema
  - the definition of the XXXFile class (if the input file is not an
    included file)

*/

void xml2owlGenerator::printHeaderStart() /* NO ARGUMENTS */
{
  std::list<char *>::iterator iter;

  fprintf(hhFile, "#include <stdio.h>\n");
  fprintf(hhFile, "#include <list>\n");
  fprintf(hhFile, "#include \"xmlSchemaInstance.hh\"\n");
  printStarLine(hhFile, true, true);
  snprintf(className, NAMESIZE, "%sFile", topElement->newName);
  fprintf(hhFile, "class %s;\n", className);
  printHeaderSchemaClassNames();
  fprintf(hhFile, "class XmlHeaderFor%s;\n", topElement->newName);
  printStarLine(hhFile, true, false);
  printStarLine(hhFile, false, true);
  fprintf(hhFile, "class %s :\n", className);
  fprintf(hhFile, "  public %s\n", XMLSCHEMAINSTANCEBASE);
  fprintf(hhFile, "{\n");
  fprintf(hhFile, "public:\n");
  fprintf(hhFile, "  %s();\n", className);
  fprintf(hhFile, "  %s(\n", className);
  fprintf(hhFile, "    XmlVersion * versionIn,\n");
  fprintf(hhFile, "    XmlHeaderFor%s * headerIn,\n", topElement->newName);
  fprintf(hhFile, "    %s * %sIn);\n", topElement->newTyp, topElement->newName);
  fprintf(hhFile, "  ~%s();\n", className);
  fprintf(hhFile, "  void printOwl(FILE * outFile);\n");
  fprintf(hhFile, "  void printSelf(FILE * outFile) {}\n");
  fprintf(hhFile, "\n");
  fprintf(hhFile, "  XmlVersion * version;\n");
  fprintf(hhFile, "  XmlHeaderFor%s * header;\n", topElement->newName);
  fprintf(hhFile, "  %s * %s;\n", topElement->newTyp, topElement->newName);
  fprintf(hhFile, "};\n");
  printStarLine(hhFile, true, true);
}

/********************************************************************/

/* xml2owlGenerator::printStarLine

Returned Value: none

Called By:
  xml2owlGenerator::printCodeEnd
  xml2owlGenerator::printCodeSchemaClasses
  xml2owlGenerator::printCodeStart
  xml2owlGenerator::printHeader
  xml2owlGenerator::printHeaderEnd
  xml2owlGenerator::printHeaderSchemaClassComplex
  xml2owlGenerator::printHeaderSchemaClassSimple
  xml2owlGenerator::printHeaderStart

This prints a (comment) line of stars, possibly preceded by a blank line
and possibly followed by a blank line.

*/

void xml2owlGenerator::printStarLine( /* ARGUMENTS                         */
 FILE * file,                /* file to print in                           */
 bool before,                /* if true, print blank line before star line */
 bool after)                 /* if true, print blank line after star line  */
{
  if (before)
    fprintf(file, "\n");
  fprintf(file,
"/*********************************************************************/\n");
  if (after)
    fprintf(file, "\n");
}

/********************************************************************/

/* xml2owlGenerator::processIncludes

Returned Value: none

Called By:
  xml2owlGenerator::readSchema

This puts onto the toRead list the names of any included schemas in
contents1 that are not on the haveRead list and are not already on the
toRead list.

*/

void xml2owlGenerator::processIncludes() /* NO ARGUMENTS */
{
  std::list<XmlSchemaContent1 *>::iterator iter;
  std::list<char *>::iterator ator;
  std::list<char *>::iterator etur;
  XmlInclude * incl;

  for (iter = contents1->begin(); iter != contents1->end(); iter++)
    {
      if ((incl = dynamic_cast<XmlInclude *>(*iter)))
	{
	  for (ator = haveRead.begin(); ator != haveRead.end(); ator++)
	    {
	      if (strcmp(*ator, incl->schemaLocation) == 0)
		break;
	    }
	  for (etur = toRead.begin(); etur != toRead.end(); etur++)
	    {
	      if (strcmp(*etur, incl->schemaLocation) == 0)
		break;
	    }
	  if ((ator == haveRead.end()) &&  // have not read yet and
	      (etur == toRead.end()))      // not already on toRead list
	    { // need to put name in toRead
	      toRead.push_back(incl->schemaLocation);
	      continue;
	    }
	}
    }
}

/********************************************************************/

/* xml2owlGenerator::readSchema

Returned Value: none

Called By:
  main

This reads the schema whose name is first on the toRead list; this is
called only if that list is not empty. The name of the file that is
read is removed from the toRead list and added to the haveRead list.
File names are added to the toRead list in processIncludes.

The first time this is called, XmlCppBase::wg3Prefix (a static class
attribute of xmlCppBase) is set in yylex. XmlCppBase::wg3Prefix should
not be reset the other times this is called. That is checked.

*/

void xml2owlGenerator::readSchema( /* ARGUMENTS                          */
 bool isTop)                       /* true=first schema, false=not first */
{
  char * savedPrefix;
  char * fileName;     // name of schema to read

  fileName = toRead.front();
  yyin = fopen(fileName, "r");
  if (yyin == 0)
    {
      fprintf(stderr, "unable to open file %s for reading\n", fileName);
      exit(1);
    }
  if (isTop) // if zero, XmlCppBase::wg3Prefix is reset by yyparse
    XmlCppBase::wg3Prefix = 0;
  else
    savedPrefix = XmlCppBase::wg3Prefix;
  yyparse();
  fclose(yyin);
  toRead.pop_front();
  haveRead.push_back(fileName);
  prefixes.push_back(strdup(globalOwlPrefix));
  if (!isTop && strncmp(savedPrefix, XmlCppBase::wg3Prefix, NAMESIZE))
    { // should never get here since yylex makes the same check
      fprintf(stderr, 
	      "included files must use same wg3Prefix as including file\n");
      exit(1);
    }
  contents1 = xmlSchemaFile->schema->contents1;
  contents2 = xmlSchemaFile->schema->contents2;
  processIncludes();
  buildClasses(isTop);
}

/********************************************************************/

/* xml2owlGenerator::xml2owlGenerator

This is the constructor for the xml2owlGenerator class.  It puts a
zero in the first place of the className and nameBuffer global (to the
xml2owlGenerator) buffers.

*/

xml2owlGenerator::xml2owlGenerator() /* NO ARGUMENTS */
{
  className[0] = 0;
  nameBuffer[0] = 0;
}

/********************************************************************/

/* xml2owlGenerator::~xml2owlGenerator

This is the destructor for the xml2owlGenerator class. It does nothing.

*/

xml2owlGenerator::~xml2owlGenerator() {}

/********************************************************************/

/* main

The first argument (argv[1]) is the name of an XML schema file,
for example, kitting.xsd

The second argument (argv[2]) is the base name for the output files.
If the base name is "XXX":
  driverFileName is "owlXXXPrinter.cc"
  headerFileName is "owlXXXClasses.hh"
  codeFileName is   "owlXXXClasses.cc"

If the input file cannot be opened, this prints an error message and exits.

The way included files are handled differs from the they way they are
handled in the xmlInstanceParserGenerator and the xmlSchemaOwlClassGenerator.
Those write a (2 C++ or 1 Owl) file for each input XML schema file.
The xml2owlGenerator just writes C++ header and code files corresponding to
the contents of all the input XML schema files. To do their work, the other
two generators create a generator for each input file. The xml2owlGenerator
has only one generator.

This makes sure each input file gets read once and only once by
maintaining two lists of file names: toRead and haveRead. Control of
the lists is shared by the main function, the readSchema function, and
the processIncludes function. The main function puts the top level
schema on the toRead list and then keeps calling the readSchema
function as long as the toRead list is not empty. The readSchema function
reads the first schema on the toRead list, removes its name from that
list, and adds the name to the haveRead list. Then it calls processIncludes.
ProcessIncludes looks at the includes for the schema that was just read,
and if any of them is not on the toRead or haveRead list, adds its name
to the end of the toRead list.

FIX, maybe -- May also require other text strings to insert in files,
such as the URI and file name in the instance file header. Split out
the argument reader and usage message into separate functions if more
user-given names are required.

*/

int main(       /* ARGUMENTS                                      */
 int argc,      /* one more than the number of command arguments  */
 char * argv[]) /* array of executable name and command arguments */
{
  xml2owlGenerator generator;
  bool isTop;
  char * upBaseName;

  if (argc != 3)
    {
      fprintf(stderr, "Usage: %s <schema file name> <output base name>\n",
	      argv[0]);
      fprintf(stderr, "example: %s kitting.xsd kitting\n", argv[0]);
      exit(1);
    }
  isTop = true;
  for (generator.toRead.push_back(argv[1]); generator.toRead.size(); )
    {
      generator.readSchema(isTop);
      isTop = false;
    }
  generator.enterKids();
  generator.checkClasses();
  upBaseName = strdup(argv[2]);
  upBaseName[0] = toupper(upBaseName[0]);
  generator.printDriver(argv[2], upBaseName, generator.topElement->newName);
  generator.printHeader(upBaseName);
  generator.printCode(upBaseName);
  return 0;
}

/********************************************************************/
